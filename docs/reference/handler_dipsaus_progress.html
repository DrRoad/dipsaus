<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Progress-bar Handler — handler_dipsaus_progress • dipsaus</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Progress-bar Handler — handler_dipsaus_progress" />
<meta property="og:description" content="Handler for progress2 to support
progressr::handlers. See examples for detailed use case" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">dipsaus</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.0.6</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/async_evaluator.html">Asynchronous Evaluator</a>
    </li>
    <li>
      <a href="../articles/r_expr_addons.html">R Expression Add-ons</a>
    </li>
    <li>
      <a href="../articles/shiny_customized_widgets.html">Shiny Customized Widgets</a>
    </li>
    <li>
      <a href="../articles/utility_functions.html">Utility Functions</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/dipterix/dipsaus/">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Progress-bar Handler</h1>
    <small class="dont-index">Source: <a href='https://github.com/dipterix/dipsaus/blob/master/R/shiny-progress.R'><code>R/shiny-progress.R</code></a></small>
    <div class="hidden name"><code>handler_dipsaus_progress.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Handler for <code><a href='progress2.html'>progress2</a></code> to support
<code><a href='https://rdrr.io/pkg/progressr/man/handlers.html'>progressr::handlers</a></code>. See examples for detailed use case</p>
    </div>

    <pre class="usage"><span class='fu'>handler_dipsaus_progress</span>(
  <span class='kw'>title</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span>(<span class='st'>"dipsaus.progressr.title"</span>, <span class='st'>"Progress"</span>),
  <span class='kw'>intrusiveness</span> <span class='kw'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span>(<span class='st'>"progressr.intrusiveness.gui"</span>, <span class='fl'>1</span>),
  <span class='kw'>target</span> <span class='kw'>=</span> <span class='kw'>if</span> (<span class='fu'><a href='https://rdrr.io/r/base/NULL.html'>is.null</a></span>(<span class='kw pkg'>shiny</span><span class='kw ns'>::</span><span class='fu'><a href='https://rdrr.io/pkg/shiny/man/domains.html'>getDefaultReactiveDomain</a></span>())) <span class='st'>"terminal"</span> <span class='kw'>else</span> <span class='st'>"gui"</span>,
  <span class='no'>...</span>
)</pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>title</th>
      <td><p>default title of <code><a href='progress2.html'>progress2</a></code></p></td>
    </tr>
    <tr>
      <th>intrusiveness</th>
      <td><p>A non-negative scalar on how intrusive
(disruptive) the reporter to the user</p></td>
    </tr>
    <tr>
      <th>target</th>
      <td><p>where progression updates are rendered</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>passed to <code><a href='https://rdrr.io/pkg/progressr/man/make_progression_handler.html'>make_progression_handler</a></code></p></td>
    </tr>
    </table>


    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'>

<span class='fu'><a href='https://rdrr.io/r/base/library.html'>library</a></span>(<span class='no'>progressr</span>)
<span class='fu'><a href='https://rdrr.io/r/base/library.html'>library</a></span>(<span class='no'>shiny</span>)
<span class='fu'><a href='https://rdrr.io/r/base/library.html'>library</a></span>(<span class='no'>future</span>)

<span class='co'>## ------------------------------ Setup! -------------------------------</span>
<span class='fu'><a href='https://rdrr.io/pkg/progressr/man/handlers.html'>handlers</a></span>(<span class='fu'>handler_dipsaus_progress</span>())</div><div class='output co'>#&gt; NULL</div><div class='input'>
<span class='co'># ------------------------------ A simple usage ------------------------</span>
<span class='no'>xs</span> <span class='kw'>&lt;-</span> <span class='fl'>1</span>:<span class='fl'>5</span>
<span class='fu'><a href='https://rdrr.io/pkg/progressr/man/handlers.html'>handlers</a></span>(<span class='fu'>handler_dipsaus_progress</span>())</div><div class='output co'>#&gt; [[1]]
#&gt; [[1]]
#&gt; tryCatch(withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try(signalCondition(e))
#&gt; }), error = function(e) {
#&gt;     NULL
#&gt;     try(stop(e))
#&gt; }, interrupt = function(e) {
#&gt;     NULL
#&gt;     e
#&gt; })
#&gt; 
#&gt; [[2]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[3]]
#&gt; tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
#&gt;     names[nh], parentenv, handlers[[nh]])
#&gt; 
#&gt; [[4]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[5]]
#&gt; tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
#&gt; 
#&gt; [[6]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[7]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[8]]
#&gt; withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try(signalCondition(e))
#&gt; })
#&gt; 
#&gt; [[9]]
#&gt; saveRDS(do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36")
#&gt; 
#&gt; [[10]]
#&gt; do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv)
#&gt; 
#&gt; [[11]]
#&gt; (function (what, args, quote = FALSE, envir = parent.frame()) 
#&gt; {
#&gt;     if (!is.list(args)) 
#&gt;         stop("second argument must be a list")
#&gt;     if (quote) 
#&gt;         args &lt;- lapply(args, enquote)
#&gt;     .Internal(do.call(what, args, envir))
#&gt; })(function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; }, list(pkg = list(package = "dipsaus", version = "0.0.6", src_path = "/Users/beauchamplab/Dropbox/projects/dipsaus", 
#&gt;     dst_path = "/Users/beauchamplab/Dropbox/projects/dipsaus/docs", 
#&gt;     desc = &lt;environment&gt;, meta = list(), figures = list(dev = "grDevices::png", 
#&gt;         dpi = 96L, dev.args = list(), fig.ext = "png", fig.width = 7.29166666666667, 
#&gt;         fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839), 
#&gt;     repo = list(url = list(home = "https://github.com/dipterix/dipsaus/", 
#&gt;         source = "https://github.com/dipterix/dipsaus/blob/master/", 
#&gt;         issue = "https://github.com/dipterix/dipsaus/issues/", 
#&gt;         user = "https://github.com/")), development = list(destination = "dev", 
#&gt;         mode = "release", version_label = "default", version_tooltip = "Released version", 
#&gt;         in_dev = FALSE), topics = list(name = c(AbstractMap.Rd = "AbstractMap", 
#&gt;     AbstractQueue.Rd = "AbstractQueue", MasterEvaluator.Rd = "MasterEvaluator", 
#&gt;     PersistContainer.Rd = "PersistContainer", actionButtonStyled.Rd = "actionButtonStyled", 
#&gt;     ask_or_default.Rd = "ask_or_default", ask_yesno.Rd = "ask_yesno", 
#&gt;     async.Rd = "async", async_expr.Rd = "async_expr", async_flapply.Rd = "async_flapply", 
#&gt;     base64_to_image.Rd = "base64_to_image", baseline_array.Rd = "baseline_array", 
#&gt;     cat2.Rd = "cat2", check_installed_packages.Rd = "check_installed_packages", 
#&gt;     col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", compoundInput2.Rd = "compoundInput2", 
#&gt;     decorate_function.Rd = "decorate_function", deparse_svec.Rd = "deparse_svec", 
#&gt;     dev_create.Rd = "dev_create", do_aggregate.Rd = "do_aggregate", 
#&gt;     drop_nulls.Rd = "drop_nulls", eval_dirty.Rd = "eval_dirty", 
#&gt;     fastmap2.Rd = "fastmap2", forelse.Rd = "forelse", getInputBinding.Rd = "getInputBinding", 
#&gt;     get_cpu.Rd = "get_cpu", get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", 
#&gt;     `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", `grapes-help-set-grapes.Rd` = "%?&lt;-%", 
#&gt;     `grapes-plus-grapes.Rd` = "%+-%", handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;     iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;     lock.Rd = "lock", make_async_evaluator.Rd = "make_async_evaluator", 
#&gt;     make_forked_clusters.Rd = "make_forked_clusters", map.Rd = "map", 
#&gt;     match_calls.Rd = "match_calls", mem_limit2.Rd = "mem_limit2", 
#&gt;     no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;     parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;     progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;     screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;     shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;     time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;     to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;     updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;     use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), file_in = c("AbstractMap.Rd", 
#&gt;     "AbstractQueue.Rd", "MasterEvaluator.Rd", "PersistContainer.Rd", 
#&gt;     "actionButtonStyled.Rd", "ask_or_default.Rd", "ask_yesno.Rd", 
#&gt;     "async.Rd", "async_expr.Rd", "async_flapply.Rd", "base64_to_image.Rd", 
#&gt;     "baseline_array.Rd", "cat2.Rd", "check_installed_packages.Rd", 
#&gt;     "col2hexStr.Rd", "collapse.Rd", "compoundInput2.Rd", "decorate_function.Rd", 
#&gt;     "deparse_svec.Rd", "dev_create.Rd", "do_aggregate.Rd", "drop_nulls.Rd", 
#&gt;     "eval_dirty.Rd", "fastmap2.Rd", "forelse.Rd", "getInputBinding.Rd", 
#&gt;     "get_cpu.Rd", "get_dots.Rd", "get_ram.Rd", "grapes-equals-greater-than-grapes.Rd", 
#&gt;     "grapes-help-set-grapes.Rd", "grapes-plus-grapes.Rd", "handler_dipsaus_progress.Rd", 
#&gt;     "iapply.Rd", "lapply_async2.Rd", "lock.Rd", "make_async_evaluator.Rd", 
#&gt;     "make_forked_clusters.Rd", "map.Rd", "match_calls.Rd", "mem_limit2.Rd", 
#&gt;     "no_op.Rd", "package_installed.Rd", "parse_svec.Rd", "prepare_install.Rd", 
#&gt;     "progress2.Rd", "registerInputBinding.Rd", "screenshot.Rd", 
#&gt;     "set_shiny_input.Rd", "shift_array.Rd", "sync_shiny_inputs.Rd", 
#&gt;     "time_delta.Rd", "to_datauri.Rd", "to_ram_size.Rd", "updateActionButtonStyled.Rd", 
#&gt;     "updateCompoundInput2.Rd", "update_fastmap2.Rd", "use_shiny_dipsaus.Rd"
#&gt;     ), file_out = c("AbstractMap.html", "AbstractQueue.html", 
#&gt;     "MasterEvaluator.html", "PersistContainer.html", "actionButtonStyled.html", 
#&gt;     "ask_or_default.html", "ask_yesno.html", "async.html", "async_expr.html", 
#&gt;     "async_flapply.html", "base64_to_image.html", "baseline_array.html", 
#&gt;     "cat2.html", "check_installed_packages.html", "col2hexStr.html", 
#&gt;     "collapse.html", "compoundInput2.html", "decorate_function.html", 
#&gt;     "deparse_svec.html", "dev_create.html", "do_aggregate.html", 
#&gt;     "drop_nulls.html", "eval_dirty.html", "fastmap2.html", "forelse.html", 
#&gt;     "getInputBinding.html", "get_cpu.html", "get_dots.html", 
#&gt;     "get_ram.html", "grapes-equals-greater-than-grapes.html", 
#&gt;     "grapes-help-set-grapes.html", "grapes-plus-grapes.html", 
#&gt;     "handler_dipsaus_progress.html", "iapply.html", "lapply_async2.html", 
#&gt;     "lock.html", "make_async_evaluator.html", "make_forked_clusters.html", 
#&gt;     "map.html", "match_calls.html", "mem_limit2.html", "no_op.html", 
#&gt;     "package_installed.html", "parse_svec.html", "prepare_install.html", 
#&gt;     "progress2.html", "registerInputBinding.html", "screenshot.html", 
#&gt;     "set_shiny_input.html", "shift_array.html", "sync_shiny_inputs.html", 
#&gt;     "time_delta.html", "to_datauri.html", "to_ram_size.html", 
#&gt;     "updateActionButtonStyled.html", "updateCompoundInput2.html", 
#&gt;     "update_fastmap2.html", "use_shiny_dipsaus.html"), alias = list(
#&gt;         AbstractMap.Rd = "AbstractMap", AbstractQueue.Rd = "AbstractQueue", 
#&gt;         MasterEvaluator.Rd = "MasterEvaluator", PersistContainer.Rd = "PersistContainer", 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled", ask_or_default.Rd = "ask_or_default", 
#&gt;         ask_yesno.Rd = "ask_yesno", async.Rd = "async", async_expr.Rd = "async_expr", 
#&gt;         async_flapply.Rd = "async_flapply", base64_to_image.Rd = "base64_to_image", 
#&gt;         baseline_array.Rd = "baseline_array", cat2.Rd = "cat2", 
#&gt;         check_installed_packages.Rd = "check_installed_packages", 
#&gt;         col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", 
#&gt;         compoundInput2.Rd = "compoundInput2", decorate_function.Rd = c("decorate_function", 
#&gt;         "%D%"), deparse_svec.Rd = "deparse_svec", dev_create.Rd = "dev_create", 
#&gt;         do_aggregate.Rd = "do_aggregate", drop_nulls.Rd = "drop_nulls", 
#&gt;         eval_dirty.Rd = "eval_dirty", fastmap2.Rd = c("fastmap2", 
#&gt;         "[[.fastmap2", "$.fastmap2", "[[&lt;-.fastmap2", "$&lt;-.fastmap2", 
#&gt;         "[.fastmap2", "[&lt;-.fastmap2", "names.fastmap2", "print.fastmap2", 
#&gt;         "length.fastmap2", "as.list.fastmap2"), forelse.Rd = "forelse", 
#&gt;         getInputBinding.Rd = "getInputBinding", get_cpu.Rd = "get_cpu", 
#&gt;         get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", 
#&gt;         `grapes-help-set-grapes.Rd` = "%?&lt;-%", `grapes-plus-grapes.Rd` = "%+-%", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;         iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;         lock.Rd = c("lock", "dipsaus_lock", "dipsaus_unlock"), 
#&gt;         make_async_evaluator.Rd = "make_async_evaluator", make_forked_clusters.Rd = "make_forked_clusters", 
#&gt;         map.Rd = c("map", "session_map", "rds_map", "text_map", 
#&gt;         "qs_map", "redis_map"), match_calls.Rd = "match_calls", 
#&gt;         mem_limit2.Rd = "mem_limit2", no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;         parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;         progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;         screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;         shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;         time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;         to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), funs = list(
#&gt;         AbstractMap.Rd = character(0), AbstractQueue.Rd = character(0), 
#&gt;         MasterEvaluator.Rd = character(0), PersistContainer.Rd = character(0), 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled()", ask_or_default.Rd = "ask_or_default()", 
#&gt;         ask_yesno.Rd = "ask_yesno()", async.Rd = "async()", async_expr.Rd = "async_expr()", 
#&gt;         async_flapply.Rd = "async_flapply()", base64_to_image.Rd = "base64_to_image()", 
#&gt;         baseline_array.Rd = "baseline_array()", cat2.Rd = "cat2()", 
#&gt;         check_installed_packages.Rd = "check_installed_packages()", 
#&gt;         col2hexStr.Rd = "col2hexStr()", collapse.Rd = "collapse()", 
#&gt;         compoundInput2.Rd = "compoundInput2()", decorate_function.Rd = c("decorate_function()", 
#&gt;         "`%D%`"), deparse_svec.Rd = "deparse_svec()", dev_create.Rd = "dev_create()", 
#&gt;         do_aggregate.Rd = "do_aggregate()", drop_nulls.Rd = "drop_nulls()", 
#&gt;         eval_dirty.Rd = "eval_dirty()", fastmap2.Rd = c("fastmap2()", 
#&gt;         "`[[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "names(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "print(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "length(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "as.list(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)"
#&gt;         ), forelse.Rd = "forelse()", getInputBinding.Rd = "getInputBinding()", 
#&gt;         get_cpu.Rd = "get_cpu()", get_dots.Rd = "get_dots()", 
#&gt;         get_ram.Rd = "get_ram()", `grapes-equals-greater-than-grapes.Rd` = "`%=&amp;gt;%`", 
#&gt;         `grapes-help-set-grapes.Rd` = "`%?&amp;lt;-%`", `grapes-plus-grapes.Rd` = "`%+-%`", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress()", 
#&gt;         iapply.Rd = "iapply()", lapply_async2.Rd = "lapply_async2()", 
#&gt;         lock.Rd = c("dipsaus_lock()", "dipsaus_unlock()"), make_async_evaluator.Rd = "make_async_evaluator()", 
#&gt;         make_forked_clusters.Rd = "make_forked_clusters()", map.Rd = c("session_map()", 
#&gt;         "rds_map()", "text_map()", "qs_map()", "redis_map()"), 
#&gt;         match_calls.Rd = "match_calls()", mem_limit2.Rd = "mem_limit2()", 
#&gt;         no_op.Rd = "no_op()", package_installed.Rd = "package_installed()", 
#&gt;         parse_svec.Rd = "parse_svec()", prepare_install.Rd = "prepare_install()", 
#&gt;         progress2.Rd = "progress2()", registerInputBinding.Rd = "registerInputBinding()", 
#&gt;         screenshot.Rd = "screenshot()", set_shiny_input.Rd = "set_shiny_input()", 
#&gt;         shift_array.Rd = "shift_array()", sync_shiny_inputs.Rd = "sync_shiny_inputs()", 
#&gt;         time_delta.Rd = "time_delta()", to_datauri.Rd = "to_datauri()", 
#&gt;         to_ram_size.Rd = "to_ram_size()", updateActionButtonStyled.Rd = "updateActionButtonStyled()", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2()", update_fastmap2.Rd = "update_fastmap2()", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus()"), title = c(AbstractMap.Rd = "Abstract Map to store key-value pairs", 
#&gt;     AbstractQueue.Rd = "Defines abstract queue class", MasterEvaluator.Rd = "Generator Class for Asynchronous Evaluation", 
#&gt;     PersistContainer.Rd = "Wrapper to cache key-value pairs and persist across sessions", 
#&gt;     actionButtonStyled.Rd = "Action Button but with customized styles", 
#&gt;     ask_or_default.Rd = "Read a Line from the Terminal, but with Default Values", 
#&gt;     ask_yesno.Rd = "Ask and Return True or False from the Terminal", 
#&gt;     async.Rd = "Evaluate expression in &lt;code&gt;async_expr&lt;/code&gt;", 
#&gt;     async_expr.Rd = "Apply R expressions in a parallel way", 
#&gt;     async_flapply.Rd = "Wrapper for &lt;code&gt;future.apply::future_lapply&lt;/code&gt;", 
#&gt;     base64_to_image.Rd = "Save \"Base64\" Data to Images", baseline_array.Rd = "Calculate Contrasts of Arrays in Different Methods", 
#&gt;     cat2.Rd = "Color Output", check_installed_packages.Rd = "Check If Packages Are Installed, Returns Missing Packages", 
#&gt;     col2hexStr.Rd = "Convert color to Hex string", collapse.Rd = "Collapse Sensors And Calculate Summations/Mean\n\n(stable)", 
#&gt;     compoundInput2.Rd = "Compound input that combines and extends shiny inputs", 
#&gt;     decorate_function.Rd = "Python-style decorator", deparse_svec.Rd = "Convert Integer Vectors To String\n\n(stable)", 
#&gt;     dev_create.Rd = "Create a group of named graphic devices", 
#&gt;     do_aggregate.Rd = "Make aggregate pipe-friendly", drop_nulls.Rd = "Drop &lt;code&gt;NULL&lt;/code&gt; values from list or vectors", 
#&gt;     eval_dirty.Rd = "Evaluate expressions", fastmap2.Rd = "A Wrapper for &lt;code&gt;fastmap::fastmap&lt;/code&gt;", 
#&gt;     forelse.Rd = "Python-style &lt;code&gt;\"for-else\"&lt;/code&gt; function", 
#&gt;     getInputBinding.Rd = "Obtain registered input bindings", 
#&gt;     get_cpu.Rd = "Get CPU Chip-set Information", get_dots.Rd = "Get element from dots &lt;code&gt;'...'&lt;/code&gt;", 
#&gt;     get_ram.Rd = "Get Memory Size", `grapes-equals-greater-than-grapes.Rd` = "A JavaScript style of creating functions", 
#&gt;     `grapes-help-set-grapes.Rd` = "Assign if not exists, or NULL\nProvides a way to assign default values to variables. If the statement\n`&lt;code&gt;lhs&lt;/code&gt;` is invalid or &lt;code&gt;NULL&lt;/code&gt;, this function will try to assign\n&lt;code&gt;value&lt;/code&gt;, otherwise nothing happens.", 
#&gt;     `grapes-plus-grapes.Rd` = "Plus-minus operator", handler_dipsaus_progress.Rd = "Progress-bar Handler", 
#&gt;     iapply.Rd = "Apply each elements with index as second input", 
#&gt;     lapply_async2.Rd = "Apply, but in parallel", lock.Rd = "Create or Unlock a Lock", 
#&gt;     make_async_evaluator.Rd = "Create Asynchronous Evaluator to Queue Tasks", 
#&gt;     make_forked_clusters.Rd = "Create forked clusters", map.Rd = "Create R object map.", 
#&gt;     match_calls.Rd = "Recursively match calls and modify arguments", 
#&gt;     mem_limit2.Rd = "Get max RAM size\nThis is an experimental function that is designed for non-windows systems", 
#&gt;     no_op.Rd = "Pipe-friendly no-operation function", package_installed.Rd = "Check if a package is installed", 
#&gt;     parse_svec.Rd = "Parse Text Into Numeric Vectors\n\n(stable)", 
#&gt;     prepare_install.Rd = "Install Packages at Next Startup", 
#&gt;     progress2.Rd = "'Shiny' progress bar, but can run without reactive context", 
#&gt;     registerInputBinding.Rd = "Register customized input to enable support by compound input", 
#&gt;     screenshot.Rd = "Take a screenshot in shiny apps", set_shiny_input.Rd = "Set Shiny Input", 
#&gt;     shift_array.Rd = "Shift Array by Index", sync_shiny_inputs.Rd = "Synchronize Shiny Inputs", 
#&gt;     time_delta.Rd = "Calculate time difference and return a number", 
#&gt;     to_datauri.Rd = "Convert file to 'base64' format", to_ram_size.Rd = "Convert bytes to KB, MB, GB,...", 
#&gt;     updateActionButtonStyled.Rd = "Update styled action button", 
#&gt;     updateCompoundInput2.Rd = "Update compound inputs", update_fastmap2.Rd = "Migrate a &lt;code&gt;fastmap2&lt;/code&gt; object to a new one", 
#&gt;     use_shiny_dipsaus.Rd = "Set up shiny plugins"), rd = list(
#&gt;         AbstractMap.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-abstract.R", 
#&gt;             "\n", list("AbstractMap"), "\n", list("AbstractMap"), 
#&gt;             "\n", list("Abstract Map to store key-value pairs"), 
#&gt;             "\n", list("\n", "Abstract Map to store key-value pairs\n"), 
#&gt;             "\n"), AbstractQueue.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/queue-abstract.R", 
#&gt;             "\n", list("AbstractQueue"), "\n", list("AbstractQueue"), 
#&gt;             "\n", list("Defines abstract queue class"), "\n", 
#&gt;             list("\n", "This class is inspired by ", list("https://cran.r-project.org/package=txtq"), 
#&gt;                 ".\n", "The difference is ", list("AbstractQueue"), 
#&gt;                 " introduce an abstract class that can\n", "be extended and can queue not only text messages, but also arbitrary R\n", 
#&gt;                 "objects, including expressions and environments. All the queue types in this\n", 
#&gt;                 "package inherit this class.\n"), "\n", list(
#&gt;                 list("Abstract Public Methods"), list("\n", "\n", 
#&gt;                   "\n", "Methods start with ", list("@..."), 
#&gt;                   " are not thread-safe. Most of them are not\n", 
#&gt;                   "used directly by users. However, you might want to override them if you\n", 
#&gt;                   "inherit this abstract class. Methods marked as \"(override)\" are not\n", 
#&gt;                   "implemented, meaning you are supposed to implement the details. Methods\n", 
#&gt;                   "marked as \"(optional)\" usually have default alternatives.\n", 
#&gt;                   "\n", list("\n", list(list(list("initialize(...)"), 
#&gt;                     " (override)"), list("\n", "The constructor. Usually three things to do during the process:\n", 
#&gt;                     "1. set ", list("get_locker"), " ", list(
#&gt;                       "free_locker"), " if you don't want to use the\n", 
#&gt;                     "default lockers. 2. set lock file (if using default lockers). 3. call\n", 
#&gt;                     list("self$connect(...)"), "\n")), "\n", 
#&gt;                     list(list(list("get_locker()"), ", ", list(
#&gt;                       "free_locker()"), " (optional)"), list(
#&gt;                       "\n", "Default is ", list("NULL"), " for each methods, and queue uses an internal\n", 
#&gt;                       list("private$default_get_locker"), " and ", 
#&gt;                       list("private$default_free_locker"), ".\n", 
#&gt;                       "These two methods are for customized locker, please\n", 
#&gt;                       "implement these two methods as functions during ", 
#&gt;                       list("self$initialization"), "\n", list(
#&gt;                         "get_locker"), " obtains and lock access (exclusive), and ", 
#&gt;                       list("free_locker"), "\n", "frees the locker. Once implemented, ", 
#&gt;                       list("private$exclusive"), " will take care\n", 
#&gt;                       "the rest. Type: function; parameters: none; return: none\n")), 
#&gt;                     "\n", list(list(list("@get_head()"), ", ", 
#&gt;                       list("@set_head(v)"), " (override)"), list(
#&gt;                       "\n", "Get head so that we know where we are in the queue ", 
#&gt;                       list("self$@get_head()"), "\n", "should return a integer indicating where we are at the queue\n", 
#&gt;                       list("self$@set_head(v)"), " stores that integer. Parameter ", 
#&gt;                       list("v"), " is always\n", "non-negative, this is guaranteed. Users are not supposed to call these\n", 
#&gt;                       "methods directly, use ", list("self$head"), 
#&gt;                       " and ", list("self$head&lt;-"), " instead.\n", 
#&gt;                       "However, if you inherit this class, you are supposed to override the methods.\n")), 
#&gt;                     "\n", list(list(list("@get_total()"), ", ", 
#&gt;                       list("@set_total(v)"), " (override)"), 
#&gt;                       list("\n", "Similar to ", list("@get_head"), 
#&gt;                         " and ", list("@set_head"), ", defines the total items\n", 
#&gt;                         "ever stored in the queue. total-head equals current items in the queue.\n")), 
#&gt;                     "\n", list(list(list("@inc_total(n=1)"), 
#&gt;                       " (optional)"), list("\n", "Increase total, usually this doesn't need to be override, unless you are\n", 
#&gt;                       "using files to store total and want to decrease number of file connections\n")), 
#&gt;                     "\n", list(list(list("@append_header(msg, ...)"), 
#&gt;                       " (override)"), list("\n", list("msg"), 
#&gt;                       " will be vector of strings, separated by \"|\", containing encoded\n", 
#&gt;                       "headers: `time`, `key`, `hash`, and `message`. to decode what's inside, you\n", 
#&gt;                       "can use ", list("self$print_items(stringr::str_split_fixed(msg, '\\|', 4))"), 
#&gt;                       ".\n", list("Make sure"), " to return a number, indicating number of items stored.\n", 
#&gt;                       "Unless handled elsewhere, usually ", list(
#&gt;                         "return(length(msg))"), ".\n")), "\n", 
#&gt;                     list(list(list("@store_value(value, key)"), 
#&gt;                       " (override)"), list("\n", "Defines how to store value. `key` is unique identifier generated from\n", 
#&gt;                       "time, queue ID, and value. Usually I use it as file name or key ID in\n", 
#&gt;                       "database. value is an arbitrary R object to store. you need to store value\n", 
#&gt;                       "somewhere and return a string that will be passed as `hash` in\n", 
#&gt;                       list("self$restore_value"), ".\n")), "\n", 
#&gt;                     list(list(list("restore_value(hash, key, preserve = FALSE)"), 
#&gt;                       " (override)"), list("\n", "Method to restore value from given combination of `hash` and `key`.\n", 
#&gt;                       "`hash` is the string returned by ", list(
#&gt;                         "@store_value"), ", and `key` is the same\n", 
#&gt;                       "as key in ", list("@store_value"), ". preserve is a indicator of whether to\n", 
#&gt;                       "preserve the value for future use. If set to ", 
#&gt;                       list("FALSE"), ", then you are\n", "supposed to free up the resource related to the value. (such as free memory\n", 
#&gt;                       "or disk space)\n")), "\n", list(list(list(
#&gt;                       "@log(n = -1, all = FALSE) (override)")), 
#&gt;                       list("\n", "get ", list("n"), " items from what you saved to during ", 
#&gt;                         list("@append_header"), ".\n", list("n"), 
#&gt;                         " less equal than 0 means listing all possible items.\n", 
#&gt;                         "If ", list("all=TRUE"), ", return all items (number of rows should equals to\n", 
#&gt;                         list("self$total"), "), including popped items. If ", 
#&gt;                         list("all=FALSE"), ", only\n", "return items in the queue (number of rows is ", 
#&gt;                         list("self$count"), "). The\n", "returned value should be a ", 
#&gt;                         list("n x 4"), " matrix. Usually I use\n", 
#&gt;                         list("stringr::str_split_fixed(..., '\\|', 4)"), 
#&gt;                         ". Please see all other\n", "types implemented for example.\n")), 
#&gt;                     "\n", list(list(list("@reset(...)"), " (override)"), 
#&gt;                       list("\n", "Reset queue, remove all items and reset head, total to be 0.\n")), 
#&gt;                     "\n", list(list(list("@clean()"), " (override)"), 
#&gt;                       list("\n", "Clean the queue, remove all the popped items.\n")), 
#&gt;                     "\n", list(list(list("@validate()"), " (override)"), 
#&gt;                       list("\n", "Validate the queue. Stop if the queue is broken.\n")), 
#&gt;                     "\n", list(list(list("@connect(con, ...)"), 
#&gt;                       " (override)"), list("\n", "Set up connection. Usually should be called at the end of\n", 
#&gt;                       list("self$initialization"), " to connect to a database, a folder, or an\n", 
#&gt;                       "existing queue you should do checks whether the connection is new or it's\n", 
#&gt;                       "an existing queue.\n")), "\n", list(list(
#&gt;                       list("connect(con, ...)"), " (optional)"), 
#&gt;                       list("\n", "Thread-safe version. sometimes you need to override this function instead\n", 
#&gt;                         "of ", list("@connect"), ", because ", 
#&gt;                         list("private$exclusive"), " requires ", 
#&gt;                         list("lockfile"), "\n", "to exist and to be locked. If you don't have lockers ready, or need to set\n", 
#&gt;                         "lockers during the connection, override this one.\n")), 
#&gt;                     "\n", list(list(list("destroy()"), " (optional)"), 
#&gt;                       list("\n", "Destroy a queue, free up space and call\n", 
#&gt;                         list("delayedAssign('.lockfile', {stop(...)}, assign.env=private)"), 
#&gt;                         " to raise\n", "error if a destroyed queue is called again later.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Methods"), 
#&gt;                 list("\n", "\n", "\n", "Usually don't need to override unless you know what you are doing.\n", 
#&gt;                   "\n", list("\n", list(list(list("push(value, message='',...)")), 
#&gt;                     list("\n", "Function to push an arbitrary R object to queue. ", 
#&gt;                       list("message"), " is a string\n", "giving notes to the pushed item. Usually message is stored with header,\n", 
#&gt;                       "separated from values. The goal is to describe the value. ", 
#&gt;                       list("..."), " is\n", "passed to ", list(
#&gt;                         "@append_header"), "\n")), "\n", list(
#&gt;                     list(list("pop(n = 1, preserve = FALSE)")), 
#&gt;                     list("\n", "Pop ", list("n"), " items from the queue. ", 
#&gt;                       list("preserve"), " indicates whether not to\n", 
#&gt;                       "free up the resources, though not always guaranteed.\n")), 
#&gt;                     "\n", list(list(list("print_item(item)"), 
#&gt;                       ", ", list("print_items(items)")), list(
#&gt;                       "\n", "To decode matrix returned by ", 
#&gt;                       list("log()"), ", returning named list or data frame\n", 
#&gt;                       "with four heads: `time`, `key`, `hash`, and `message`.\n")), 
#&gt;                     "\n", list(list(list("list(n=-1)")), list(
#&gt;                       "\n", "List items in the queue, decoded. If ", 
#&gt;                       list("n"), " is less equal than 0, then\n", 
#&gt;                       "list all results. The result is equivalent to\n", 
#&gt;                       list("self$print_items(self$log(n))"), 
#&gt;                       "\n")), "\n", list(list(list("log(n=-1,all=FALSE)")), 
#&gt;                       list("\n", "List items in the queue, encoded. This is used with ", 
#&gt;                         list("self$print_items"), ".\n", "When ", 
#&gt;                         list("all=TRUE"), ", result will list the  records ever pushed to the queue\n", 
#&gt;                         "since the last time queue is cleaned. When ", 
#&gt;                         list("all=FALSE"), ", results will be\n", 
#&gt;                         "items in the queue. ", list("n"), " is the number of items.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Active Bindings"), 
#&gt;                 list("\n", "\n", "\n", list("\n", list(list(list(
#&gt;                   "id")), list("\n", "Read-only property. Returns unique ID of current queue.\n")), 
#&gt;                   "\n", list(list(list("lockfile")), list("\n", 
#&gt;                     "The lock file.\n")), "\n", list(list(list(
#&gt;                     "head")), list("\n", "Integer, total number of items popped, i.e. inactive items.\n")), 
#&gt;                   "\n", list(list(list("total")), list("\n", 
#&gt;                     "Total number of items ever pushed to the queue since last cleaned, integer.\n")), 
#&gt;                   "\n", list(list(list("count")), list("\n", 
#&gt;                     "Integer, read-only, equals to total - head, number of active items in the\n", 
#&gt;                     "queue\n")), "\n"), "\n")), "\n", "\n", list(
#&gt;                 list("Private Methods or properties"), list("\n", 
#&gt;                   "\n", "\n", list("\n", list(list(list(".id")), 
#&gt;                     list("\n", "Don't use directly. Used to store queue ID.\n")), 
#&gt;                     "\n", list(list(list(".lockfile")), list(
#&gt;                       "\n", "Location of lock file.\n")), "\n", 
#&gt;                     list(list(list("lock")), list("\n", "Preserve the file lock.\n")), 
#&gt;                     "\n", list(list(list("exclusive(expr,...)")), 
#&gt;                       list("\n", "Function to make sure the methods are thread-safe\n")), 
#&gt;                     "\n", list(list(list("default_get_locker()")), 
#&gt;                       list("\n", "Default method to lock a queue\n")), 
#&gt;                     "\n", list(list(list("default_free_locker")), 
#&gt;                       list("\n", "Default method to free a queue\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n"), MasterEvaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("MasterEvaluator"), "\n", list("MasterEvaluator"), 
#&gt;             "\n", list("Generator Class for Asynchronous Evaluation"), 
#&gt;             "\n", list("\n", "Generator Class for Asynchronous Evaluation\n"), 
#&gt;             "\n"), PersistContainer.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/persist.R", 
#&gt;             "\n", list("PersistContainer"), "\n", list("PersistContainer"), 
#&gt;             "\n", list("Wrapper to cache key-value pairs and persist across sessions"), 
#&gt;             "\n", list("\n", "This class is designed to persist arbitrary R objects locally\n", 
#&gt;                 "and share across different sessions. The container consists two-level caches.\n", 
#&gt;                 "The first one is session-based, meaning it's only valid under current R\n", 
#&gt;                 "session and will be cleared once the session is shut down. The second is\n", 
#&gt;                 "the persist-level map, which will persist to hard drive and shared across\n", 
#&gt;                 "sessions. See ", list("cache"), " method in 'details'.\n"), 
#&gt;             "\n", list(list("Public Methods"), list("\n", "\n", 
#&gt;                 "\n", list("\n", list(list(list("initialize(..., backend = text_map)")), 
#&gt;                   list("\n", "The constructor. backend must inherit ", 
#&gt;                     list("AbstractMap"), ", ", list("..."), " will\n", 
#&gt;                     "be passed to ", list("backend$new(...)"), 
#&gt;                     ". To check available back-ends and their\n", 
#&gt;                     "use cases, see ", list(list("map")), ".\n")), 
#&gt;                   "\n", list(list(list("reset(all = FALSE)")), 
#&gt;                     list("\n", "Reset container. If all is set to be true, then reset session-based and\n", 
#&gt;                       "hard-drive-based, otherwise only reset session-based container.\n")), 
#&gt;                   "\n", list(list(list("destroy(all = FALSE)")), 
#&gt;                     list("\n", "destroy the container. Only use it when you want to finalize the container in\n", 
#&gt;                       list(list("reg.finalizer")), ".\n")), "\n", 
#&gt;                   list(list(list("has(key, signature = NULL)")), 
#&gt;                     list("\n", "returns a list of true/false (logical) vectors indicating whether keys exist\n", 
#&gt;                       "in the container, if signature is used when caching the key-value pairs, then\n", 
#&gt;                       "it also checks whether signature matches. This is very important as even if\n", 
#&gt;                       "the keys match but signature is wrong, the results will be false.\n")), 
#&gt;                   "\n", list(list(list("remove(keys, all = TRUE)")), 
#&gt;                     list("\n", "Remove keys in the container. Default is to remove the keys in both levels.\n", 
#&gt;                       "If ", list("all=FALSE"), ", then only remove the key in current session\n")), 
#&gt;                   "\n", list(list(list("cache(key, value, signature = NULL, replace = FALSE, persist = FALSE)")), 
#&gt;                     list("\n", list("key"), " and ", list("signature"), 
#&gt;                       " together form the unique identifier for the\n", 
#&gt;                       "value. By default ", list("signature"), 
#&gt;                       " is none, but it's very useful when value\n", 
#&gt;                       "if large, or ", list("key"), " is not a string. ", 
#&gt;                       list("replace"), " indicates whether\n", 
#&gt;                       "to force replace the key-value pairs even if the entry exists. If\n", 
#&gt;                       list("persist"), " is true, then the value is stored in hard-disks, otherwise\n", 
#&gt;                       "the value will be deleted once the session is closed.\n")), 
#&gt;                   "\n"), "\n")), "\n", "\n", list("\n", "\n", 
#&gt;                 "container = PersistContainer$new(tempfile())\n", 
#&gt;                 "\n", "# Reset the container so that values are cleared\n", 
#&gt;                 "container$reset(all = TRUE)\n", "\n", "# Store `1` to 'a' with signature 111 to a non-persist map\n", 
#&gt;                 "# returns 1\n", "container$cache(key = 'a', value = 1, signature = 111, persist = FALSE)\n", 
#&gt;                 "\n", "# Replace 'a' with 3\n", "# returns 3\n", 
#&gt;                 "container$cache(key = 'a', value = 3, signature = 111,\n", 
#&gt;                 "                persist = TRUE, replace = TRUE)\n", 
#&gt;                 "\n", "# check if 'a' exists with signature 111\n", 
#&gt;                 "container$has('a', signature = 111)    # TRUE\n", 
#&gt;                 "# When you only have 'a' but no signature\n", 
#&gt;                 "container$has('a')                     # TRUE\n", 
#&gt;                 "# check if 'a' exists with wrong signature 222\n", 
#&gt;                 "container$has('a', signature = 222)    # FALSE\n", 
#&gt;                 "\n", "\n", "# Store 'a' with 2 with same signature\n", 
#&gt;                 "# will fail and ignore the value (value will not be evaluated if signatured)\n", 
#&gt;                 "# Return 2 (Important! use cached values)\n", 
#&gt;                 "container$cache(key = 'a', value = {\n", "  print(123)\n", 
#&gt;                 "  return(2)\n", "}, signature = 111, replace = FALSE)\n", 
#&gt;                 "\n", "# When no signature is present\n", "# If the key exists (no signature provided), return stored value\n", 
#&gt;                 "# returns 3\n", "container$cache(key = 'a', value = 4)\n", 
#&gt;                 "\n", "# replace is TRUE (no signature provided), signature will be some default value\n", 
#&gt;                 "container$cache(key = 'a', value = 2, replace = TRUE)\n", 
#&gt;                 "\n", "# destroy the container to free disk space\n", 
#&gt;                 "container$destroy()\n"), "\n", list("\n", list(
#&gt;                 list("map")), "\n"), "\n"), actionButtonStyled.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("actionButtonStyled"), "\n", list("actionButtonStyled"), 
#&gt;             "\n", list("Action Button but with customized styles"), 
#&gt;             "\n", list("\n", "actionButtonStyled(\n", "  inputId,\n", 
#&gt;                 "  label,\n", "  icon = NULL,\n", "  width = NULL,\n", 
#&gt;                 "  type = \"primary\",\n", "  btn_type = \"button\",\n", 
#&gt;                 "  class = \"\",\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("inputId, label, icon, width, ..."), 
#&gt;                 list("passed to ", list("shiny::actionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type, choices are `default`, `primary`, `info`, `success`,\n", 
#&gt;                   "`warning`, and `danger`")), "\n", "\n", list(
#&gt;                   list("btn_type"), list("HTML tag type, either ", 
#&gt;                     list("\"button\""), " or ", list("\"a\""))), 
#&gt;                 "\n", "\n", list(list("class"), list("additional classes to be added to the button")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Action Button but with customized styles\n"), 
#&gt;             "\n", list("\n", "\n", "# demo('example-actionButtonStyled', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButtonStyled('btn', label = 'Click me', type = 'default'),\n", 
#&gt;                 "  actionButtonStyled('btn2', label = 'Click me2', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  btn_types = c('default', 'primary', 'info', 'success', 'warning', 'danger')\n", 
#&gt;                 "  observeEvent(input$btn, {\n", "    btype = btn_types[((input$btn-1) %% (length(btn_types)-1)) + 1]\n", 
#&gt;                 "    updateActionButtonStyled(session, 'btn2', type = btype)\n", 
#&gt;                 "  })\n", "  observeEvent(input$btn2, {\n", "    updateActionButtonStyled(session, 'btn',\n", 
#&gt;                 "                             disabled = c(FALSE,TRUE)[(input$btn2 %% 2) + 1])\n", 
#&gt;                 "  })\n", "}\n", "\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser=TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateActionButtonStyled")), 
#&gt;                 " for how to update the button.\n"), "\n"), ask_or_default.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("ask_or_default"), "\n", list("ask_or_default"), 
#&gt;             "\n", list("Read a Line from the Terminal, but with Default Values"), 
#&gt;             "\n", list("\n", "ask_or_default(..., default = \"\", end = \"\", level = \"INFO\")\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("default"), list("default value to return in case of blank input")), 
#&gt;                 "\n"), "\n", list("\n", "A character from the user's input, or the default value. See details.\n"), 
#&gt;             "\n", list("\n", "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask a question, providing defaults. Users\n", 
#&gt;                 "need to enter the answer. If the answer is blank (no space), then returns the\n", 
#&gt;                 "default, otherwise returns the user input.\n", 
#&gt;                 "\n", "This can only be used in an ", list(list(
#&gt;                   "interactive")), " session.\n"), "\n", list(
#&gt;                 "\n", "if(interactive()){\n", "ask_or_default('What is the best programming language?',\n", 
#&gt;                 "               default = 'PHP')\n", "}\n"), 
#&gt;             "\n", list("\n", list(list("cat2")), ", ", list(list(
#&gt;                 "readline")), ",\n", list(list("ask_yesno")), 
#&gt;                 "\n"), "\n"), ask_yesno.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("ask_yesno"), "\n", list("ask_yesno"), 
#&gt;             "\n", list("Ask and Return True or False from the Terminal"), 
#&gt;             "\n", list("\n", "ask_yesno(..., end = \"\", level = \"INFO\", error_if_canceled = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("error_if_canceled"), list("raise error if canceled.")), 
#&gt;                 "\n"), "\n", list("\n", "logical or ", list("NULL"), 
#&gt;                 " or raise an error. If \"yes\" is entered,\n", 
#&gt;                 "returns ", list("TRUE"), "; if \"no\" is entered, returns ", 
#&gt;                 list("FALSE"), "; if \"c\" is\n", "entered, ", 
#&gt;                 list("error_if_canceled=TRUE"), " will result in an error, otherwise\n", 
#&gt;                 "return ", list("NULL"), "\n"), "\n", list("\n", 
#&gt;                 "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask for an yes or no question. Users need to\n", 
#&gt;                 "enter \"y\", \"yes\" for yes, \"n\", \"no\" or no, and \"c\" for cancel\n", 
#&gt;                 "(case-insensitive).\n", "\n", "This can only be used in an ", 
#&gt;                 list(list("interactive")), " session.\n"), "\n", 
#&gt;             list("\n", "if(interactive()){\n", "ask_yesno('Do you know how hard it is to submit an R package and ',\n", 
#&gt;                 "          'pass the CRAN checks?')\n", "ask_yesno('Can I pass the CRAN check this time?')\n", 
#&gt;                 "}\n"), "\n", list("\n", list(list("cat2")), 
#&gt;                 ", ", list(list("readline")), ",\n", list(list(
#&gt;                   "ask_or_default")), "\n"), "\n"), async.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async"), "\n", list("async"), "\n", list("Evaluate expression in ", 
#&gt;                 list("async_expr")), "\n", list("\n", "async(expr)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression")), 
#&gt;                 "\n"), "\n", list("\n", "Evaluate expression in ", 
#&gt;                 list("async_expr"), "\n"), "\n", list("\n", list(
#&gt;                 list("async_expr")), "\n"), "\n"), async_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_expr"), "\n", list("async_expr"), "\n", 
#&gt;             list("Apply R expressions in a parallel way"), "\n", 
#&gt;             list("\n", "async_expr(\n", "  .X,\n", "  .expr,\n", 
#&gt;                 "  .varname = \"x\",\n", "  envir = parent.frame(),\n", 
#&gt;                 "  .pre_run = NULL,\n", "  .ncore = future::availableCores(),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 ".X"), list("a vector or a list to apply evaluation on")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression, unquoted")), 
#&gt;                 "\n", "\n", list(list(".varname"), list("variable name representing element of each ", 
#&gt;                   list(".X"))), "\n", "\n", list(list("envir"), 
#&gt;                   list("environment to evaluate expressions")), 
#&gt;                 "\n", "\n", list(list(".pre_run"), list("expressions to be evaluated before looping.")), 
#&gt;                 "\n", "\n", list(list(".ncore"), list("number of CPU cores")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("future::future"))), "\n"), "\n", list(
#&gt;                 "\n", "a list whose length equals to ", list(
#&gt;                   ".X"), ". The value of each item\n", "returned depends on whether ", 
#&gt;                 list("async"), " is called. See details for workflow.\n"), 
#&gt;             "\n", list("\n", "Apply R expressions in a parallel way\n"), 
#&gt;             "\n", list("\n", list("async_expr"), " uses ", list(
#&gt;                 "lapply"), " and ", list("future::future"), " internally.\n", 
#&gt;                 "Within each loop, an item in ", list("\".X\""), 
#&gt;                 " will be assigned to variable ", list("\"x\""), 
#&gt;                 "\n", "(defined by ", list("\".varname\""), ") and enter the evaluation. During the evaluation,\n", 
#&gt;                 "function ", list("async"), " is provided. Expressions within ", 
#&gt;                 list("async"), " will be\n", "evaluated in another session, otherwise will be evaluated in current session.\n", 
#&gt;                 "Below is the workflow:\n", list("\n", "  ", 
#&gt;                   list(), " Run ", list(".pre_run"), "\n", "  ", 
#&gt;                   list(), " For ", list("i"), " in ", list("seq_along(.X)"), 
#&gt;                   ":\n", "  ", list("\n", "    ", list(), " 1. Assign ", 
#&gt;                     list("x"), " with ", list(".X[[i]]"), ", variable name ", 
#&gt;                     list("x"), " is\n", "    defined by ", list(
#&gt;                       ".varname"), "\n", "    ", list(), " 2. Evaluate ", 
#&gt;                     list("expr"), " in current session.\n", "    ", 
#&gt;                     list("\n", "      ", list(), " a. If ", list(
#&gt;                       "async"), " is not called, return evaluated ", 
#&gt;                       list("expr"), "\n", "      ", list(), " b. If ", 
#&gt;                       list("async(aync_expr)"), " is called, evaluate ", 
#&gt;                       list("aync_expr"), "\n", "      in another session, and return the evaluation results if ", 
#&gt;                       list("aync_expr"), "\n", "    "), "\n", 
#&gt;                     "  "), "\n"), "\n"), "\n"), async_flapply.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_flapply"), "\n", list("async_flapply"), 
#&gt;             "\n", list("Wrapper for ", list("future.apply::future_lapply")), 
#&gt;             "\n", list("\n", "async_flapply(X, FUN, ...)\n"), 
#&gt;             "\n", list("\n", list(list("X, FUN, ..."), list("passing to ", 
#&gt;                 list("future.apply::future_lapply"))), "\n"), 
#&gt;             "\n", list("\n", "Wrapper for ", list("future.apply::future_lapply"), 
#&gt;                 "\n"), "\n", list("\n", list(list("future_lapply")), 
#&gt;                 "\n"), "\n"), base64_to_image.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("base64_to_image"), "\n", list("base64_to_image"), 
#&gt;             "\n", list("Save \"Base64\" Data to Images"), "\n", 
#&gt;             list("\n", "base64_to_image(data, path)\n"), "\n", 
#&gt;             list("\n", list(list("data"), list("characters, encoded \"Base64\" data for images")), 
#&gt;                 "\n", "\n", list(list("path"), list("file path to save to")), 
#&gt;                 "\n"), "\n", list("\n", "Absolute path of the saved file\n"), 
#&gt;             "\n", list("\n", "Save \"Base64\" Data to Images\n"), 
#&gt;             "\n"), baseline_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-baseline_array.R", 
#&gt;             "\n", list("baseline_array"), "\n", list("baseline_array"), 
#&gt;             "\n", list("Calculate Contrasts of Arrays in Different Methods"), 
#&gt;             "\n", list("\n", "baseline_array(\n", "  x,\n", "  along_dim,\n", 
#&gt;                 "  baseline_indexpoints,\n", "  unit_dims = seq_along(dim(x))[-along_dim],\n", 
#&gt;                 "  method = c(\"percentage\", \"sqrt_percentage\", \"decibel\", \"zscore\", \"sqrt_zscore\")\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("x"), list(
#&gt;                 "array (tensor) to calculate contrast")), "\n", 
#&gt;                 "\n", list(list("along_dim"), list("integer range from 1 to the maximum dimension of ", 
#&gt;                   list("x"), ".\n", "baseline along this dimension, this is usually the time dimension.")), 
#&gt;                 "\n", "\n", list(list("baseline_indexpoints"), 
#&gt;                   list("integer vector, which index points are counted\n", 
#&gt;                     "into baseline window? Each index ranges from 1 to ", 
#&gt;                     list("dim(x)[[along_dim]]"), ".\n", "See Details.")), 
#&gt;                 "\n", "\n", list(list("unit_dims"), list("integer vector, baseline unit: see Details.")), 
#&gt;                 "\n", "\n", list(list("method"), list("character, baseline method options are:\n", 
#&gt;                   list("\"percentage\""), ", ", list("\"sqrt_percentage\""), 
#&gt;                   ", ", list("\"decibel\""), ",\n", list("\"zscore\""), 
#&gt;                   ", and ", list("\"sqrt_zscore\""))), "\n"), 
#&gt;             "\n", list("\n", "Contrast array with the same dimension as ", 
#&gt;                 list("x"), ".\n"), "\n", list("\n", "Provides five methods to baseline an array and calculate\n", 
#&gt;                 "contrast.\n"), "\n", list("\n", "Consider a scenario where we want to baseline a bunch of signals recorded\n", 
#&gt;                 "from different locations. For each location, we record ", 
#&gt;                 list("n"), " sessions.\n", "For each session, the signal is further decomposed into frequency-time\n", 
#&gt;                 "domain. In this case, we have the input ", list(
#&gt;                   "x"), " in the following form:\n", list(list(
#&gt;                   "session x frequency x time x location")), 
#&gt;                 "\n", "Now we want to calibrate signals for each session, frequency and location\n", 
#&gt;                 "using the first 100 time points as baseline points, then the code will be\n", 
#&gt;                 list(list("baseline_array(x, along_dim=3, 1:100, unit_dims=c(1,2,4))")), 
#&gt;                 "\n", list("along_dim=3"), " is dimension of time, in this case, it's the\n", 
#&gt;                 "third dimension of ", list("x"), ". ", list(
#&gt;                   "baseline_indexpoints=1:100"), ", meaning\n", 
#&gt;                 "the first 100 time points are used to calculate baseline.\n", 
#&gt;                 list("unit_dims"), " defines the unit signal. Its value ", 
#&gt;                 list("c(1,2,4)"), "\n", "means the unit signal is per session (first dimension), per frequency\n", 
#&gt;                 "(second) and per location (fourth).\n", "\n", 
#&gt;                 "In some other cases, we might want to calculate baseline across frequencies\n", 
#&gt;                 "then the unit signal is ", list(list("frequency x time")), 
#&gt;                 ", i.e. signals that share the\n", "same session and location also share the same baseline. In this case,\n", 
#&gt;                 "we assign ", list("unit_dims=c(1,4)"), ".\n", 
#&gt;                 "\n", "There are five baseline methods. They fit for different types of data.\n", 
#&gt;                 "Denote ", list(list("z")), " is an unit signal, ", 
#&gt;                 list(list("z_0")), " is its baseline slice. Then\n", 
#&gt;                 "these baseline methods are:\n", "\n", list("\n", 
#&gt;                   list(list(list("\"percentage\"")), list("\n", 
#&gt;                     list(list("\n", "  \\frac{z - \\bar{z_{0}}}{\\bar{z_{0}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (z / mean(z_0) - 1) x 100%\n")), 
#&gt;                     "\n")), "\n", list(list(list("\"sqrt_percentage\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z} - \\bar{\\sqrt{z_{0}}}}{\\bar{\\sqrt{z_{0}}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (sqrt(z) / mean(sqrt(z_0)) - 1) x 100%\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"decibel\"")), 
#&gt;                     list("\n", list(list("\n", "  10 \\times ( \\log_{10}(z) - \\bar{\\log_{10}(z_{0})} )\n"), 
#&gt;                       list("\n", "  10 * ( log10 (z) - mean( log10(z_0) ) )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{z-\\bar{z_{0}}}{sd(z_{0})}\n"), 
#&gt;                       list("\n", "  (z - mean( z_0 )) / sd( z_0 )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"sqrt_zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z}-\\bar{\\sqrt{z_{0}}}}{sd(\\sqrt{z_{0}})}\n"), 
#&gt;                       list("\n", "  (sqrt(z) - mean( sqrt(z_0) )) / sd( sqrt(z_0) )\n")), 
#&gt;                       "\n")), "\n", "\n", "\n"), "\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(dipsaus)\n", "set.seed(1)\n", 
#&gt;                 "\n", "# Generate sample data\n", "dims = c(10,20,30,2)\n", 
#&gt;                 "x = array(rnorm(prod(dims))^2, dims)\n", "\n", 
#&gt;                 "# Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "baseline_window = sample(30, 10)\n", "\n", "# ----- baseline percentage change ------\n", 
#&gt;                 "\n", "# Using base functions\n", "re1 &lt;- aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "  m &lt;- mean(y[baseline_window])\n", "  (y/m - 1) * 100\n", 
#&gt;                 "}), c(2,3,1,4))\n", "\n", "# Using dipsaus\n", 
#&gt;                 "re2 &lt;- baseline_array(x, 3, baseline_window, c(1,2,4),\n", 
#&gt;                 "                      method = 'percentage')\n", 
#&gt;                 "\n", "# Check different, should be very tiny (double precisions)\n", 
#&gt;                 "range(re2 - re1)\n", "\n", "# Check speed for large dataset\n", 
#&gt;                 "if(interactive()){\n", "  dims = c(200,20,300,2)\n", 
#&gt;                 "  x = array(rnorm(prod(dims))^2, dims)\n", "  # Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "  baseline_window = seq_len(100)\n", "  f1 &lt;- function(){\n", 
#&gt;                 "    aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "      m &lt;- mean(y[baseline_window])\n", "      (y/m - 1) * 100\n", 
#&gt;                 "    }), c(2,3,1,4))\n", "  }\n", "  f2 &lt;- function(){\n", 
#&gt;                 "    # equivalent as bl = x[,,baseline_window, ]\n", 
#&gt;                 "    #\n", "    baseline_array(x, along_dim = 3,\n", 
#&gt;                 "                   baseline_indexpoints = baseline_window,\n", 
#&gt;                 "                   unit_dims = c(1,2,4), method = 'sqrt_percentage')\n", 
#&gt;                 "  }\n", "  microbenchmark::microbenchmark(f1(), f2(), times = 3L)\n", 
#&gt;                 "}\n", "\n", "\n", "\n"), "\n"), cat2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("cat2"), "\n", list("cat2"), "\n", list("Color Output"), 
#&gt;             "\n", list("\n", "cat2(\n", "  ...,\n", "  level = \"DEBUG\",\n", 
#&gt;                 "  print_level = FALSE,\n", "  file = \"\",\n", 
#&gt;                 "  sep = \" \",\n", "  fill = FALSE,\n", "  labels = NULL,\n", 
#&gt;                 "  append = FALSE,\n", "  end = \"\\n\",\n", 
#&gt;                 "  pal = list(DEBUG = \"grey60\", INFO = \"#1d9f34\", WARNING = \"#ec942c\", ERROR =\n", 
#&gt;                 "    \"#f02c2c\", FATAL = \"#763053\", DEFAULT = \"grey60\"),\n", 
#&gt;                 "  use_cli = TRUE,\n", "  bullet = \"auto\"\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("..."), list(
#&gt;                 "to be printed")), "\n", "\n", list(list("level"), 
#&gt;                 list("'DEBUG', 'INFO', 'WARNING', 'ERROR', or 'FATAL' (total 5 levels)")), 
#&gt;                 "\n", "\n", list(list("print_level"), list("if true, prepend levels before messages")), 
#&gt;                 "\n", "\n", list(list("file, sep, fill, labels, append"), 
#&gt;                   list("pass to ", list("base::cat"))), "\n", 
#&gt;                 "\n", list(list("end"), list("character to append to the string")), 
#&gt;                 "\n", "\n", list(list("pal"), list("a named list defining colors see details")), 
#&gt;                 "\n", "\n", list(list("use_cli"), list("logical, whether to use package 'cli'")), 
#&gt;                 "\n", "\n", list(list("bullet"), list("character, if use 'cli', which symbol to show. see\n", 
#&gt;                   list(list("symbol")))), "\n"), "\n", list("\n", 
#&gt;                 "none.\n"), "\n", list("\n", "Color Output\n"), 
#&gt;             "\n", list("\n", "There are five levels of colors by default: 'DEBUG', 'INFO', 'WARNING', 'ERROR',\n", 
#&gt;                 "or FATAL. Default colors are: 'DEBUG' (", list(
#&gt;                   "grey60"), "), 'INFO' (", list("#1d9f34"), 
#&gt;                 "), 'WARNING'\n", "(", list("#ec942c"), "), 'ERROR' (", 
#&gt;                 list("#f02c2c"), "), 'FATAL' (", list("#763053"), 
#&gt;                 ") and\n", "'DEFAULT' (", list("#000000"), ", black). If level is not in preset five levels,\n", 
#&gt;                 "the color will be \"default\"-black color.\n"), 
#&gt;             "\n"), check_installed_packages.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("check_installed_packages"), "\n", list(
#&gt;                 "check_installed_packages"), "\n", list("Check If Packages Are Installed, Returns Missing Packages"), 
#&gt;             "\n", list("\n", "check_installed_packages(\n", "  pkgs,\n", 
#&gt;                 "  libs = base::.libPaths(),\n", "  auto_install = FALSE,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "pkgs"), list("vector of packages to install")), 
#&gt;                 "\n", "\n", list(list("libs"), list("paths of libraries")), 
#&gt;                 "\n", "\n", list(list("auto_install"), list("automatically install packages if missing")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters for ", 
#&gt;                   list("install.packages"))), "\n"), "\n", list(
#&gt;                 "\n", "package names that are not installed\n"), 
#&gt;             "\n", list("\n", "Check If Packages Are Installed, Returns Missing Packages\n"), 
#&gt;             "\n"), col2hexStr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("col2hexStr"), "\n", list("col2hexStr"), 
#&gt;             "\n", list("Convert color to Hex string"), "\n", 
#&gt;             list("\n", "col2hexStr(col, alpha = NULL, prefix = \"#\", ...)\n"), 
#&gt;             "\n", list("\n", list(list("col"), list("character or integer indicating color")), 
#&gt;                 "\n", "\n", list(list("alpha"), list(list("NULL"), 
#&gt;                   " or numeric, transparency. See ", list("grDevices::rgb"))), 
#&gt;                 "\n", "\n", list(list("prefix"), list("character, default is ", 
#&gt;                   list("\"#\""))), "\n", "\n", list(list("..."), 
#&gt;                   list("passing to  ", list(list("adjustcolor")))), 
#&gt;                 "\n"), "\n", list("\n", "characters containing the hex value of each color. See details\n"), 
#&gt;             "\n", list("\n", "Convert color to Hex string\n"), 
#&gt;             "\n", list("\n", list("col2hexStr"), " converts colors such as 1, 2, 3, \"red\", \"blue\", ... into\n", 
#&gt;                 "hex strings that can be easily recognized by `HTML`, `CSS` and `JavaScript`.\n", 
#&gt;                 "Internally this function uses ", list(list("adjustcolor")), 
#&gt;                 " with two differences:\n", list("\n", list(), 
#&gt;                   " the returned hex string does not contain alpha value if ", 
#&gt;                   list("alpha"), " is ", list("NULL"), ";\n", 
#&gt;                   list(), " the leading prefix \"#\" can be customized\n"), 
#&gt;                 "\n"), "\n", list("\n", "\n", "col2hexStr(1, prefix = '0x')      # \"0x000000\"\n", 
#&gt;                 "col2hexStr('blue')                # \"#0000FF\"\n", 
#&gt;                 "\n", "# Change default palette, see \"grDevices::colors()\"\n", 
#&gt;                 "grDevices::palette(c('orange3', 'skyblue1'))\n", 
#&gt;                 "col2hexStr(1)                     # Instead of #000000, #CD8500\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("adjustcolor")), 
#&gt;                 "\n"), "\n"), collapse.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("collapse"), "\n", list("collapse"), "\n", 
#&gt;             list("Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "collapse(x, keep, average = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A numeric multi-mode tensor (array), without ", 
#&gt;                 list("NA"))), "\n", "\n", list(list("keep"), 
#&gt;                 list("Which dimension to keep")), "\n", "\n", 
#&gt;                 list(list("average"), list("collapse to sum or mean")), 
#&gt;                 "\n"), "\n", list("\n", "a collapsed array with values to be mean or summation along\n", 
#&gt;                 "collapsing dimensions\n"), "\n", list("\n", 
#&gt;                 "Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "# Example 1\n", 
#&gt;                 "x = matrix(1:16, 4)\n", "\n", "# Keep the first dimension and calculate sums along the rest\n", 
#&gt;                 "collapse(x, keep = 1)\n", "rowSums(x)  # Should yield the same result\n", 
#&gt;                 "\n", "# Example 2\n", "x = array(1:120, dim = c(2,3,4,5))\n", 
#&gt;                 "result = collapse(x, keep = c(3,2))\n", "compare = apply(x, c(3,2), sum)\n", 
#&gt;                 "sum(abs(result - compare)) # The same, yield 0 or very small number (1e-10)\n", 
#&gt;                 "\n", "# Example 3 (performance)\n", "RcppParallel::setThreadOptions(numThreads = -1) # auto multicores\n", 
#&gt;                 "# Small data, no big difference, even slower\n", 
#&gt;                 "x = array(rnorm(240), dim = c(4,5,6,2))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L, check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  }\n", ")\n", "\n", "# large data big difference\n", 
#&gt;                 "x = array(rnorm(prod(300,200,105)), c(300,200,105,1))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L , check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  })\n", "\n"), "\n"), compoundInput2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("compoundInput2"), "\n", list("compoundInput2"), 
#&gt;             "\n", list("Compound input that combines and extends shiny inputs"), 
#&gt;             "\n", list("\n", "compoundInput2(\n", "  inputId,\n", 
#&gt;                 "  label = \"Group\",\n", "  components = shiny::tagList(),\n", 
#&gt;                 "  initial_ncomp = 1,\n", "  min_ncomp = 0,\n", 
#&gt;                 "  max_ncomp = 10,\n", "  value = NULL,\n", "  label_color = 1,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "inputId"), list("character, shiny input ID")), 
#&gt;                 "\n", "\n", list(list("label"), list("character, will show on each groups")), 
#&gt;                 "\n", "\n", list(list("components"), list("`HTML` tags that defines and combines HTML components within groups")), 
#&gt;                 "\n", "\n", list(list("initial_ncomp"), list(
#&gt;                   "numeric initial number of groups to show, non-negative")), 
#&gt;                 "\n", "\n", list(list("min_ncomp"), list("minimum number of groups, default is 0, non-negative")), 
#&gt;                 "\n", "\n", list(list("max_ncomp"), list("maximum number of groups, default is 10, greater or equal\n", 
#&gt;                   "than ", list("min_ncomp"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, initial values of each inputs, see examples.")), 
#&gt;                 "\n", "\n", list(list("label_color"), list("integer or characters, length of 1 or ", 
#&gt;                   list("max_ncomp"), ",\n", "assigning colors to each group labels,")), 
#&gt;                 "\n", "\n", list(list("..."), list("will be ignored")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Compound input that combines and extends shiny inputs\n"), 
#&gt;             "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    list(),                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "# Source - system.file('demo/example-compountInput2.R', package='dipsaus')\n", 
#&gt;                 "\n", "# demo('example-compountInput2', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  fluidRow(\n", "    column(\n", 
#&gt;                 "      width = 4,\n", "      compoundInput2(\n", 
#&gt;                 "        'compound', 'Group Label', label_color = 1:10,\n", 
#&gt;                 "        components = div(\n", "          textInput('txt', 'Text'),\n", 
#&gt;                 "          selectInput('sel', 'Select', choices = 1:10, multiple = TRUE),\n", 
#&gt;                 "          sliderInput('sli', 'Slider', max=1, min=0, val=0.5)\n", 
#&gt;                 "        ),\n", "        value = list(\n", "          list(txt = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "          '',                # no settings for second group\n", 
#&gt;                 "          list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "        )\n", "      ),\n", "      hr(),\n", 
#&gt;                 "      actionButton('action', 'Update compound input')\n", 
#&gt;                 "    )\n", "  )\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observe({\n", "    print(input$compound)\n", 
#&gt;                 "  })\n", "  observe({\n", "    # Getting specific input at group 1\n", 
#&gt;                 "    print(input$compound_txt_1)\n", "  })\n", 
#&gt;                 "  observeEvent(input$action, {\n", "    updateCompoundInput2(\n", 
#&gt;                 "      session, 'compound',\n", "      # Update values for each components\n", 
#&gt;                 "      value = lapply(1:5, function(ii){\n", 
#&gt;                 "        list(\n", "          txt = sample(LETTERS, 1),\n", 
#&gt;                 "          sel = sample(1:10, 3),\n", "          sli = runif(1)\n", 
#&gt;                 "        )\n", "      }), ncomp = NULL, txt = list(label = as.character(Sys.time())))\n", 
#&gt;                 "  })\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser = TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateCompoundInput2")), 
#&gt;                 " for how to update inputs\n"), "\n"), decorate_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("decorate_function"), "\n", list("decorate_function"), 
#&gt;             "\n", list("%D%"), "\n", list("Python-style decorator"), 
#&gt;             "\n", list("\n", "decorate_function(orig, decor, ...)\n", 
#&gt;                 "\n", "lhs %D% rhs\n"), "\n", list("\n", list(
#&gt;                 list("orig, lhs"), list("any function")), "\n", 
#&gt;                 "\n", list(list("decor, rhs"), list("decorator function that takes ", 
#&gt;                   list("orig"), " as its first\n", "argument")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("decor"))), "\n"), "\n", list("\n", "Python-style decorator\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# Example 1: basic usage\n", 
#&gt;                 "# Decorator that prints summary of results and return results itself\n", 
#&gt;                 "verbose_summary &lt;- function(...){\n", "  summary_args &lt;- list(...)\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      results &lt;- f(...)\n", 
#&gt;                 "\n", "\n", "      print(do.call(\n", "        summary,\n", 
#&gt;                 "        c(list(results), summary_args)\n", "      ))\n", 
#&gt;                 "      results\n", "\n", "    }\n", "  }\n", 
#&gt;                 "\n", "}\n", "\n", "# runs as.list, but through verbose_summary\n", 
#&gt;                 "as_list2 &lt;- decorate_function(as.list, verbose_summary)\n", 
#&gt;                 "\n", "# run test\n", "res &lt;- as_list2(1:3)  # will verbose summary\n", 
#&gt;                 "identical(res, as.list(1:3))\n", "\n", "# Example 2\n", 
#&gt;                 "x &lt;- 1:20\n", "y &lt;- x + rnorm(20)\n", "\n", 
#&gt;                 "# decorator, add a line with slope 1 with given intercept\n", 
#&gt;                 "abline_xy &lt;- function(b){\n", "  function(f){\n", 
#&gt;                 "    function(...){\n", "      f(...)\n", "      intercept &lt;- get_dots('intercept', 0, ...)\n", 
#&gt;                 "      abline(a = intercept, b = b)\n", "    }\n", 
#&gt;                 "  }\n", "}\n", "\n", "# orig, plot whatever x vs jittered+intercept\n", 
#&gt;                 "plot_xy &lt;- function(x, intercept = rnorm(1)){\n", 
#&gt;                 "  plot(x, jitter(x, amount = 3) + intercept)\n", 
#&gt;                 "}\n", "\n", "# new function that decorate plot_xy with abline_xy, and\n", 
#&gt;                 "# returns the intercept\n", "plot_xy2 &lt;- decorate_function(plot_xy, abline_xy, b = 1)\n", 
#&gt;                 "\n", "# alternatively, you might also want to try\n", 
#&gt;                 "plot_xy2 &lt;- plot_xy %D% abline_xy(b = 1)\n", 
#&gt;                 "\n", "plot_xy2(x = 1:20)\n", "\n"), "\n"), deparse_svec.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("deparse_svec"), "\n", list("deparse_svec"), 
#&gt;             "\n", list("Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "deparse_svec(\n", 
#&gt;                 "  nums,\n", "  connect = \"-\",\n", "  concatenate = TRUE,\n", 
#&gt;                 "  collapse = \",\",\n", "  max_lag = 1\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("nums"), list("integer vector")), 
#&gt;                 "\n", "\n", list(list("connect"), list("character used to connect consecutive numbers")), 
#&gt;                 "\n", "\n", list(list("concatenate"), list("connect strings if there are multiples")), 
#&gt;                 "\n", "\n", list(list("collapse"), list("if concatenate, character used to connect strings")), 
#&gt;                 "\n", "\n", list(list("max_lag"), list("defines \"consecutive\", min = 1")), 
#&gt;                 "\n"), "\n", list("\n", "strings representing the input vector. For example, ", 
#&gt;                 list("c(1, 2, 3)"), " returns \"1-3\".\n"), "\n", 
#&gt;             list("\n", "Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "deparse_svec(c(1:10, 15:18))\n"), 
#&gt;             "\n", list("\n", list(list("parse_svec")), "\n"), 
#&gt;             "\n"), dev_create.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/graphics.R", 
#&gt;             "\n", list("dev_create"), "\n", list("dev_create"), 
#&gt;             "\n", list("Create a group of named graphic devices"), 
#&gt;             "\n", list("\n", "dev_create(..., env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("named expressions to launch devices")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate expressions")), 
#&gt;                 "\n"), "\n", list("\n", "A list of functions to query, control, and switch between devices\n"), 
#&gt;             "\n", list("\n", "Create a group of named graphic devices\n"), 
#&gt;             "\n", list("\n", list(" ## Unix-specific example\n", 
#&gt;                 "\n", "# Create multiple named devices\n", "devs &lt;- dev_create(line = X11(), points = x11())\n", 
#&gt;                 "\n", "# switch to device named \"points\"\n", 
#&gt;                 "\n", "devs$dev_which('points')\n", "plot(1:10)\n", 
#&gt;                 "\n", "# switch to \"line\" device\n", "devs$dev_switch('line')\n", 
#&gt;                 "plot(1:100, type='l')\n", "\n", "# Create another group with conflict name\n", 
#&gt;                 "dev_another &lt;- dev_create(line = X11())\n", 
#&gt;                 "\n", "# Query device name with 'line'\n", "dev_another$dev_which('line')  # 4\n", 
#&gt;                 "devs$dev_which('line')  # 2, doesn't conflict with the new groups\n", 
#&gt;                 "\n", "dev.list()\n", "# close one or more device\n", 
#&gt;                 "dev_another$dev_off('line')\n", "dev.list()\n", 
#&gt;                 "\n", "# close all devices\n", "devs$dev_off()\n", 
#&gt;                 "dev.list()\n", "\n"), "\n"), "\n"), do_aggregate.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("do_aggregate"), "\n", list("do_aggregate"), 
#&gt;             "\n", list("Make aggregate pipe-friendly"), "\n", 
#&gt;             list("\n", "do_aggregate(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("an R object")), "\n", 
#&gt;                 "\n", list(list("..."), list("other parameters passed to ", 
#&gt;                   list(list("aggregate")))), "\n"), "\n", list(
#&gt;                 "\n", "Results from ", list(list("aggregate")), 
#&gt;                 "\n"), "\n", list("\n", "A pipe-friendly wrapper of ", 
#&gt;                 list(list("aggregate")), "\n", "when using formula as input.\n"), 
#&gt;             "\n", list("\n", "\n", "library(magrittr)\n", "data(ToothGrowth)\n", 
#&gt;                 "\n", "ToothGrowth %&gt;%\n", "  do_aggregate(len ~ ., mean)\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("aggregate")), 
#&gt;                 "\n"), "\n"), drop_nulls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("drop_nulls"), "\n", list("drop_nulls"), 
#&gt;             "\n", list("Drop ", list("NULL"), " values from list or vectors"), 
#&gt;             "\n", list("\n", "drop_nulls(x, .invalids = list(\"is.null\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("list to check")), 
#&gt;                 "\n", "\n", list(list(".invalids"), list("a list of functions, or function name. Default is 'is.null'.")), 
#&gt;                 "\n"), "\n", list("\n", "list or vector containing no invalid values\n"), 
#&gt;             "\n", list("\n", "Drop ", list("NULL"), " values from list or vectors\n"), 
#&gt;             "\n", list("\n", "\n", "x &lt;- list(NULL,NULL,1,2)\n", 
#&gt;                 "drop_nulls(x)  # length of 2\n", "\n"), "\n"), 
#&gt;         eval_dirty.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("eval_dirty"), "\n", list("eval_dirty"), 
#&gt;             "\n", list("Evaluate expressions"), "\n", list("\n", 
#&gt;                 "eval_dirty(expr, env = parent.frame(), data = NULL, quoted = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression or 'rlang' quo")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate")), 
#&gt;                 "\n", "\n", list(list("data"), list("dataframe or list")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("Is the expression quoted? By default, this is ", 
#&gt;                   list("TRUE"), ".\n", "This is useful when you don't want to use an expression that is stored in a\n", 
#&gt;                   "variable; see examples")), "\n"), "\n", list(
#&gt;                 "\n", "the executed results of ", list("expr"), 
#&gt;                 " evaluated with side effects.\n"), "\n", list(
#&gt;                 "\n", "Evaluate expressions\n"), "\n", list("\n", 
#&gt;                 list("eval_dirty"), " uses ", list("base::eval()"), 
#&gt;                 " function to evaluate\n", "expressions. Compare to ", 
#&gt;                 list("rlang::eval_tidy"), ", which won't affect original\n", 
#&gt;                 "environment, ", list("eval_dirty"), " causes changes to the environment. Therefore\n", 
#&gt;                 "if ", list("expr"), " contains assignment, environment will be changed in this case.\n"), 
#&gt;             "\n", list("\n", "\n", "env = new.env(); env$a = 1\n", 
#&gt;                 "rlang::eval_tidy(quote({a &lt;- 111}), env = env)\n", 
#&gt;                 "print(env$a)  # Will be 1. This is because eval_tidy has no side effect\n", 
#&gt;                 "\n", "eval_dirty(quote({a &lt;- 111}), env)\n", 
#&gt;                 "print(env$a)  # 111, a is changed\n", "\n", 
#&gt;                 "# Unquoted case\n", "eval_dirty({a &lt;- 222}, env, quoted = FALSE)\n", 
#&gt;                 "print(env$a)\n", "\n"), "\n"), fastmap2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fastmap2.R", "\n", 
#&gt;             list("fastmap2"), "\n", list("fastmap2"), "\n", list(
#&gt;                 "[[.fastmap2"), "\n", list("$.fastmap2"), "\n", 
#&gt;             list("[[&lt;-.fastmap2"), "\n", list("$&lt;-.fastmap2"), 
#&gt;             "\n", list("[.fastmap2"), "\n", list("[&lt;-.fastmap2"), 
#&gt;             "\n", list("names.fastmap2"), "\n", list("print.fastmap2"), 
#&gt;             "\n", list("length.fastmap2"), "\n", list("as.list.fastmap2"), 
#&gt;             "\n", list("A Wrapper for ", list("fastmap::fastmap")), 
#&gt;             "\n", list("\n", "fastmap2(missing_default = NULL)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...)\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...) &lt;- value\n", 
#&gt;                 "\n", list(list("names"), list("fastmap2")), 
#&gt;                 "(x)\n", "\n", list(list("print"), list("fastmap2")), 
#&gt;                 "(x, ...)\n", "\n", list(list("length"), list(
#&gt;                   "fastmap2")), "(x)\n", "\n", list(list("as.list"), 
#&gt;                   list("fastmap2")), "(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("missing_default"), list("passed to ", 
#&gt;                   list("fastmap::fastmap"))), "\n", "\n", list(
#&gt;                   list("x"), list("a ", list("'fastmap2'"), " object")), 
#&gt;                 "\n", "\n", list(list("name"), list("name, or key of the value")), 
#&gt;                 "\n", "\n", list(list("value"), list("any R object")), 
#&gt;                 "\n", "\n", list(list("i, j"), list("vector of names")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to other methods")), 
#&gt;                 "\n"), "\n", list("\n", "A list of ", list("'fastmap2'"), 
#&gt;                 " instance\n"), "\n", list("\n", list(list("fastmap")), 
#&gt;                 "\n", "provides a key-value store where the keys are strings and the\n", 
#&gt;                 "values are any R objects. It differs from normal environment that\n", 
#&gt;                 list(list("fastmap")), " avoids memory leak. ", 
#&gt;                 list("fastmap2"), "\n", "is a wrapper for ", 
#&gt;                 list("fastmap"), ", which provides several generic\n", 
#&gt;                 "functions such that it has similar behaviors to lists or\n", 
#&gt;                 "environments\n"), "\n", list("\n", "\n", "## --------------------------- Basic Usage --------------------------\n", 
#&gt;                 "map &lt;- fastmap2()\n", "map$a = 1\n", "map$b = 2\n", 
#&gt;                 "print(map)\n", "\n", "map[c('a', 'b')]\n", "# Alternative way\n", 
#&gt;                 "map['a', 'b']\n", "\n", "map[c('c', 'd')] &lt;- 3:4\n", 
#&gt;                 "# or\n", "map['e', 'f'] &lt;- 5:6\n", "\n", "# The order is not guaranteed, unless sort=TRUE\n", 
#&gt;                 "as.list(map)\n", "as.list(map, sort=TRUE)\n", 
#&gt;                 "\n", "names(map)\n", "length(map)\n", "\n", 
#&gt;                 "## ----------------------- NULL value handles -----------------------\n", 
#&gt;                 "map$b &lt;- NULL\n", "names(map)   # 'b' still exists!\n", 
#&gt;                 "as.list(map) # 'b' is NULL, but still there\n", 
#&gt;                 "\n", "# to remove 'b', you have to use `@remove` method\n", 
#&gt;                 "map$`@remove`('b')\n", "\n", "## ---------------- Native fastmap::fastmap methods -----------------\n", 
#&gt;                 "\n", "# whether map has 'a'\n", "map$`@has`('a')\n", 
#&gt;                 "\n", "# Remove a name from list\n", "map$`@remove`('a')\n", 
#&gt;                 "\n", "# remove all from list\n", "map$`@reset`()\n", 
#&gt;                 "print(map)\n", "\n"), "\n"), forelse.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("forelse"), "\n", list("forelse"), "\n", list(
#&gt;                 "Python-style ", list("\"for-else\""), " function"), 
#&gt;             "\n", list("\n", "forelse(x, FUN, ALT_FUN = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("iterative R objects such as list, vector, etc.")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("function that applies to each ", 
#&gt;                   list("x"))), "\n", "\n", list(list("ALT_FUN"), 
#&gt;                   list("function that takes no argument or other types of R\n", 
#&gt;                     "object")), "\n"), "\n", list("\n", "If any ", 
#&gt;                 list("FUN"), " returns anything other than ", 
#&gt;                 list("NULL"), ",\n", "then the function returns the first none ", 
#&gt;                 list("NULL"), " object. If\n", "all ", list("x"), 
#&gt;                 " fed to ", list("FUN"), " return ", list("NULL"), 
#&gt;                 ", then this\n", "function returns ", list("ALT_FUN"), 
#&gt;                 " (if ", list("ALT_FUN"), " is not a function)\n", 
#&gt;                 "or the result of ", list("ALT_FUN()"), ".\n"), 
#&gt;             "\n", list("\n", "Provide Python-style ", list("\"for-else\""), 
#&gt;                 " that works as\n", "follows: for each element, execute \"for\" block, if there is break\n", 
#&gt;                 "while executing \"for\" block, then just stop and ignore the \"else\"\n", 
#&gt;                 "statement, otherwise run \"else\" block.\n"), 
#&gt;             "\n", list("\n", "\n", "# --------------------------- Basic Usage ------------------------------\n", 
#&gt;                 "\n", "# 1. ALT_FUN get executed because FUN returns NULL for all items in x\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x &gt; 10) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  function(){\n", "    cat('ALT_FUN is executed!\\n')\n", 
#&gt;                 "    'wow'\n", "  }\n", ")\n", "\n", "# 2. FUN returns non-NULL object\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  'wow'\n", ")\n", "\n", "# --------------------------- Performance ------------------------------\n", 
#&gt;                 "FUN &lt;- function(x){\n", "  Sys.sleep(0.01)\n", 
#&gt;                 "  if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "}\n", "\n", "microbenchmark::microbenchmark({\n", 
#&gt;                 "  forelse(1:10, FUN, 'wow')\n", "}, {\n", "  y &lt;- unlist(lapply(1:10, FUN))\n", 
#&gt;                 "  if(length(y)){\n", "    y &lt;- y[[1]]\n", "  }else{\n", 
#&gt;                 "    y &lt;- 'wow'\n", "  }\n", "}, {\n", "  y &lt;- NULL\n", 
#&gt;                 "  for(x in 1:10){ y &lt;- FUN(x) }\n", "  if(is.null(y)){ y &lt;- 'wow' }\n", 
#&gt;                 "}, times = 3)\n", "\n", "\n"), "\n"), getInputBinding.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("getInputBinding"), "\n", list("getInputBinding"), 
#&gt;             "\n", list("Obtain registered input bindings"), "\n", 
#&gt;             list("\n", "getInputBinding(fname, pkg = NULL, envir = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("input function name, character or quoted expression\n", 
#&gt;                 "such as ", list("'shiny::textInput'"), " or ", 
#&gt;                 list("numericInput"), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("(optional), name of package")), 
#&gt;                 "\n", "\n", list(list("envir"), list("environment to evaluate ", 
#&gt;                   list("fname"), " if ", list("pkg"), " is not provided")), 
#&gt;                 "\n"), "\n", list("\n", "a list containing: 1. `JavaScript` input binding name; 2. `R` updating function name\n"), 
#&gt;             "\n", list("\n", "Obtain registered input bindings\n"), 
#&gt;             "\n", list("\n", "\n", "library(dipsaus)\n", "\n", 
#&gt;                 "# Most recommended usage\n", "getInputBinding('compoundInput2', pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Other usages\n", "getInputBinding('shiny::textInput')\n", 
#&gt;                 "\n", "\n", "getInputBinding(shiny::textInput)\n", 
#&gt;                 "\n", "getInputBinding(compoundInput2, pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Bad usage, raise errors in some cases\n", 
#&gt;                 list("\n", "## You need to library(shiny), or set envir=asNamespace('shiny'), or pkg='shiny'\n", 
#&gt;                   "getInputBinding('textInput')\n", "getInputBinding(textInput) # also fails\n", 
#&gt;                   "\n", "## Always fails\n", "getInputBinding('dipsaus::compoundInput2', pkg = 'dipsaus')\n"), 
#&gt;                 "\n", "\n"), "\n"), get_cpu.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_cpu"), "\n", list("get_cpu"), "\n", 
#&gt;             list("Get CPU Chip-set Information"), "\n", list(
#&gt;                 "\n", "get_cpu()\n"), "\n", list("\n", "a list of vendor ID and CPU model name\n"), 
#&gt;             "\n", list("\n", "Get CPU Chip-set Information\n"), 
#&gt;             "\n"), get_dots.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("get_dots"), "\n", list("get_dots"), "\n", 
#&gt;             list("Get element from dots ", list("'...'")), "\n", 
#&gt;             list("\n", "get_dots(..name, ..default = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("..name"), list("character name of the argument")), 
#&gt;                 "\n", "\n", list(list("..default"), list("R object to return if argument not found")), 
#&gt;                 "\n", "\n", list(list("..."), list("dots that contains argument")), 
#&gt;                 "\n"), "\n", list("\n", "Get specific key values from ", 
#&gt;                 list("'...'"), " without\n", "evaluating the rest of arguments.\n"), 
#&gt;             "\n", list("\n", "One could use ", list("list(...)[[name]]"), 
#&gt;                 " to extract any keys\n", "from the dots. However, such way reduces code readability. If\n", 
#&gt;                 "some arguments have not evaluated, ", list("list(...)"), 
#&gt;                 " will\n", list(list("force")), " evaluating them. Normally it's fine if\n", 
#&gt;                 "these expressions take little time to run, but if the\n", 
#&gt;                 "expression require time to run, ", list(list(
#&gt;                   "get_dots")), " avoids\n", "unnecessary evaluations.\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# ------------------------ Basic Usage ---------------------------\n", 
#&gt;                 "plot2 &lt;- function(...){\n", "  title = get_dots('main', 'There is no title', ...)\n", 
#&gt;                 "  plot(...)\n", "  title\n", "}\n", "\n", "plot2(1:10)\n", 
#&gt;                 "plot2(1:10, main = 'Scatter Plot of 1:10')\n", 
#&gt;                 "\n", "# ------------------------ Comparisons ----------------------------\n", 
#&gt;                 "f1 &lt;- function(...){ get_dots('x', ...) }\n", 
#&gt;                 "f2 &lt;- function(...){ list(...)[['x']] }\n", 
#&gt;                 "delayedAssign('y', { cat('y is evaluated!') })\n", 
#&gt;                 "\n", "# y will not evaluate\n", "f1(x = 1, y = y)\n", 
#&gt;                 "\n", "# y gets evaluated\n", "f2(x = 1, y = y)\n", 
#&gt;                 "\n", "# -------------------- Decorator example --------------------------\n", 
#&gt;                 "ret_range &lt;- function(which_range = 'y'){\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      f(...)\n", 
#&gt;                 "      y_range &lt;- range(get_dots(which_range, 0, ...))\n", 
#&gt;                 "      y_range\n", "    }\n", "  }\n", "}\n", 
#&gt;                 "plot_ret_yrange &lt;- plot %D% ret_range('y')\n", 
#&gt;                 "plot_ret_yrange(x = 1:10, y = rnorm(10))\n", 
#&gt;                 "\n", "\n"), "\n"), get_ram.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_ram"), "\n", list("get_ram"), "\n", 
#&gt;             list("Get Memory Size"), "\n", list("\n", "get_ram()\n"), 
#&gt;             "\n", list("\n", "numeric in Bytes how big your system RAM is\n"), 
#&gt;             "\n", list("\n", "Get Memory Size\n"), "\n"), `grapes-equals-greater-than-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%=&gt;%"), "\n", list("%=&gt;%"), "\n", list("A JavaScript style of creating functions"), 
#&gt;             "\n", list("\n", "args %=&gt;% expr\n"), "\n", list(
#&gt;                 "\n", list(list("args"), list("function arguments: see ", 
#&gt;                   list(list("formals")))), "\n", "\n", list(list(
#&gt;                   "expr"), list("R expression that forms the body of functions: see ", 
#&gt;                   list(list("body")))), "\n"), "\n", list("\n", 
#&gt;                 "A function that takes ", list("args"), " as parameters and ", 
#&gt;                 list("expr"), " as\n", "the function body\n"), 
#&gt;             "\n", list("\n", "A JavaScript style of creating functions\n"), 
#&gt;             "\n", list("\n", "# Formal arguments\n", "c(a) %=&gt;% {\n", 
#&gt;                 "  print(a)\n", "}\n", "\n", "# Informal arguments\n", 
#&gt;                 "list(a=) %=&gt;% {\n", "  print(a)\n", "}\n", "\n", 
#&gt;                 "# Multiple inputs\n", "c(a, b = 2, ...) %=&gt;% {\n", 
#&gt;                 "  print(c(a, b, ...))\n", "}\n", "\n", "# ----- JavaScript style of forEach -----\n", 
#&gt;                 "# ### Equivalent JavaScript Code:\n", "# LETTERS.forEach((el, ii) =&gt; {\n", 
#&gt;                 "#   console.log('The index of letter ' + el + ' in \"x\" is: ' + ii);\n", 
#&gt;                 "# });\n", "\n", "iapply(LETTERS, c(el, ii) %=&gt;% {\n", 
#&gt;                 "  cat2('The index of letter ', el, ' in ', sQuote('x'), ' is: ', ii)\n", 
#&gt;                 "}) -&gt; results\n"), "\n"), `grapes-help-set-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%?&lt;-%"), "\n", list("%?&lt;-%"), "\n", list("Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens."), 
#&gt;             "\n", list("\n", "lhs %?&lt;-% value\n"), "\n", list(
#&gt;                 "\n", list(list("lhs"), list("an object to check or assign")), 
#&gt;                 "\n", "\n", list(list("value"), list("value to be assigned if lhs is NULL")), 
#&gt;                 "\n"), "\n", list("\n", "Assign value on the right-hand side to the left-hand side if\n", 
#&gt;                 list("lhs"), " does not exist or is ", list("NULL"), 
#&gt;                 "\n"), "\n", list("\n", "Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens.\n"), 
#&gt;             "\n", list("\n", "# Prepare, remove aaa if exists\n", 
#&gt;                 "if(exists('aaa', envir = globalenv(), inherits = FALSE)){\n", 
#&gt;                 "  rm(aaa, envir = globalenv())\n", "}\n", "\n", 
#&gt;                 "# Assign\n", "aaa %?&lt;-% 1; print(aaa)\n", "\n", 
#&gt;                 "# However, if assigned, nothing happens\n", 
#&gt;                 "aaa = 1;\n", "aaa %?&lt;-% 2;\n", "print(aaa)\n", 
#&gt;                 "\n", "# in a list\n", "a = list()\n", "a$e %?&lt;-% 1; print(a$e)\n", 
#&gt;                 "a$e %?&lt;-% 2; print(a$e)\n", "\n"), "\n"), `grapes-plus-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%+-%"), "\n", list("%+-%"), "\n", list("Plus-minus operator"), 
#&gt;             "\n", list("\n", "a %+-% b\n"), "\n", list("\n", 
#&gt;                 list(list("a, b"), list("numeric vectors, matrices or arrays")), 
#&gt;                 "\n"), "\n", list("\n", list("a +/- b"), ", the dimension depends on ", 
#&gt;                 list("a+b"), ". If ", list("a+b"), " is\n", "a scalar, returns a vector of two; in the case of vector, returns a matrix;\n", 
#&gt;                 "all other cases will return an array with the last dimension equal to 2.\n"), 
#&gt;             "\n", list("\n", "Plus-minus operator\n"), "\n", 
#&gt;             list("\n", "\n", "# scalar\n", "1 %+-% 2   # -1, 3\n", 
#&gt;                 "\n", "# vector input\n", "c(1,2,3) %+-% 2   # matrix\n", 
#&gt;                 "\n", "# matrix input\n", "matrix(1:9, 3) %+-% 2   # 3x3x2 array\n", 
#&gt;                 "\n"), "\n"), handler_dipsaus_progress.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("handler_dipsaus_progress"), "\n", list(
#&gt;                 "handler_dipsaus_progress"), "\n", list("Progress-bar Handler"), 
#&gt;             "\n", list("\n", "handler_dipsaus_progress(\n", "  title = getOption(\"dipsaus.progressr.title\", \"Progress\"),\n", 
#&gt;                 "  intrusiveness = getOption(\"progressr.intrusiveness.gui\", 1),\n", 
#&gt;                 "  target = if (is.null(shiny::getDefaultReactiveDomain())) \"terminal\" else \"gui\",\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "title"), list("default title of ", list(list(
#&gt;                 "progress2")))), "\n", "\n", list(list("intrusiveness"), 
#&gt;                 list("A non-negative scalar on how intrusive\n", 
#&gt;                   "(disruptive) the reporter to the user")), 
#&gt;                 "\n", "\n", list(list("target"), list("where progression updates are rendered")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("make_progression_handler")))), "\n"), 
#&gt;             "\n", list("\n", "Handler for ", list(list("progress2")), 
#&gt;                 " to support\n", list("progressr::handlers"), 
#&gt;                 ". See examples for detailed use case\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(progressr)\n", "library(shiny)\n", 
#&gt;                 "library(future)\n", "\n", "## ------------------------------ Setup! -------------------------------\n", 
#&gt;                 "handlers(handler_dipsaus_progress())\n", "\n", 
#&gt;                 "# ------------------------------ A simple usage ------------------------\n", 
#&gt;                 "xs &lt;- 1:5\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- lapply(xs, function(x) {\n", "    p(sprintf(\"x=%g\", x))\n", 
#&gt;                 "    Sys.sleep(0.1)\n", "    sqrt(x)\n", "  })\n", 
#&gt;                 "})\n", "\n", "# ------------------------ A future.apply case -------------------------\n", 
#&gt;                 "plan(sequential)\n", "# test it yourself with plan(multisession)\n", 
#&gt;                 "\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- future.apply::future_lapply(xs, function(x) {\n", 
#&gt;                 "    p(sprintf(\"x=%g\", x))\n", "    Sys.sleep(0.1)\n", 
#&gt;                 "    sqrt(x)\n", "  })\n", "})\n", "\n", "# ------------------------ A shiny case --------------------------------\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButton('ok', 'Run Demo')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  handlers(handler_dipsaus_progress())\n", "  make_forked_clusters()\n", 
#&gt;                 "\n", "  observeEvent(input$ok, {\n", "    with_progress({\n", 
#&gt;                 "      p &lt;- progressor(along = 1:100)\n", "      y &lt;- future.apply::future_lapply(1:100, function(x) {\n", 
#&gt;                 "        p(sprintf(\"Input %d|Result %d\", x, x+1))\n", 
#&gt;                 "        Sys.sleep(1)\n", "        x+1\n", "      })\n", 
#&gt;                 "    })\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n", 
#&gt;                 "\n"), "\n"), iapply.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/apply.R", 
#&gt;             "\n", list("iapply"), "\n", list("iapply"), "\n", 
#&gt;             list("Apply each elements with index as second input"), 
#&gt;             "\n", list("\n", "iapply(X, FUN, ..., .method = c(\"sapply\", \"lapply\", \"vapply\"))\n"), 
#&gt;             "\n", list("\n", list(list("X"), list("a vector (atomic or list)")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("the function to be applied to each element of ", 
#&gt;                   list("X"), ": see `Details`.")), "\n", "\n", 
#&gt;                 list(list("..."), list("passed to apply methods")), 
#&gt;                 "\n", "\n", list(list(".method"), list("method to use, default is ", 
#&gt;                   list(list("sapply")))), "\n"), "\n", list("\n", 
#&gt;                 "a list or matrix depends on ", list(".method"), 
#&gt;                 ". See ", list(list("lapply")), "\n"), "\n", 
#&gt;             list("\n", "Apply function with an index variable as the second input.\n"), 
#&gt;             "\n", list("\n", list("FUN"), " will be further passed to the apply methods. Unlike\n", 
#&gt;                 list(list("lapply")), ", ", list("FUN"), " is expected to have at least two arguments.\n", 
#&gt;                 "The first argument is each element of ", list(
#&gt;                   "X"), ", the second argument is the\n", "index number of the element.\n"), 
#&gt;             "\n"), lapply_async2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels-future.R", 
#&gt;             "\n", list("lapply_async2"), "\n", list("lapply_async2"), 
#&gt;             "\n", list("Apply, but in parallel"), "\n", list(
#&gt;                 "\n", "lapply_async2(\n", "  x,\n", "  FUN,\n", 
#&gt;                 "  FUN.args = list(),\n", "  callback = NULL,\n", 
#&gt;                 "  plan = TRUE,\n", "  future.chunk.size = NULL,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("vector, list")), "\n", "\n", list(
#&gt;                 list("FUN"), list("function to apply on each element of ", 
#&gt;                   list("x"))), "\n", "\n", list(list("FUN.args"), 
#&gt;                 list("more arguments to feed into ", list("FUN"))), 
#&gt;                 "\n", "\n", list(list("callback"), list("function to run after each iteration")), 
#&gt;                 "\n", "\n", list(list("plan"), list("logical, or character or ", 
#&gt;                   list("future"), " plan; see Details.")), "\n", 
#&gt;                 "\n", list(list("future.chunk.size"), list("see also\n", 
#&gt;                   list(list("future_eapply")), ". If you want the callbacks\n", 
#&gt;                   "to be called immediately after each loop, then set it to ", 
#&gt;                   list("1"), ",\n", "which is not optimal but the only way right now.")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("plan")))), "\n"), "\n", list("\n", 
#&gt;                 "same as\n", list("with(FUN.args, lapply(x, function(el){eval(body(FUN))}))"), 
#&gt;                 "\n"), "\n", list("\n", "Apply, but in parallel\n"), 
#&gt;             "\n", list("\n", "When ", list("plan"), " is logical, ", 
#&gt;                 list("FALSE"), " means use current plan.\n", 
#&gt;                 "If ", list("plan=TRUE"), ", then it equals to ", 
#&gt;                 list("plan='multicore'"), ". For\n", "characters, ", 
#&gt;                 list("plan"), " can be ", list("'multicore'"), 
#&gt;                 ", ", list("'callr'"), ",\n", list("'sequential'"), 
#&gt;                 ", ", list("'multisession'"), ", ", list("'multiprocess'"), 
#&gt;                 ",\n", "etc. Alternatively, you could pass future ", 
#&gt;                 list(list("plan")), "\n", "objects.\n"), "\n", 
#&gt;             list("\n", "\n", "library(future)\n", "plan(sequential)\n", 
#&gt;                 "\n", "# Use sequential plan\n", "# 1. Change `plan` to 'multicore', 'multisession', or TRUE to enable\n", 
#&gt;                 "# multi-core, but still with progress information\n", 
#&gt;                 "# 2. Change plan=FALSE will use current future plan\n", 
#&gt;                 "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = function(e){\n", 
#&gt;                 "  sprintf('Input=%d', e)\n", "}, plan = 'sequential')\n", 
#&gt;                 "\n", "# Disable callback message, then the function reduce to\n", 
#&gt;                 "# normal `future.apply::future_lapply`\n", "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = NULL, plan = FALSE)\n", 
#&gt;                 "\n", "\n"), "\n"), lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lock.R", 
#&gt;             "\n", list("lock"), "\n", list("lock"), "\n", list(
#&gt;                 "dipsaus_lock"), "\n", list("dipsaus_unlock"), 
#&gt;             "\n", list("Create or Unlock a Lock"), "\n", list(
#&gt;                 "\n", "dipsaus_lock(name, exclusive = TRUE, timeout = 10)\n", 
#&gt;                 "\n", "dipsaus_unlock(name, exclusive = TRUE, timeout = 10)\n"), 
#&gt;             "\n", list("\n", list(list("name"), list("character, the locker's name, must be only letters and digits")), 
#&gt;                 "\n", "\n", list(list("exclusive"), list("logical whether the locker is exclusive. True for write\n", 
#&gt;                   "access, False for read access. Default is true.")), 
#&gt;                 "\n", "\n", list(list("timeout"), list("numeric, seconds to wait for the locker to lock or unlock")), 
#&gt;                 "\n"), "\n", list("\n", "Logical, whether the operation succeed.\n"), 
#&gt;             "\n", list("\n", "A wrapper for ", list(list("lock")), 
#&gt;                 ", but user can\n", "interrupt the lock procedure anytime, and don't have to worry about\n", 
#&gt;                 "whether the lock exists or not.\n"), "\n", list(
#&gt;                 "\n", "# unlock to prepare for the example\n", 
#&gt;                 "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "# Create a locker, return TRUE\n", "lock_success = dipsaus_lock('testlocker')\n", 
#&gt;                 "if(lock_success){\n", "  cat2('testlocker has been locked')\n", 
#&gt;                 "}\n", "\n", "# test whether locker has been locked\n", 
#&gt;                 "lock_success = dipsaus_lock('testlocker', timeout = 0.01)\n", 
#&gt;                 "if(!lock_success){\n", "  cat2('attempt to lock testlocker failed')\n", 
#&gt;                 "}\n", "\n", "# unlock\n", "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "\n"), "\n"), make_async_evaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("make_async_evaluator"), "\n", list("make_async_evaluator"), 
#&gt;             "\n", list("Create Asynchronous Evaluator to Queue Tasks"), 
#&gt;             "\n", list("\n", "make_async_evaluator(\n", "  name,\n", 
#&gt;                 "  path = tempfile(),\n", "  n_nodes = 1,\n", 
#&gt;                 "  n_subnodes = future::availableCores() - 1,\n", 
#&gt;                 "  verbose = FALSE,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("name"), list("unique name for the evaluator")), 
#&gt;                 "\n", "\n", list(list("path"), list("blank directory for evaluator to store data")), 
#&gt;                 "\n", "\n", list(list("n_nodes"), list("number of control nodes, default is 1")), 
#&gt;                 "\n", "\n", list(list("n_subnodes"), list("number of sub-sessions for each control node, default is\n", 
#&gt;                   "the number of CPU cores minus 1")), "\n", 
#&gt;                 "\n", list(list("verbose"), list("for internal debug use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to the constructor of ", 
#&gt;                   list(list("MasterEvaluator")))), "\n"), "\n", 
#&gt;             list("\n", "Asynchronous evaluator aims at queuing R evaluations from sub-processes\n", 
#&gt;                 "without blocking the main session. It's based on ", 
#&gt;                 list("'parallel'"), " and\n", list("'future'"), 
#&gt;                 " packages.\n"), "\n", list("\n", list("'parallel'"), 
#&gt;                 " blocks the main session when evaluating expressions.\n", 
#&gt;                 list("'future'"), " blocks the main session when the number of running futures\n", 
#&gt;                 "exceed the maximum number of workers. (For example if 4 workers are planned,\n", 
#&gt;                 "then running 5 future instances at the same time will freeze the session).\n", 
#&gt;                 "\n", "Asynchronous evaluator is designed to queue any number of R expressions\n", 
#&gt;                 "without blocking the main session. The incoming expressions are stored in\n", 
#&gt;                 list(list("AbstractQueue")), " instances, and main session monitors\n", 
#&gt;                 "the queue and is charge of notifying child sessions to evaluate these\n", 
#&gt;                 "expressions whenever available.\n", "\n", "Important: Asynchronous evaluator is not designed for super high-performance\n", 
#&gt;                 "computing. The internal scheduler schedules ", 
#&gt;                 list("n_nodes"), " evaluations for\n", "every 1 second. Therefore if each of the process can be finished within\n", 
#&gt;                 list("1 / n_nodes"), " seconds, then use `future` instead.\n"), 
#&gt;             "\n", list(list("Value"), list("\n", "\n", "\n", 
#&gt;                 "A list of functions to control the evaluator:\n", 
#&gt;                 "\n", list("\n", "\n", list(list(list("run(expr, success = NULL, failure = NULL, priority = 0,\n", 
#&gt;                   "persist = FALSE, quoted = FALSE, ..., .list = NULL)")), 
#&gt;                   list("\n", "Queue and run an R expression.\n", 
#&gt;                     "\n", list("\n", "\n", list(list(list("expr")), 
#&gt;                       list("\n", " can be anything except for\n", 
#&gt;                         list("q()"), ", which terminates the session. ", 
#&gt;                         list("'rlang'"), "\n", list(list("nse-force")), 
#&gt;                         " is also supported. For example, you\n", 
#&gt;                         "can use ", list("`!!`"), " to quasi-quote the expression and unquote the values.\n")), 
#&gt;                       "\n", "\n", list(list(list("..., .list")), 
#&gt;                         list("\n", "provides additional data for ", 
#&gt;                           list("expr"), ". For example,\n", list(
#&gt;                             "expr"), " uses a large data object ", 
#&gt;                           list("dat"), " in the main session, which\n", 
#&gt;                           "might not be available to the child sessions. Also because the object\n", 
#&gt;                           "is large, quasi-quotation could be slow or fail. By passing ", 
#&gt;                           list("dat=..."), "\n", "or ", list(
#&gt;                             ".list=list(dat=...)"), ", it's able to temporary store the data on\n", 
#&gt;                           "hard-drive and persist for evaluators. The back-end is using\n", 
#&gt;                           list(list("qs_map")), ", which is super fast for data that are no\n", 
#&gt;                           "more than ", list("2GB"), ".\n")), 
#&gt;                       "\n", "\n", list(list(list("success"), 
#&gt;                         " and ", list("failure")), list("\n", 
#&gt;                         "functions to handle the results once\n", 
#&gt;                         "the evaluator returns the value. Since it's almost impossible to know\n", 
#&gt;                         "when the evaluator returns values, it's recommended that these functions\n", 
#&gt;                         "to be simple.\n")), "\n", "\n", list(
#&gt;                         list(list("priority")), list("\n", "puts the priority of the expression. It can only be `0` or\n", 
#&gt;                           "`1`. Evaluators will run expressions with priority equal to 1 first.\n")), 
#&gt;                       "\n", "\n", list(list(list("persist")), 
#&gt;                         list("\n", "indicates whether to run the expression and persist\n", 
#&gt;                           "intermediate variables.\n")), "\n"), 
#&gt;                     "\n")), "\n", "\n", list(list(list("terminate()")), 
#&gt;                   list("\n", "Shut down and release all the resource.\n")), 
#&gt;                   "\n", "\n", list(list(list("scale_down(n_nodes, n_subnodes = 1)"), 
#&gt;                     ",\n", "      ", list("scale_up(n_nodes, n_subnodes = 1,\n", 
#&gt;                       "      create_if_missing = FALSE, path = tempfile())")), 
#&gt;                     list("\n", "Scale down or up the evaluator.\n", 
#&gt;                       list("\n", list(list(list("n_nodes"), " and ", 
#&gt;                         list("n_subnodes")), list(" see 'usage' ")), 
#&gt;                         "\n", list(list(list("create_if_missing")), 
#&gt;                           list("\n", "If the evaluator was previously terminated or shutdown, setting this to be\n", 
#&gt;                             "true ignores the `invalid` flags and re-initialize the evaluator\n")), 
#&gt;                         "\n", list(list(list("path")), list("\n", 
#&gt;                           "If ", list("create_if_missing"), " is true, then ", 
#&gt;                           list("path"), " will be passed to\n", 
#&gt;                           "the constructor of ", list(list("MasterEvaluator")), 
#&gt;                           ". See 'usage'.\n")), "\n"), "\n")), 
#&gt;                   "\n", "\n", "\n", list(list(list("workers(...)")), 
#&gt;                     list("\n", "Returns number of workers available in the evaluator. ", 
#&gt;                       list("`...`"), " is for\n", "debug use\n")), 
#&gt;                   "\n", "\n", list(list(list("progress()")), 
#&gt;                     list("\n", "Returns a vector of 4 integers. They are:\n", 
#&gt;                       list("\n", list(), list(" The total number evaluations. "), 
#&gt;                         "\n", list(), list(" Number of running evaluations. "), 
#&gt;                         "\n", list(), list(" Number of awaiting evaluations. "), 
#&gt;                         "\n", list(), list(" Number of finished evaluations. "), 
#&gt;                         "\n"), "\n")), "\n", "\n"), "\n")), "\n", 
#&gt;             "\n"), make_forked_clusters.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels.R", 
#&gt;             "\n", list("make_forked_clusters"), "\n", list("make_forked_clusters"), 
#&gt;             "\n", list("Create forked clusters"), "\n", list(
#&gt;                 "\n", "make_forked_clusters(\n", "  workers = future::availableCores(constraints = \"multicore\"),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "workers"), list("positive integer, number of cores to use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passing to ", 
#&gt;                   list("future::plan"))), "\n"), "\n", list("\n", 
#&gt;                 "number of cores\n"), "\n", list("\n", "Create forked clusters\n"), 
#&gt;             "\n", list("\n", "This is a wrapper for ", list("future::plan(future::multicore, ...)"), 
#&gt;                 ".\n", "However, since version 1.14.0, forked clusters are disabled in `RStudio` by\n", 
#&gt;                 "default, and you usually need to enable it manually. This function provides\n", 
#&gt;                 "a simple way of enable it and plan the future at the same time.\n"), 
#&gt;             "\n"), map.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-s3.R", 
#&gt;             "\n", list("map"), "\n", list("map"), "\n", list(
#&gt;                 "session_map"), "\n", list("rds_map"), "\n", 
#&gt;             list("text_map"), "\n", list("qs_map"), "\n", list(
#&gt;                 "redis_map"), "\n", list("Create R object map."), 
#&gt;             "\n", list("\n", "session_map(map = fastmap::fastmap())\n", 
#&gt;                 "\n", "rds_map(path = tempfile())\n", "\n", "text_map(path = tempfile())\n", 
#&gt;                 "\n", "qs_map(path = tempfile())\n", "\n", "redis_map(name = rand_string())\n"), 
#&gt;             "\n", list("\n", list(list("map"), list("a ", list(
#&gt;                 "fastmap::fastmap()"), " list")), "\n", "\n", 
#&gt;                 list(list("path"), list("directory path where map data should be stored")), 
#&gt;                 "\n", "\n", list(list("name"), list("character, map name. If map names are the same, the data\n", 
#&gt;                   "will be shared.")), "\n"), "\n", list("\n", 
#&gt;                 "An ", list("R6"), " instance that inherits ", 
#&gt;                 list(list("AbstractMap")), "\n"), "\n", list(
#&gt;                 "\n", "Provides five types of map that fit in different use cases.\n"), 
#&gt;             "\n", list("\n", "There are five types of map implemented. They all inherit class\n", 
#&gt;                 list(list("AbstractMap")), ". There are several differences in\n", 
#&gt;                 "use case scenarios and they backend implementations.\n", 
#&gt;                 "\n", list("\n", list(list(list(list("session_map"))), 
#&gt;                   list("\n", "A session map takes a ", list(list(
#&gt;                     "fastmap")), " object. All objects are\n", 
#&gt;                     "stored in current R session. This means you cannot access the map from other\n", 
#&gt;                     "process nor parent process. The goal of this map is to share the data across\n", 
#&gt;                     "different environments and to store global variables, as long as they share\n", 
#&gt;                     "the same map object. If you are looking for maps that can be shared\n", 
#&gt;                     "by different processes, check the rest map types. The closest map type is\n", 
#&gt;                     list("redis_map"), ", which is also memory-based.\n")), 
#&gt;                   "\n", list(list(list(list("rds_map"))), list(
#&gt;                     "\n", "An 'RDS' map uses file system to store values. The values are stored\n", 
#&gt;                     "separately in '.rds' files. Compared to session maps, 'RDS' map can be\n", 
#&gt;                     "shared across different R process. It's recommended to store\n", 
#&gt;                     "large files in ", list("rds_map"), ". If the value is not large in RAM,\n", 
#&gt;                     list("text_map"), " and ", list("redis_map"), 
#&gt;                     " are recommended.\n")), "\n", list(list(
#&gt;                     list(list("qs_map"))), list("\n", "A 'qs' map uses package 'qs' as backend. This map is very similar to\n", 
#&gt;                     list("rds_map"), ", but is especially designed for large values. For example,\n", 
#&gt;                     "pushing 1GB data to ", list("qs_map"), " will be 100 times faster than using\n", 
#&gt;                     list("rds_map"), ", and ", list("text_map"), 
#&gt;                     " will almost fail. However, compared\n", 
#&gt;                     "to ", list("rds_map"), " the stored data cannot be normally read by R as they\n", 
#&gt;                     "are compressed binary files. And ", list(
#&gt;                       "qs_map"), " is heavier than\n", list("text_map"), 
#&gt;                     ".\n")), "\n", list(list(list(list("text_map"))), 
#&gt;                     list("\n", "A 'text' map uses file system to store values. Similar to ", 
#&gt;                       list("rds_map"), ",\n", "it can be stored across multiple processes as long as the maps share the\n", 
#&gt;                       "same file directory. However, unlike ", 
#&gt;                       list("rds_map"), ", ", list("text_map"), 
#&gt;                       "\n", "the ", list("text_map"), " can only store basic data values, namely atom data types.\n", 
#&gt;                       "The supported types are: numeric, character, vector, list, matrix\n", 
#&gt;                       "It's highly recommended to convert factors to characters. Do NOT use if the\n", 
#&gt;                       "values are functions or environments. Please check\n", 
#&gt;                       list(list("write_yaml")), " for details. The recommended use case scenario\n", 
#&gt;                       "is when the speed is not the major concern, and you want to preserve data\n", 
#&gt;                       "with backward compatibility. Otherwise it's highly recommended to use\n", 
#&gt;                       list("redis_map"), ", ", list("qs_map"), 
#&gt;                       ", and ", list("rds_map"), ".\n")), "\n", 
#&gt;                   list(list(list(list("redis_map"))), list("\n", 
#&gt;                     "A 'Redis' map uses free open source software `Redis` and R package\n", 
#&gt;                     "'RcppRedis' as backend. Compared to session map, 'Redis' map can be\n", 
#&gt;                     "shared across sessions. Compared to 'text' and 'rds' maps, 'Redis' map\n", 
#&gt;                     "stores data in memory, meaning a potential of significant speed ups. To use\n", 
#&gt;                     list("redis_map"), ", you need to install `Redis` on your computer.\n", 
#&gt;                     list("\n", "  ", list(), " On Mac: use `", 
#&gt;                       list("brew install redis"), "` to install and\n", 
#&gt;                       "    `", list("brew services start redis"), 
#&gt;                       "` to start the service\n", "  ", list(), 
#&gt;                       " On Linux: use `", list("sudo apt-get install redis-server"), 
#&gt;                       "` to install\n", "    and `", list("sudo systemctl enable redis-server.service"), 
#&gt;                       "` to start the\n", "    service\n", "  ", 
#&gt;                       list(), " On Windows: Download from\n", 
#&gt;                       "    ", list("https://github.com/dmajkic/redis/downloads"), 
#&gt;                       " and double click\n", "    'redis-server.exe'\n"), 
#&gt;                     "\n")), "\n"), "\n"), "\n", list("\n", "# ----------------------Basic Usage ----------------------\n", 
#&gt;                 "\n", "# Define a path to your map.\n", "path = tempfile()\n", 
#&gt;                 "map &lt;- qs_map(path)\n", "\n", "# Reset\n", "map$reset()\n", 
#&gt;                 "\n", "# Check if the map is corrupted.\n", "map$validate()\n", 
#&gt;                 "\n", "# You have not set any key-value pairs yet.\n", 
#&gt;                 "# Let's say two parallel processes (A and B) are sharing this map.\n", 
#&gt;                 "# Process A set values\n", "map$keys()\n", "\n", 
#&gt;                 "# Start push\n", "# set a normal message\n", 
#&gt;                 "map$set(key = 'a', value = 1)\n", "\n", "# set a large object\n", 
#&gt;                 "map$set(key = 'b', value = rnorm(100000))\n", 
#&gt;                 "\n", "# set an object with hash of another object\n", 
#&gt;                 "map$set(key = 'c', value = 2, signature = list(\n", 
#&gt;                 "  parameter1 = 123,\n", "  parameter2 = 124\n", 
#&gt;                 "))\n", "\n", "# Check what's in the map from process B\n", 
#&gt;                 "mapB &lt;- qs_map(path)\n", "mapB$keys()\n", "mapB$keys(include_signatures = TRUE)\n", 
#&gt;                 "\n", "# Number of key-values pairs in the map.\n", 
#&gt;                 "mapB$size()\n", "\n", "# Check if key exists\n", 
#&gt;                 "mapB$has(c('1','a', 'c'))\n", "\n", "# Check if key exists and signature also matches\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 123,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Signature changed, then return FALSE. This is especially useful when\n", 
#&gt;                 "# value is really large and reading the value takes tons of time\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 1244444,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Destroy the map's files altogether.\n", 
#&gt;                 "mapB$destroy()\n", "\n", list("\n", "  # Once destroyed, validate will raise error\n", 
#&gt;                   "  mapB$validate()\n"), "\n", "\n", "\n"), 
#&gt;             "\n"), match_calls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("match_calls"), "\n", list("match_calls"), 
#&gt;             "\n", list("Recursively match calls and modify arguments"), 
#&gt;             "\n", list("\n", "match_calls(\n", "  call,\n", "  recursive = TRUE,\n", 
#&gt;                 "  replace_args = list(),\n", "  quoted = FALSE,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("an ", list(
#&gt;                 "R"), " expression")), "\n", "\n", list(list(
#&gt;                 "recursive"), list("logical, recursively match calls, default is true")), 
#&gt;                 "\n", "\n", list(list("replace_args"), list("named list of functions, see examples")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("logical, is ", 
#&gt;                   list("call"), " quoted")), "\n", "\n", list(
#&gt;                   list("envir"), list("which environment should call be evaluated")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters passing to ", 
#&gt;                   list("match.call"))), "\n"), "\n", list("\n", 
#&gt;                 "A nested call with all arguments matched\n"), 
#&gt;             "\n", list("\n", "Recursively match calls and modify arguments\n"), 
#&gt;             "\n", list("\n", "library(dipsaus); library(shiny)\n", 
#&gt;                 "\n", "# In shiny modules, we might want to add ns() to inputIds\n", 
#&gt;                 "# In this example, textInput(id) will become textInput(ns(id))\n", 
#&gt;                 "match_calls(lapply(1:20, function(i){\n", "  textInput(paste('id_', i), paste('Label ', i))\n", 
#&gt;                 "}), replace_args = list(\n", "  inputId = function(arg, call){ as.call(list(quote(ns), arg)) }\n", 
#&gt;                 "))\n", "\n"), "\n"), mem_limit2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("mem_limit2"), "\n", list("mem_limit2"), 
#&gt;             "\n", list("Get max RAM size\n", "This is an experimental function that is designed for non-windows systems"), 
#&gt;             "\n", list("\n", "mem_limit2()\n"), "\n", list("\n", 
#&gt;                 "a list of total free memory.\n"), "\n", list(
#&gt;                 "\n", "Get max RAM size\n", "This is an experimental function that is designed for non-windows systems\n"), 
#&gt;             "\n"), no_op.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("no_op"), "\n", list("no_op"), "\n", list(
#&gt;                 "Pipe-friendly no-operation function"), "\n", 
#&gt;             list("\n", "no_op(.x, .expr, ..., .check_fun = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("any R object")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression that produces side effects")), 
#&gt;                 "\n", "\n", list(list("..., .check_fun"), list(
#&gt;                   "see `details`")), "\n"), "\n", list("\n", 
#&gt;                 "The value of ", list(".x"), "\n"), "\n", list(
#&gt;                 "\n", "returns the first input with side effects\n"), 
#&gt;             "\n", list("\n", list("no_op"), " is a pipe-friendly function that takes any values in,\n", 
#&gt;                 "evaluate expressions but still returns input. This is very useful when\n", 
#&gt;                 "you have the same input across multiple functions and you want to use pipes.\n", 
#&gt;                 "\n", list(".expr"), " is evaluated with a special object ", 
#&gt;                 list("'.'"), ", you can use\n", list("'.'"), 
#&gt;                 " to represent ", list(".x"), " in ", list(".expr"), 
#&gt;                 ". For example, if\n", list(".x=1:100"), ", then ", 
#&gt;                 list("plot(x=seq(0,1,length.out = 100), y=.)"), 
#&gt;                 " is\n", "equivalent to ", list("plot(x=seq(0,1,length.out = 100), y=1:100)"), 
#&gt;                 ".\n", "\n", list(".check_fun"), " checks whether ", 
#&gt;                 list(".expr"), " returns a function, if yes,\n", 
#&gt;                 "then the function is called with argument ", 
#&gt;                 list(".x"), " and ", list("..."), "\n"), "\n", 
#&gt;             list("\n", "\n", "library(magrittr)\n", "\n", "## 1. Basic usage\n", 
#&gt;                 "\n", "# Will print('a') and return 'a'\n", "no_op('a', print)\n", 
#&gt;                 "\n", "# Will do nothing and return 'a' because .check_fun is false\n", 
#&gt;                 "no_op('a', print, .check_fun = FALSE)\n", "\n", 
#&gt;                 "# Will print('a') and return 'a'\n", "no_op('a', print(.), .check_fun = FALSE)\n", 
#&gt;                 "\n", "## 2. Toy example\n", "library(graphics)\n", 
#&gt;                 "\n", "par(mfrow = c(2,2))\n", "x &lt;- rnorm(100)\n", 
#&gt;                 "\n", "# hist and plot share the same input `rnorm(100)`\n", 
#&gt;                 "\n", "x %&gt;%\n", "  # .expr is a function, all ... are passed as other arguments\n", 
#&gt;                 "  no_op( hist, nclass = 10 ) %&gt;%\n", "  no_op( plot, x = seq(0,1,length.out = 100) ) %&gt;%\n", 
#&gt;                 "\n", "  # Repeat the previous two plots, but with different syntax\n", 
#&gt;                 "  no_op({ hist(., nclass = 10) }) %&gt;%\n", "  no_op({ plot(x = seq(0,1,length.out = 100), y = .) }) %&gt;%\n", 
#&gt;                 "\n", "  # The return statement is ignored\n", 
#&gt;                 "\n", "  no_op({ return(x + 1)}) -&gt;\n", "  y\n", 
#&gt;                 "\n", "# x is returned at the end\n", "\n", "identical(x, y)   # TRUE\n", 
#&gt;                 "\n"), "\n"), package_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("package_installed"), "\n", list("package_installed"), 
#&gt;             "\n", list("Check if a package is installed"), "\n", 
#&gt;             list("\n", "package_installed(pkgs, all = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("pkgs"), list("vector of package names")), 
#&gt;                 "\n", "\n", list(list("all"), list("only returns TRUE if all packages are installed. Default is FALSE.")), 
#&gt;                 "\n"), "\n", list("\n", "logical, if packages are installed or not. If ", 
#&gt;                 list("all=TRUE"), ", return\n", "a logical value of whether all packages a re installed.\n"), 
#&gt;             "\n", list("\n", "Check if a package is installed\n"), 
#&gt;             "\n", list("\n", "\n", "# Check if package base and dipsaus are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'))\n", 
#&gt;                 "\n", "# Check if all required packages are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'), all = TRUE)\n", 
#&gt;                 "\n"), "\n"), parse_svec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("parse_svec"), "\n", list("parse_svec"), 
#&gt;             "\n", list("Parse Text Into Numeric Vectors\n", "\n", 
#&gt;                 "(stable)"), "\n", list("\n", "parse_svec(text, sep = \",\", connect = \"-:|\", sort = FALSE, unique = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("text"), list("string with chunks, e.g. ", 
#&gt;                 list("\"1-10, 14, 16-20, 18-30\""), " has 4 chunks")), 
#&gt;                 "\n", "\n", list(list("sep"), list("default is \",\", character used to separate chunks")), 
#&gt;                 "\n", "\n", list(list("connect"), list("characters defining connection links for example \"1:10\" is the same as \"1-10\"")), 
#&gt;                 "\n", "\n", list(list("sort"), list("sort the result")), 
#&gt;                 "\n", "\n", list(list("unique"), list("extract unique elements")), 
#&gt;                 "\n"), "\n", list("\n", "a numeric vector. For example, \"1-3\" returns ", 
#&gt;                 list("c(1, 2, 3)"), "\n"), "\n", list("\n", "Parse Text Into Numeric Vectors\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "parse_svec('1-10, 13:15,14-20')\n"), 
#&gt;             "\n", list("\n", list(list("deparse_svec")), "\n"), 
#&gt;             "\n"), prepare_install.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("prepare_install"), "\n", list("prepare_install"), 
#&gt;             "\n", list("Install Packages at Next Startup"), "\n", 
#&gt;             list("\n", "prepare_install(\n", "  packages,\n", 
#&gt;                 "  update_all = FALSE,\n", "  restart = FALSE,\n", 
#&gt;                 "  repos = getOption(\"repos\")\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("packages"), list("characters, vector of package names")), 
#&gt;                 "\n", "\n", list(list("update_all"), list("whether to update all installed packages before\n", 
#&gt;                   "installation; default is false")), "\n", "\n", 
#&gt;                 list(list("restart"), list("whether to restart session automatically")), 
#&gt;                 "\n", "\n", list(list("repos"), list("repositories to search for packages")), 
#&gt;                 "\n"), "\n", list("\n", "None\n"), "\n", list(
#&gt;                 "\n", "Register temporary code that will install packages at\n", 
#&gt;                 "next session. The code will be automatically removed once executed.\n"), 
#&gt;             "\n", list("\n", "Installing packages in R session could require restarts if\n", 
#&gt;                 "a package to be updated has been loaded. Normally restarting R\n", 
#&gt;                 "fixes the problem. However, under some circumstances, such as with a\n", 
#&gt;                 "startup code in profile, restarting R might still fail the\n", 
#&gt;                 "installation. ", list("prepare_install"), " inserts the installation\n", 
#&gt;                 "code prior to the startup code so that next time the code will get\n", 
#&gt;                 "executed before any other packages are loaded.\n", 
#&gt;                 "Once the temporary code get executed, no matter succeeded or not,\n", 
#&gt;                 "it will be removed from startup profile.\n"), 
#&gt;             "\n"), progress2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("progress2"), "\n", list("progress2"), 
#&gt;             "\n", list("'Shiny' progress bar, but can run without reactive context"), 
#&gt;             "\n", list("\n", "progress2(\n", "  title,\n", "  max = 1,\n", 
#&gt;                 "  ...,\n", "  quiet = FALSE,\n", "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  shiny_auto_close = FALSE,\n", "  log = NULL\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("title"), 
#&gt;                 list("character, task description")), "\n", "\n", 
#&gt;                 list(list("max"), list("maximum number of items in the queue")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("shiny::Progress$new(...)"))), "\n", "\n", 
#&gt;                 list(list("quiet"), list("suppress console output, ignored in shiny context.")), 
#&gt;                 "\n", "\n", list(list("session"), list("'shiny' session, default is current reactive domain")), 
#&gt;                 "\n", "\n", list(list("shiny_auto_close"), list(
#&gt;                   "logical, automatically close 'shiny' progress bar\n", 
#&gt;                   "once current observer is over. Default is ", 
#&gt;                   list("FALSE"), ". If setting to\n", list("TRUE"), 
#&gt;                   ", then it's equivalent to\n", list("p &lt;- progress2(...); on.exit({p$close()}, add = TRUE)"), 
#&gt;                   ".")), "\n", "\n", list(list("log"), list("function when running locally, default is ", 
#&gt;                   list("NULL"), ",\n", "which redirects to ", 
#&gt;                   list(list("cat2")))), "\n"), "\n", list("\n", 
#&gt;                 "A list of functions:\n", list("\n", list(list(
#&gt;                   list("inc(detail, message = NULL, amount = 1, ...)")), 
#&gt;                   list("\n", "Increase progress bar by ", list(
#&gt;                     "amount"), " (default is 1).\n")), "\n", 
#&gt;                   list(list(list("close()")), list("\n", "Close the progress\n")), 
#&gt;                   "\n", list(list(list("reset(detail = '', message = '', value = 0)")), 
#&gt;                     list("\n", "Reset the progress to ", list(
#&gt;                       "value"), " (default is 0), and reset information\n")), 
#&gt;                   "\n", list(list(list("get_value()")), list(
#&gt;                     "\n", "Get current progress value\n")), "\n", 
#&gt;                   list(list(list("is_closed()")), list("\n", 
#&gt;                     "Returns logical value if the progress is closed or not.\n")), 
#&gt;                   "\n"), "\n"), "\n", list("\n", "'Shiny' progress bar, but can run without reactive context\n"), 
#&gt;             "\n", list("\n", "\n", "progress &lt;- progress2('Task A', max = 2)\n", 
#&gt;                 "progress$inc('Detail 1')\n", "progress$inc('Detail 2')\n", 
#&gt;                 "progress$close()\n", "\n", "# Check if progress is closed\n", 
#&gt;                 "progress$is_closed()\n", "\n", "# ------------------------------ Shiny Example ------------------------------\n", 
#&gt;                 "library(shiny)\n", "library(dipsaus)\n", "\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  actionButtonStyled('do', 'Click Here', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    updateActionButtonStyled(session, 'do', disabled = TRUE)\n", 
#&gt;                 "    progress &lt;- progress2('Task A', max = 10, shiny_auto_close = TRUE)\n", 
#&gt;                 "    lapply(1:10, function(ii){\n", "      progress$inc(sprintf('Detail %d', ii))\n", 
#&gt;                 "      Sys.sleep(0.2)\n", "    })\n", "    updateActionButtonStyled(session, 'do', disabled = FALSE)\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         registerInputBinding.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("registerInputBinding"), "\n", list("registerInputBinding"), 
#&gt;             "\n", list("Register customized input to enable support by compound input"), 
#&gt;             "\n", list("\n", "registerInputBinding(fname, pkg, shiny_binding, update_function = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("character, function name, such as ", 
#&gt;                 list("\"textInput\""))), "\n", "\n", list(list(
#&gt;                 "pkg"), list("character, package name, like ", 
#&gt;                 list("\"shiny\""))), "\n", "\n", list(list("shiny_binding"), 
#&gt;                 list("character, 'JavaScript' binding name.See examples")), 
#&gt;                 "\n", "\n", list(list("update_function"), list(
#&gt;                   "character, update function such as ", list(
#&gt;                     "\"shiny::textInput\""))), "\n"), "\n", list(
#&gt;                 "\n", "a list of binding functions, one is `JavaScript` object key in\n", 
#&gt;                 list("Shiny.inputBindings"), ", the other is `shiny` update function in R end.\n"), 
#&gt;             "\n", list("\n", "Register customized input to enable support by compound input\n"), 
#&gt;             "\n", list("\n", "\n", "# register shiny textInput\n", 
#&gt;                 "registerInputBinding('textInput', 'shiny',\n", 
#&gt;                 "                     'shiny.textInput', 'shiny::updateTextInput')\n", 
#&gt;                 "\n", "# Register shiny actionLink\n", "# In \"Shiny.inputbindings\", the binding name is \"shiny.actionButtonInput\",\n", 
#&gt;                 "# Shiny update function is \"shiny::updateActionButton\"\n", 
#&gt;                 "registerInputBinding('actionLink', 'shiny',\n", 
#&gt;                 "                     'shiny.actionButtonInput', 'shiny::updateActionButton')\n", 
#&gt;                 "\n"), "\n"), screenshot.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("screenshot"), "\n", list("screenshot"), 
#&gt;             "\n", list("Take a screenshot in shiny apps"), "\n", 
#&gt;             list("\n", "screenshot(inputId, session = shiny::getDefaultReactiveDomain())\n"), 
#&gt;             "\n", list("\n", list(list("inputId"), list("the input id where the screenshot should be")), 
#&gt;                 "\n", "\n", list(list("session"), list("shiny session")), 
#&gt;                 "\n"), "\n", list("\n", "None. However, the screenshot results can be accessed from\n", 
#&gt;                 "shiny input\n"), "\n", list("\n", "Take a screenshot of the whole page and save encoded\n", 
#&gt;                 list("DataURI"), " that can be accessed via ", 
#&gt;                 list("input[[inputId]]"), ".\n"), "\n", list(
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  tagList(\n", "    shiny::singleton(shiny::tags$head(\n", 
#&gt;                 "      shiny::tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"dipsaus/dipsaus.css\"),\n", 
#&gt;                 "      shiny::tags$script(src=\"dipsaus/dipsaus-dipterix-lib.js\")\n", 
#&gt;                 "    ))\n", "  ),\n", "  actionButtonStyled('do', 'Take Screenshot'),\n", 
#&gt;                 "  compoundInput2('group', label = 'Group', components = list(\n", 
#&gt;                 "    textInput('txt', 'Enter something here')\n", 
#&gt;                 "  ))\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    screenshot('screeshot_result')\n", 
#&gt;                 "  })\n", "  observeEvent(input$screeshot_result, {\n", 
#&gt;                 "    showModal(modalDialog(\n", "      tags$img(src = input$screeshot_result, width = '100%')\n", 
#&gt;                 "    ))\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         set_shiny_input.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("set_shiny_input"), "\n", list("set_shiny_input"), 
#&gt;             "\n", list("Set Shiny Input"), "\n", list("\n", "set_shiny_input(\n", 
#&gt;                 "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  inputId,\n", "  value,\n", "  priority = c(\"event\", \"deferred\", \"immediate\"),\n", 
#&gt;                 "  method = c(\"proxy\", \"serialize\", \"value\", \"expression\"),\n", 
#&gt;                 "  quoted = TRUE\n", ")\n"), "\n", list("\n", 
#&gt;                 list(list("session"), list("shiny session, see shiny ", 
#&gt;                   list(list("domains")))), "\n", "\n", list(list(
#&gt;                   "inputId"), list("character, input ID")), "\n", 
#&gt;                 "\n", list(list("value"), list("the value to assign")), 
#&gt;                 "\n", "\n", list(list("priority"), list("characters, options are \"event\", \"deferred\", and \"immediate\".\n", 
#&gt;                   "\"event\" and \"immediate\" are similar, they always fire changes. \"deferred\"\n", 
#&gt;                   "fire signals to other reactive/observers only when the input value has been\n", 
#&gt;                   "changed")), "\n", "\n", list(list("method"), 
#&gt;                   list("characters, options are \"proxy\", \"serialize\", \"value\",\n", 
#&gt;                     "\"expression\". \"proxy\" is recommended, other methods are experimental.")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("is value quoted? Only used when method is \"expression\"")), 
#&gt;                 "\n"), "\n", list("\n", "Shiny `input' object is read-only reactive list. When try to\n", 
#&gt;                 "assign values to input, errors usually occur. This method provides several\n", 
#&gt;                 "work-around to set values to input. Please use along with\n", 
#&gt;                 list(list("use_shiny_dipsaus")), ".\n"), "\n", 
#&gt;             list("\n", "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  # Register widgets\n", 
#&gt;                 "  use_shiny_dipsaus(),\n", "  actionButton('run', 'Set Input'),\n", 
#&gt;                 "  verbatimTextOutput('input_value')\n", ")\n", 
#&gt;                 "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  start = Sys.time()\n", "\n", "  output$input_value &lt;- renderPrint({\n", 
#&gt;                 "\n", "    now &lt;- input$key\n", "    now %?&lt;-% start\n", 
#&gt;                 "    cat('This app has been opened for ',\n", 
#&gt;                 "        difftime(now, start, units = 'sec'), ' seconds')\n", 
#&gt;                 "  })\n", "\n", "  observeEvent(input$run, {\n", 
#&gt;                 "    # setting input$key to Sys.time()\n", "    set_shiny_input(session, 'key', Sys.time())\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n"), 
#&gt;             "\n"), shift_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("shift_array"), "\n", list("shift_array"), 
#&gt;             "\n", list("Shift Array by Index"), "\n", list("\n", 
#&gt;                 "shift_array(x, shift_idx, shift_by, shift_amount)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("array, must have at least matrix")), 
#&gt;                 "\n", "\n", list(list("shift_idx"), list("which index is to be shifted")), 
#&gt;                 "\n", "\n", list(list("shift_by"), list("which dimension decides ", 
#&gt;                   list("shift_amount"))), "\n", "\n", list(list(
#&gt;                   "shift_amount"), list("shift amount along ", 
#&gt;                   list("shift_idx"))), "\n"), "\n", list("\n", 
#&gt;                 "Re-arrange arrays in parallel\n"), "\n", list(
#&gt;                 "\n", "A simple use-case for this function is to think of a matrix where each row\n", 
#&gt;                 "is a signal and columns stand for time. The objective is to align (time-lock)\n", 
#&gt;                 "each signal according to certain events. For each signal, we want to shift\n", 
#&gt;                 "the time points by certain amount.\n", "\n", 
#&gt;                 "In this case, the shift amount is defined by ", 
#&gt;                 list("shift_amount"), ", whose\n", "length equals to number of signals. ", 
#&gt;                 list("shift_idx=2"), " as we want to shift\n", 
#&gt;                 "time points (column, the second dimension) for each signal. ", 
#&gt;                 list("shift_by=1"), "\n", "because the shift amount is depend on the signal number.\n"), 
#&gt;             "\n", list("\n", "x &lt;- matrix(1:10, nrow = 2, byrow = TRUE)\n", 
#&gt;                 "z &lt;- shift_array(x, 2, 1, c(1,2))\n", "\n", 
#&gt;                 "y &lt;- NA * x\n", "y[1,1:4] = x[1,2:5]\n", "y[2,1:3] = x[2,3:5]\n", 
#&gt;                 "\n", "# Check if z ang y are the same\n", "z - y\n", 
#&gt;                 "\n", "# array case\n", "# x is Trial x Frequency x Time\n", 
#&gt;                 "x &lt;- array(1:27, c(3,3,3))\n", "\n", "# Shift time for each trial, amount is 1, -1, 0\n", 
#&gt;                 "shift_amount &lt;- c(1,-1,0)\n", "z &lt;- shift_array(x, 3, 1, shift_amount)\n", 
#&gt;                 "par(mfrow = c(3, 2))\n", "for( ii in 1:3 ){\n", 
#&gt;                 "  image(t(x[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Trial', ii))\n", "  image(t(z[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Shifted amount:', shift_amount[ii]))\n", 
#&gt;                 "}\n", "\n"), "\n"), sync_shiny_inputs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-syncInputs.R", 
#&gt;             "\n", list("sync_shiny_inputs"), "\n", list("sync_shiny_inputs"), 
#&gt;             "\n", list("Synchronize Shiny Inputs"), "\n", list(
#&gt;                 "\n", "sync_shiny_inputs(\n", "  input,\n", "  session,\n", 
#&gt;                 "  inputIds,\n", "  uniform = rep(\"I\", length(inputIds)),\n", 
#&gt;                 "  updates,\n", "  snap = 250\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("input, session"), list("shiny reactive objects")), 
#&gt;                 "\n", "\n", list(list("inputIds"), list("input ids to be synchronized")), 
#&gt;                 "\n", "\n", list(list("uniform"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", converting inputs\n", 
#&gt;                   "to a uniform values")), "\n", "\n", list(list(
#&gt;                   "updates"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", updating input values")), 
#&gt;                 "\n", "\n", list(list("snap"), list("numeric, milliseconds to defer the changes")), 
#&gt;                 "\n"), "\n", list("\n", "none.\n"), "\n", list(
#&gt;                 "\n", "Synchronize Shiny Inputs\n"), "\n", list(
#&gt;                 "\n", "\n", "library(shiny)\n", "\n", "ui &lt;- fluidPage(\n", 
#&gt;                 "  textInput('a', 'a', value = 'a'),\n", "  sliderInput('b', 'b', value = 1, min = 0, max = 1000)\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  sync_shiny_inputs(input, session, inputIds = c('a', 'b'), uniform = list(\n", 
#&gt;                 "    function(a){as.numeric(a)},\n", "    'I'\n", 
#&gt;                 "  ), updates = list(\n", "    function(a){updateTextInput(session, 'a', value = a)},\n", 
#&gt;                 "    function(b){updateSliderInput(session, 'b', value = b)}\n", 
#&gt;                 "  ))\n", "\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         time_delta.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("time_delta"), "\n", list("time_delta"), 
#&gt;             "\n", list("Calculate time difference and return a number"), 
#&gt;             "\n", list("\n", "time_delta(t1, t2, units = \"secs\")\n"), 
#&gt;             "\n", list("\n", list(list("t1"), list("time start")), 
#&gt;                 "\n", "\n", list(list("t2"), list("time end")), 
#&gt;                 "\n", "\n", list(list("units"), list("character, choices are ", 
#&gt;                   list("'secs'"), ", ", list("'mins'"), ", ", 
#&gt;                   list("'hours'"), ", and ", list("'days'"))), 
#&gt;                 "\n"), "\n", list("\n", "numeric difference of time in units specified\n"), 
#&gt;             "\n", list("\n", "Calculate time difference and return a number\n"), 
#&gt;             "\n", list("\n", "a = Sys.time()\n", "Sys.sleep(0.3)\n", 
#&gt;                 "b = Sys.time()\n", "\n", "time_delta(a, b) # In seconds, around 0.3\n", 
#&gt;                 "time_delta(a, b, 'mins') # in minutes, around 0.005\n", 
#&gt;                 "\n"), "\n"), to_datauri.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_datauri"), "\n", list("to_datauri"), 
#&gt;             "\n", list("Convert file to 'base64' format"), "\n", 
#&gt;             list("\n", "to_datauri(file, mime = \"\")\n"), "\n", 
#&gt;             list("\n", list(list("file"), list("file path")), 
#&gt;                 "\n", "\n", list(list("mime"), list("'mime' type, default is blank")), 
#&gt;                 "\n"), "\n", list("\n", "a 'base64' data string looks like ", 
#&gt;                 list("'data:;base64,AEF6986...'"), "\n"), "\n", 
#&gt;             list("\n", "Convert file to 'base64' format\n"), 
#&gt;             "\n"), to_ram_size.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_ram_size"), "\n", list("to_ram_size"), 
#&gt;             "\n", list("Convert bytes to KB, MB, GB,..."), "\n", 
#&gt;             list("\n", "to_ram_size(s, kb_to_b = 1000)\n"), "\n", 
#&gt;             list("\n", list(list("s"), list("size")), "\n", "\n", 
#&gt;                 list(list("kb_to_b"), list("how many bytes counts one KB, 1000 by default")), 
#&gt;                 "\n"), "\n", list("\n", "numeric equaling to ", 
#&gt;                 list("s"), " but formatted\n"), "\n", list("\n", 
#&gt;                 "Convert bytes to KB, MB, GB,...\n"), "\n"), 
#&gt;         updateActionButtonStyled.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("updateActionButtonStyled"), "\n", list(
#&gt;                 "updateActionButtonStyled"), "\n", list("Update styled action button"), 
#&gt;             "\n", list("\n", "updateActionButtonStyled(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  label = NULL,\n", "  icon = NULL,\n", 
#&gt;                 "  type = NULL,\n", "  disabled = NULL,\n", "  ...\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("session, inputId, label, icon"), 
#&gt;                 list("passed to ", list("shiny::updateActionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type to update")), 
#&gt;                 "\n", "\n", list(list("disabled"), list("whether to disable the button")), 
#&gt;                 "\n", "\n", list(list("..."), list("ignored")), 
#&gt;                 "\n"), "\n", list("\n", "none\n"), "\n", list(
#&gt;                 "\n", "Update styled action button\n"), "\n", 
#&gt;             list("\n", list(list("actionButtonStyled")), " for how to define the button.\n"), 
#&gt;             "\n"), updateCompoundInput2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("updateCompoundInput2"), "\n", list("updateCompoundInput2"), 
#&gt;             "\n", list("Update compound inputs"), "\n", list(
#&gt;                 "\n", "updateCompoundInput2(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  value = NULL,\n", "  ncomp = NULL,\n", 
#&gt;                 "  initialization = NULL,\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("session"), list("shiny session or session proxy")), 
#&gt;                 "\n", "\n", list(list("inputId"), list("character see ", 
#&gt;                   list("compoundInput2"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, see ", 
#&gt;                     list("compoundInput2"), " or examples")), 
#&gt;                 "\n", "\n", list(list("ncomp"), list("integer, non-negative number of groups to update, ", 
#&gt;                   list("NULL"), " to\n", "remain unchanged")), 
#&gt;                 "\n", "\n", list(list("initialization, ..."), 
#&gt;                   list("named list of other updates")), "\n"), 
#&gt;             "\n", list("\n", "none\n"), "\n", list("\n", "Update compound inputs\n"), 
#&gt;             "\n", list("\n", "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "\n", "## UI side\n", "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    '',                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "## server side:\n", "updateCompoundInput2(session, 'inputid',\n", 
#&gt;                 "                     # Change the first 3 groups\n", 
#&gt;                 "                     value = lapply(1:3, function(ii){\n", 
#&gt;                 "                       list(sli = runif(1))\n", 
#&gt;                 "                     }),\n", "                     # Change text label for all groups\n", 
#&gt;                 "                     initialization = list(\n", 
#&gt;                 "                       text = list(label = as.character(Sys.time()))\n", 
#&gt;                 "                     ))\n"), "\n", "\n"), "\n", 
#&gt;             list("\n", list(list("compoundInput2")), " for how to define components.\n"), 
#&gt;             "\n"), update_fastmap2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fastmap2.R", 
#&gt;             "\n", list("update_fastmap2"), "\n", list("update_fastmap2"), 
#&gt;             "\n", list("Migrate a ", list("fastmap2"), " object to a new one"), 
#&gt;             "\n", list("\n", "update_fastmap2(from, to, override = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("from, to"), list(list(
#&gt;                 "fastmap2"), " object")), "\n", "\n", list(list(
#&gt;                 "override"), list("whether to override keys in ", 
#&gt;                 list("to"), " if they exist")), "\n"), "\n", 
#&gt;             list("\n", "Map ", list("to"), "\n"), "\n", list(
#&gt;                 "\n", "Migrate a ", list("fastmap2"), " object to a new one\n"), 
#&gt;             "\n", list("\n", list(list("fastmap2")), "\n"), "\n"), 
#&gt;         use_shiny_dipsaus.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("use_shiny_dipsaus"), "\n", list("use_shiny_dipsaus"), 
#&gt;             "\n", list("Set up shiny plugins"), "\n", list("\n", 
#&gt;                 "use_shiny_dipsaus()\n"), "\n", list("\n", "This function must be called from a Shiny app's UI in order for\n", 
#&gt;                 "some widgets to work.\n"), "\n")), source = list(
#&gt;         AbstractMap.Rd = "R/map-abstract.R", AbstractQueue.Rd = "R/queue-abstract.R", 
#&gt;         MasterEvaluator.Rd = "R/parallels-workers.R", PersistContainer.Rd = "R/persist.R", 
#&gt;         actionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         ask_or_default.Rd = "R/strings.R", ask_yesno.Rd = "R/strings.R", 
#&gt;         async.Rd = "R/parallels.R", async_expr.Rd = "R/parallels.R", 
#&gt;         async_flapply.Rd = "R/parallels.R", base64_to_image.Rd = "R/screenshot.R", 
#&gt;         baseline_array.Rd = "R/cpp-baseline_array.R", cat2.Rd = "R/strings.R", 
#&gt;         check_installed_packages.Rd = "R/utils-package.R", col2hexStr.Rd = "R/strings.R", 
#&gt;         collapse.Rd = "R/cpp-collapse.R", compoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         decorate_function.Rd = "R/language.R", deparse_svec.Rd = "R/strings.R", 
#&gt;         dev_create.Rd = "R/graphics.R", do_aggregate.Rd = "R/apply.R", 
#&gt;         drop_nulls.Rd = "R/utils.R", eval_dirty.Rd = "R/language.R", 
#&gt;         fastmap2.Rd = "R/fastmap2.R", forelse.Rd = "R/apply.R", 
#&gt;         getInputBinding.Rd = "R/shiny-inputbindings.R", get_cpu.Rd = "R/systems.R", 
#&gt;         get_dots.Rd = "R/language.R", get_ram.Rd = "R/systems.R", 
#&gt;         `grapes-equals-greater-than-grapes.Rd` = "R/language.R", 
#&gt;         `grapes-help-set-grapes.Rd` = "R/language.R", `grapes-plus-grapes.Rd` = "R/language.R", 
#&gt;         handler_dipsaus_progress.Rd = "R/shiny-progress.R", iapply.Rd = "R/apply.R", 
#&gt;         lapply_async2.Rd = "R/parallels-future.R", lock.Rd = "R/lock.R", 
#&gt;         make_async_evaluator.Rd = "R/parallels-workers.R", make_forked_clusters.Rd = "R/parallels.R", 
#&gt;         map.Rd = "R/map-s3.R", match_calls.Rd = "R/language.R", 
#&gt;         mem_limit2.Rd = "R/strings.R", no_op.Rd = "R/language.R", 
#&gt;         package_installed.Rd = "R/utils-package.R", parse_svec.Rd = "R/strings.R", 
#&gt;         prepare_install.Rd = "R/utils-package.R", progress2.Rd = "R/shiny-progress.R", 
#&gt;         registerInputBinding.Rd = "R/shiny-inputbindings.R", 
#&gt;         screenshot.Rd = "R/screenshot.R", set_shiny_input.Rd = "R/shiny-setInputs.R", 
#&gt;         shift_array.Rd = "R/cpp-collapse.R", sync_shiny_inputs.Rd = "R/shiny-syncInputs.R", 
#&gt;         time_delta.Rd = "R/utils.R", to_datauri.Rd = "R/strings.R", 
#&gt;         to_ram_size.Rd = "R/strings.R", updateActionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         updateCompoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         update_fastmap2.Rd = "R/fastmap2.R", use_shiny_dipsaus.Rd = "R/shiny-setInputs.R"), 
#&gt;         keywords = list(character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0)), concepts = list(
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0)), internal = c(FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE)), tutorials = list(name = character(0), file_out = character(0), 
#&gt;         title = character(0), pagetitle = character(0), url = character(0)), 
#&gt;     vignettes = list(name = c("async_evaluator", "r_expr_addons", 
#&gt;     "shiny_customized_widgets", "utility_functions"), file_in = c("vignettes/async_evaluator.Rmd", 
#&gt;     "vignettes/r_expr_addons.Rmd", "vignettes/shiny_customized_widgets.Rmd", 
#&gt;     "vignettes/utility_functions.Rmd"), file_out = c("articles/async_evaluator.html", 
#&gt;     "articles/r_expr_addons.html", "articles/shiny_customized_widgets.html", 
#&gt;     "articles/utility_functions.html"), title = c("Asynchronous Evaluator", 
#&gt;     "R Expression Add-ons", "Shiny Customized Widgets", "Utility Functions"
#&gt;     ), description = c(NA_character_, NA_character_, NA_character_, 
#&gt;     NA_character_)), topic_index = c(`[.fastmap2` = "fastmap2", 
#&gt;     `[[.fastmap2` = "fastmap2", `[[&lt;-.fastmap2` = "fastmap2", 
#&gt;     `[&lt;-.fastmap2` = "fastmap2", `%?&lt;-%` = "grapes-help-set-grapes", 
#&gt;     `%+-%` = "grapes-plus-grapes", `%=&gt;%` = "grapes-equals-greater-than-grapes", 
#&gt;     `%D%` = "decorate_function", `$.fastmap2` = "fastmap2", `$&lt;-.fastmap2` = "fastmap2", 
#&gt;     AbstractMap = "AbstractMap", AbstractQueue = "AbstractQueue", 
#&gt;     actionButtonStyled = "actionButtonStyled", as.list.fastmap2 = "fastmap2", 
#&gt;     ask_or_default = "ask_or_default", ask_yesno = "ask_yesno", 
#&gt;     async = "async", async_expr = "async_expr", async_flapply = "async_flapply", 
#&gt;     base64_to_image = "base64_to_image", baseline_array = "baseline_array", 
#&gt;     cat2 = "cat2", check_installed_packages = "check_installed_packages", 
#&gt;     col2hexStr = "col2hexStr", collapse = "collapse", compoundInput2 = "compoundInput2", 
#&gt;     decorate_function = "decorate_function", deparse_svec = "deparse_svec", 
#&gt;     dev_create = "dev_create", dipsaus_lock = "lock", dipsaus_unlock = "lock", 
#&gt;     do_aggregate = "do_aggregate", drop_nulls = "drop_nulls", 
#&gt;     eval_dirty = "eval_dirty", fastmap2 = "fastmap2", forelse = "forelse", 
#&gt;     get_cpu = "get_cpu", get_dots = "get_dots", get_ram = "get_ram", 
#&gt;     getInputBinding = "getInputBinding", handler_dipsaus_progress = "handler_dipsaus_progress", 
#&gt;     iapply = "iapply", lapply_async2 = "lapply_async2", length.fastmap2 = "fastmap2", 
#&gt;     lock = "lock", make_async_evaluator = "make_async_evaluator", 
#&gt;     make_forked_clusters = "make_forked_clusters", map = "map", 
#&gt;     MasterEvaluator = "MasterEvaluator", match_calls = "match_calls", 
#&gt;     mem_limit2 = "mem_limit2", names.fastmap2 = "fastmap2", no_op = "no_op", 
#&gt;     package_installed = "package_installed", parse_svec = "parse_svec", 
#&gt;     PersistContainer = "PersistContainer", prepare_install = "prepare_install", 
#&gt;     print.fastmap2 = "fastmap2", progress2 = "progress2", qs_map = "map", 
#&gt;     rds_map = "map", redis_map = "map", registerInputBinding = "registerInputBinding", 
#&gt;     screenshot = "screenshot", session_map = "map", set_shiny_input = "set_shiny_input", 
#&gt;     shift_array = "shift_array", sync_shiny_inputs = "sync_shiny_inputs", 
#&gt;     text_map = "map", time_delta = "time_delta", to_datauri = "to_datauri", 
#&gt;     to_ram_size = "to_ram_size", update_fastmap2 = "update_fastmap2", 
#&gt;     updateActionButtonStyled = "updateActionButtonStyled", updateCompoundInput2 = "updateCompoundInput2", 
#&gt;     use_shiny_dipsaus = "use_shiny_dipsaus"), article_index = c(async_evaluator = "async_evaluator.html", 
#&gt;     r_expr_addons = "r_expr_addons.html", shiny_customized_widgets = "shiny_customized_widgets.html", 
#&gt;     utility_functions = "utility_functions.html")), examples = TRUE, 
#&gt;     run_dont_run = FALSE, seed = 1014, lazy = FALSE, override = list(), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE), 
#&gt;     envir = &lt;environment&gt;)
#&gt; 
#&gt; [[12]]
#&gt; (function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; })(pkg = list(package = "dipsaus", version = "0.0.6", src_path = "/Users/beauchamplab/Dropbox/projects/dipsaus", 
#&gt;     dst_path = "/Users/beauchamplab/Dropbox/projects/dipsaus/docs", 
#&gt;     desc = &lt;environment&gt;, meta = list(), figures = list(dev = "grDevices::png", 
#&gt;         dpi = 96L, dev.args = list(), fig.ext = "png", fig.width = 7.29166666666667, 
#&gt;         fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839), 
#&gt;     repo = list(url = list(home = "https://github.com/dipterix/dipsaus/", 
#&gt;         source = "https://github.com/dipterix/dipsaus/blob/master/", 
#&gt;         issue = "https://github.com/dipterix/dipsaus/issues/", 
#&gt;         user = "https://github.com/")), development = list(destination = "dev", 
#&gt;         mode = "release", version_label = "default", version_tooltip = "Released version", 
#&gt;         in_dev = FALSE), topics = list(name = c(AbstractMap.Rd = "AbstractMap", 
#&gt;     AbstractQueue.Rd = "AbstractQueue", MasterEvaluator.Rd = "MasterEvaluator", 
#&gt;     PersistContainer.Rd = "PersistContainer", actionButtonStyled.Rd = "actionButtonStyled", 
#&gt;     ask_or_default.Rd = "ask_or_default", ask_yesno.Rd = "ask_yesno", 
#&gt;     async.Rd = "async", async_expr.Rd = "async_expr", async_flapply.Rd = "async_flapply", 
#&gt;     base64_to_image.Rd = "base64_to_image", baseline_array.Rd = "baseline_array", 
#&gt;     cat2.Rd = "cat2", check_installed_packages.Rd = "check_installed_packages", 
#&gt;     col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", compoundInput2.Rd = "compoundInput2", 
#&gt;     decorate_function.Rd = "decorate_function", deparse_svec.Rd = "deparse_svec", 
#&gt;     dev_create.Rd = "dev_create", do_aggregate.Rd = "do_aggregate", 
#&gt;     drop_nulls.Rd = "drop_nulls", eval_dirty.Rd = "eval_dirty", 
#&gt;     fastmap2.Rd = "fastmap2", forelse.Rd = "forelse", getInputBinding.Rd = "getInputBinding", 
#&gt;     get_cpu.Rd = "get_cpu", get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", 
#&gt;     `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", `grapes-help-set-grapes.Rd` = "%?&lt;-%", 
#&gt;     `grapes-plus-grapes.Rd` = "%+-%", handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;     iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;     lock.Rd = "lock", make_async_evaluator.Rd = "make_async_evaluator", 
#&gt;     make_forked_clusters.Rd = "make_forked_clusters", map.Rd = "map", 
#&gt;     match_calls.Rd = "match_calls", mem_limit2.Rd = "mem_limit2", 
#&gt;     no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;     parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;     progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;     screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;     shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;     time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;     to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;     updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;     use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), file_in = c("AbstractMap.Rd", 
#&gt;     "AbstractQueue.Rd", "MasterEvaluator.Rd", "PersistContainer.Rd", 
#&gt;     "actionButtonStyled.Rd", "ask_or_default.Rd", "ask_yesno.Rd", 
#&gt;     "async.Rd", "async_expr.Rd", "async_flapply.Rd", "base64_to_image.Rd", 
#&gt;     "baseline_array.Rd", "cat2.Rd", "check_installed_packages.Rd", 
#&gt;     "col2hexStr.Rd", "collapse.Rd", "compoundInput2.Rd", "decorate_function.Rd", 
#&gt;     "deparse_svec.Rd", "dev_create.Rd", "do_aggregate.Rd", "drop_nulls.Rd", 
#&gt;     "eval_dirty.Rd", "fastmap2.Rd", "forelse.Rd", "getInputBinding.Rd", 
#&gt;     "get_cpu.Rd", "get_dots.Rd", "get_ram.Rd", "grapes-equals-greater-than-grapes.Rd", 
#&gt;     "grapes-help-set-grapes.Rd", "grapes-plus-grapes.Rd", "handler_dipsaus_progress.Rd", 
#&gt;     "iapply.Rd", "lapply_async2.Rd", "lock.Rd", "make_async_evaluator.Rd", 
#&gt;     "make_forked_clusters.Rd", "map.Rd", "match_calls.Rd", "mem_limit2.Rd", 
#&gt;     "no_op.Rd", "package_installed.Rd", "parse_svec.Rd", "prepare_install.Rd", 
#&gt;     "progress2.Rd", "registerInputBinding.Rd", "screenshot.Rd", 
#&gt;     "set_shiny_input.Rd", "shift_array.Rd", "sync_shiny_inputs.Rd", 
#&gt;     "time_delta.Rd", "to_datauri.Rd", "to_ram_size.Rd", "updateActionButtonStyled.Rd", 
#&gt;     "updateCompoundInput2.Rd", "update_fastmap2.Rd", "use_shiny_dipsaus.Rd"
#&gt;     ), file_out = c("AbstractMap.html", "AbstractQueue.html", 
#&gt;     "MasterEvaluator.html", "PersistContainer.html", "actionButtonStyled.html", 
#&gt;     "ask_or_default.html", "ask_yesno.html", "async.html", "async_expr.html", 
#&gt;     "async_flapply.html", "base64_to_image.html", "baseline_array.html", 
#&gt;     "cat2.html", "check_installed_packages.html", "col2hexStr.html", 
#&gt;     "collapse.html", "compoundInput2.html", "decorate_function.html", 
#&gt;     "deparse_svec.html", "dev_create.html", "do_aggregate.html", 
#&gt;     "drop_nulls.html", "eval_dirty.html", "fastmap2.html", "forelse.html", 
#&gt;     "getInputBinding.html", "get_cpu.html", "get_dots.html", 
#&gt;     "get_ram.html", "grapes-equals-greater-than-grapes.html", 
#&gt;     "grapes-help-set-grapes.html", "grapes-plus-grapes.html", 
#&gt;     "handler_dipsaus_progress.html", "iapply.html", "lapply_async2.html", 
#&gt;     "lock.html", "make_async_evaluator.html", "make_forked_clusters.html", 
#&gt;     "map.html", "match_calls.html", "mem_limit2.html", "no_op.html", 
#&gt;     "package_installed.html", "parse_svec.html", "prepare_install.html", 
#&gt;     "progress2.html", "registerInputBinding.html", "screenshot.html", 
#&gt;     "set_shiny_input.html", "shift_array.html", "sync_shiny_inputs.html", 
#&gt;     "time_delta.html", "to_datauri.html", "to_ram_size.html", 
#&gt;     "updateActionButtonStyled.html", "updateCompoundInput2.html", 
#&gt;     "update_fastmap2.html", "use_shiny_dipsaus.html"), alias = list(
#&gt;         AbstractMap.Rd = "AbstractMap", AbstractQueue.Rd = "AbstractQueue", 
#&gt;         MasterEvaluator.Rd = "MasterEvaluator", PersistContainer.Rd = "PersistContainer", 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled", ask_or_default.Rd = "ask_or_default", 
#&gt;         ask_yesno.Rd = "ask_yesno", async.Rd = "async", async_expr.Rd = "async_expr", 
#&gt;         async_flapply.Rd = "async_flapply", base64_to_image.Rd = "base64_to_image", 
#&gt;         baseline_array.Rd = "baseline_array", cat2.Rd = "cat2", 
#&gt;         check_installed_packages.Rd = "check_installed_packages", 
#&gt;         col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", 
#&gt;         compoundInput2.Rd = "compoundInput2", decorate_function.Rd = c("decorate_function", 
#&gt;         "%D%"), deparse_svec.Rd = "deparse_svec", dev_create.Rd = "dev_create", 
#&gt;         do_aggregate.Rd = "do_aggregate", drop_nulls.Rd = "drop_nulls", 
#&gt;         eval_dirty.Rd = "eval_dirty", fastmap2.Rd = c("fastmap2", 
#&gt;         "[[.fastmap2", "$.fastmap2", "[[&lt;-.fastmap2", "$&lt;-.fastmap2", 
#&gt;         "[.fastmap2", "[&lt;-.fastmap2", "names.fastmap2", "print.fastmap2", 
#&gt;         "length.fastmap2", "as.list.fastmap2"), forelse.Rd = "forelse", 
#&gt;         getInputBinding.Rd = "getInputBinding", get_cpu.Rd = "get_cpu", 
#&gt;         get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", 
#&gt;         `grapes-help-set-grapes.Rd` = "%?&lt;-%", `grapes-plus-grapes.Rd` = "%+-%", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;         iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;         lock.Rd = c("lock", "dipsaus_lock", "dipsaus_unlock"), 
#&gt;         make_async_evaluator.Rd = "make_async_evaluator", make_forked_clusters.Rd = "make_forked_clusters", 
#&gt;         map.Rd = c("map", "session_map", "rds_map", "text_map", 
#&gt;         "qs_map", "redis_map"), match_calls.Rd = "match_calls", 
#&gt;         mem_limit2.Rd = "mem_limit2", no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;         parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;         progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;         screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;         shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;         time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;         to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), funs = list(
#&gt;         AbstractMap.Rd = character(0), AbstractQueue.Rd = character(0), 
#&gt;         MasterEvaluator.Rd = character(0), PersistContainer.Rd = character(0), 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled()", ask_or_default.Rd = "ask_or_default()", 
#&gt;         ask_yesno.Rd = "ask_yesno()", async.Rd = "async()", async_expr.Rd = "async_expr()", 
#&gt;         async_flapply.Rd = "async_flapply()", base64_to_image.Rd = "base64_to_image()", 
#&gt;         baseline_array.Rd = "baseline_array()", cat2.Rd = "cat2()", 
#&gt;         check_installed_packages.Rd = "check_installed_packages()", 
#&gt;         col2hexStr.Rd = "col2hexStr()", collapse.Rd = "collapse()", 
#&gt;         compoundInput2.Rd = "compoundInput2()", decorate_function.Rd = c("decorate_function()", 
#&gt;         "`%D%`"), deparse_svec.Rd = "deparse_svec()", dev_create.Rd = "dev_create()", 
#&gt;         do_aggregate.Rd = "do_aggregate()", drop_nulls.Rd = "drop_nulls()", 
#&gt;         eval_dirty.Rd = "eval_dirty()", fastmap2.Rd = c("fastmap2()", 
#&gt;         "`[[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "names(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "print(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "length(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "as.list(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)"
#&gt;         ), forelse.Rd = "forelse()", getInputBinding.Rd = "getInputBinding()", 
#&gt;         get_cpu.Rd = "get_cpu()", get_dots.Rd = "get_dots()", 
#&gt;         get_ram.Rd = "get_ram()", `grapes-equals-greater-than-grapes.Rd` = "`%=&amp;gt;%`", 
#&gt;         `grapes-help-set-grapes.Rd` = "`%?&amp;lt;-%`", `grapes-plus-grapes.Rd` = "`%+-%`", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress()", 
#&gt;         iapply.Rd = "iapply()", lapply_async2.Rd = "lapply_async2()", 
#&gt;         lock.Rd = c("dipsaus_lock()", "dipsaus_unlock()"), make_async_evaluator.Rd = "make_async_evaluator()", 
#&gt;         make_forked_clusters.Rd = "make_forked_clusters()", map.Rd = c("session_map()", 
#&gt;         "rds_map()", "text_map()", "qs_map()", "redis_map()"), 
#&gt;         match_calls.Rd = "match_calls()", mem_limit2.Rd = "mem_limit2()", 
#&gt;         no_op.Rd = "no_op()", package_installed.Rd = "package_installed()", 
#&gt;         parse_svec.Rd = "parse_svec()", prepare_install.Rd = "prepare_install()", 
#&gt;         progress2.Rd = "progress2()", registerInputBinding.Rd = "registerInputBinding()", 
#&gt;         screenshot.Rd = "screenshot()", set_shiny_input.Rd = "set_shiny_input()", 
#&gt;         shift_array.Rd = "shift_array()", sync_shiny_inputs.Rd = "sync_shiny_inputs()", 
#&gt;         time_delta.Rd = "time_delta()", to_datauri.Rd = "to_datauri()", 
#&gt;         to_ram_size.Rd = "to_ram_size()", updateActionButtonStyled.Rd = "updateActionButtonStyled()", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2()", update_fastmap2.Rd = "update_fastmap2()", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus()"), title = c(AbstractMap.Rd = "Abstract Map to store key-value pairs", 
#&gt;     AbstractQueue.Rd = "Defines abstract queue class", MasterEvaluator.Rd = "Generator Class for Asynchronous Evaluation", 
#&gt;     PersistContainer.Rd = "Wrapper to cache key-value pairs and persist across sessions", 
#&gt;     actionButtonStyled.Rd = "Action Button but with customized styles", 
#&gt;     ask_or_default.Rd = "Read a Line from the Terminal, but with Default Values", 
#&gt;     ask_yesno.Rd = "Ask and Return True or False from the Terminal", 
#&gt;     async.Rd = "Evaluate expression in &lt;code&gt;async_expr&lt;/code&gt;", 
#&gt;     async_expr.Rd = "Apply R expressions in a parallel way", 
#&gt;     async_flapply.Rd = "Wrapper for &lt;code&gt;future.apply::future_lapply&lt;/code&gt;", 
#&gt;     base64_to_image.Rd = "Save \"Base64\" Data to Images", baseline_array.Rd = "Calculate Contrasts of Arrays in Different Methods", 
#&gt;     cat2.Rd = "Color Output", check_installed_packages.Rd = "Check If Packages Are Installed, Returns Missing Packages", 
#&gt;     col2hexStr.Rd = "Convert color to Hex string", collapse.Rd = "Collapse Sensors And Calculate Summations/Mean\n\n(stable)", 
#&gt;     compoundInput2.Rd = "Compound input that combines and extends shiny inputs", 
#&gt;     decorate_function.Rd = "Python-style decorator", deparse_svec.Rd = "Convert Integer Vectors To String\n\n(stable)", 
#&gt;     dev_create.Rd = "Create a group of named graphic devices", 
#&gt;     do_aggregate.Rd = "Make aggregate pipe-friendly", drop_nulls.Rd = "Drop &lt;code&gt;NULL&lt;/code&gt; values from list or vectors", 
#&gt;     eval_dirty.Rd = "Evaluate expressions", fastmap2.Rd = "A Wrapper for &lt;code&gt;fastmap::fastmap&lt;/code&gt;", 
#&gt;     forelse.Rd = "Python-style &lt;code&gt;\"for-else\"&lt;/code&gt; function", 
#&gt;     getInputBinding.Rd = "Obtain registered input bindings", 
#&gt;     get_cpu.Rd = "Get CPU Chip-set Information", get_dots.Rd = "Get element from dots &lt;code&gt;'...'&lt;/code&gt;", 
#&gt;     get_ram.Rd = "Get Memory Size", `grapes-equals-greater-than-grapes.Rd` = "A JavaScript style of creating functions", 
#&gt;     `grapes-help-set-grapes.Rd` = "Assign if not exists, or NULL\nProvides a way to assign default values to variables. If the statement\n`&lt;code&gt;lhs&lt;/code&gt;` is invalid or &lt;code&gt;NULL&lt;/code&gt;, this function will try to assign\n&lt;code&gt;value&lt;/code&gt;, otherwise nothing happens.", 
#&gt;     `grapes-plus-grapes.Rd` = "Plus-minus operator", handler_dipsaus_progress.Rd = "Progress-bar Handler", 
#&gt;     iapply.Rd = "Apply each elements with index as second input", 
#&gt;     lapply_async2.Rd = "Apply, but in parallel", lock.Rd = "Create or Unlock a Lock", 
#&gt;     make_async_evaluator.Rd = "Create Asynchronous Evaluator to Queue Tasks", 
#&gt;     make_forked_clusters.Rd = "Create forked clusters", map.Rd = "Create R object map.", 
#&gt;     match_calls.Rd = "Recursively match calls and modify arguments", 
#&gt;     mem_limit2.Rd = "Get max RAM size\nThis is an experimental function that is designed for non-windows systems", 
#&gt;     no_op.Rd = "Pipe-friendly no-operation function", package_installed.Rd = "Check if a package is installed", 
#&gt;     parse_svec.Rd = "Parse Text Into Numeric Vectors\n\n(stable)", 
#&gt;     prepare_install.Rd = "Install Packages at Next Startup", 
#&gt;     progress2.Rd = "'Shiny' progress bar, but can run without reactive context", 
#&gt;     registerInputBinding.Rd = "Register customized input to enable support by compound input", 
#&gt;     screenshot.Rd = "Take a screenshot in shiny apps", set_shiny_input.Rd = "Set Shiny Input", 
#&gt;     shift_array.Rd = "Shift Array by Index", sync_shiny_inputs.Rd = "Synchronize Shiny Inputs", 
#&gt;     time_delta.Rd = "Calculate time difference and return a number", 
#&gt;     to_datauri.Rd = "Convert file to 'base64' format", to_ram_size.Rd = "Convert bytes to KB, MB, GB,...", 
#&gt;     updateActionButtonStyled.Rd = "Update styled action button", 
#&gt;     updateCompoundInput2.Rd = "Update compound inputs", update_fastmap2.Rd = "Migrate a &lt;code&gt;fastmap2&lt;/code&gt; object to a new one", 
#&gt;     use_shiny_dipsaus.Rd = "Set up shiny plugins"), rd = list(
#&gt;         AbstractMap.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-abstract.R", 
#&gt;             "\n", list("AbstractMap"), "\n", list("AbstractMap"), 
#&gt;             "\n", list("Abstract Map to store key-value pairs"), 
#&gt;             "\n", list("\n", "Abstract Map to store key-value pairs\n"), 
#&gt;             "\n"), AbstractQueue.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/queue-abstract.R", 
#&gt;             "\n", list("AbstractQueue"), "\n", list("AbstractQueue"), 
#&gt;             "\n", list("Defines abstract queue class"), "\n", 
#&gt;             list("\n", "This class is inspired by ", list("https://cran.r-project.org/package=txtq"), 
#&gt;                 ".\n", "The difference is ", list("AbstractQueue"), 
#&gt;                 " introduce an abstract class that can\n", "be extended and can queue not only text messages, but also arbitrary R\n", 
#&gt;                 "objects, including expressions and environments. All the queue types in this\n", 
#&gt;                 "package inherit this class.\n"), "\n", list(
#&gt;                 list("Abstract Public Methods"), list("\n", "\n", 
#&gt;                   "\n", "Methods start with ", list("@..."), 
#&gt;                   " are not thread-safe. Most of them are not\n", 
#&gt;                   "used directly by users. However, you might want to override them if you\n", 
#&gt;                   "inherit this abstract class. Methods marked as \"(override)\" are not\n", 
#&gt;                   "implemented, meaning you are supposed to implement the details. Methods\n", 
#&gt;                   "marked as \"(optional)\" usually have default alternatives.\n", 
#&gt;                   "\n", list("\n", list(list(list("initialize(...)"), 
#&gt;                     " (override)"), list("\n", "The constructor. Usually three things to do during the process:\n", 
#&gt;                     "1. set ", list("get_locker"), " ", list(
#&gt;                       "free_locker"), " if you don't want to use the\n", 
#&gt;                     "default lockers. 2. set lock file (if using default lockers). 3. call\n", 
#&gt;                     list("self$connect(...)"), "\n")), "\n", 
#&gt;                     list(list(list("get_locker()"), ", ", list(
#&gt;                       "free_locker()"), " (optional)"), list(
#&gt;                       "\n", "Default is ", list("NULL"), " for each methods, and queue uses an internal\n", 
#&gt;                       list("private$default_get_locker"), " and ", 
#&gt;                       list("private$default_free_locker"), ".\n", 
#&gt;                       "These two methods are for customized locker, please\n", 
#&gt;                       "implement these two methods as functions during ", 
#&gt;                       list("self$initialization"), "\n", list(
#&gt;                         "get_locker"), " obtains and lock access (exclusive), and ", 
#&gt;                       list("free_locker"), "\n", "frees the locker. Once implemented, ", 
#&gt;                       list("private$exclusive"), " will take care\n", 
#&gt;                       "the rest. Type: function; parameters: none; return: none\n")), 
#&gt;                     "\n", list(list(list("@get_head()"), ", ", 
#&gt;                       list("@set_head(v)"), " (override)"), list(
#&gt;                       "\n", "Get head so that we know where we are in the queue ", 
#&gt;                       list("self$@get_head()"), "\n", "should return a integer indicating where we are at the queue\n", 
#&gt;                       list("self$@set_head(v)"), " stores that integer. Parameter ", 
#&gt;                       list("v"), " is always\n", "non-negative, this is guaranteed. Users are not supposed to call these\n", 
#&gt;                       "methods directly, use ", list("self$head"), 
#&gt;                       " and ", list("self$head&lt;-"), " instead.\n", 
#&gt;                       "However, if you inherit this class, you are supposed to override the methods.\n")), 
#&gt;                     "\n", list(list(list("@get_total()"), ", ", 
#&gt;                       list("@set_total(v)"), " (override)"), 
#&gt;                       list("\n", "Similar to ", list("@get_head"), 
#&gt;                         " and ", list("@set_head"), ", defines the total items\n", 
#&gt;                         "ever stored in the queue. total-head equals current items in the queue.\n")), 
#&gt;                     "\n", list(list(list("@inc_total(n=1)"), 
#&gt;                       " (optional)"), list("\n", "Increase total, usually this doesn't need to be override, unless you are\n", 
#&gt;                       "using files to store total and want to decrease number of file connections\n")), 
#&gt;                     "\n", list(list(list("@append_header(msg, ...)"), 
#&gt;                       " (override)"), list("\n", list("msg"), 
#&gt;                       " will be vector of strings, separated by \"|\", containing encoded\n", 
#&gt;                       "headers: `time`, `key`, `hash`, and `message`. to decode what's inside, you\n", 
#&gt;                       "can use ", list("self$print_items(stringr::str_split_fixed(msg, '\\|', 4))"), 
#&gt;                       ".\n", list("Make sure"), " to return a number, indicating number of items stored.\n", 
#&gt;                       "Unless handled elsewhere, usually ", list(
#&gt;                         "return(length(msg))"), ".\n")), "\n", 
#&gt;                     list(list(list("@store_value(value, key)"), 
#&gt;                       " (override)"), list("\n", "Defines how to store value. `key` is unique identifier generated from\n", 
#&gt;                       "time, queue ID, and value. Usually I use it as file name or key ID in\n", 
#&gt;                       "database. value is an arbitrary R object to store. you need to store value\n", 
#&gt;                       "somewhere and return a string that will be passed as `hash` in\n", 
#&gt;                       list("self$restore_value"), ".\n")), "\n", 
#&gt;                     list(list(list("restore_value(hash, key, preserve = FALSE)"), 
#&gt;                       " (override)"), list("\n", "Method to restore value from given combination of `hash` and `key`.\n", 
#&gt;                       "`hash` is the string returned by ", list(
#&gt;                         "@store_value"), ", and `key` is the same\n", 
#&gt;                       "as key in ", list("@store_value"), ". preserve is a indicator of whether to\n", 
#&gt;                       "preserve the value for future use. If set to ", 
#&gt;                       list("FALSE"), ", then you are\n", "supposed to free up the resource related to the value. (such as free memory\n", 
#&gt;                       "or disk space)\n")), "\n", list(list(list(
#&gt;                       "@log(n = -1, all = FALSE) (override)")), 
#&gt;                       list("\n", "get ", list("n"), " items from what you saved to during ", 
#&gt;                         list("@append_header"), ".\n", list("n"), 
#&gt;                         " less equal than 0 means listing all possible items.\n", 
#&gt;                         "If ", list("all=TRUE"), ", return all items (number of rows should equals to\n", 
#&gt;                         list("self$total"), "), including popped items. If ", 
#&gt;                         list("all=FALSE"), ", only\n", "return items in the queue (number of rows is ", 
#&gt;                         list("self$count"), "). The\n", "returned value should be a ", 
#&gt;                         list("n x 4"), " matrix. Usually I use\n", 
#&gt;                         list("stringr::str_split_fixed(..., '\\|', 4)"), 
#&gt;                         ". Please see all other\n", "types implemented for example.\n")), 
#&gt;                     "\n", list(list(list("@reset(...)"), " (override)"), 
#&gt;                       list("\n", "Reset queue, remove all items and reset head, total to be 0.\n")), 
#&gt;                     "\n", list(list(list("@clean()"), " (override)"), 
#&gt;                       list("\n", "Clean the queue, remove all the popped items.\n")), 
#&gt;                     "\n", list(list(list("@validate()"), " (override)"), 
#&gt;                       list("\n", "Validate the queue. Stop if the queue is broken.\n")), 
#&gt;                     "\n", list(list(list("@connect(con, ...)"), 
#&gt;                       " (override)"), list("\n", "Set up connection. Usually should be called at the end of\n", 
#&gt;                       list("self$initialization"), " to connect to a database, a folder, or an\n", 
#&gt;                       "existing queue you should do checks whether the connection is new or it's\n", 
#&gt;                       "an existing queue.\n")), "\n", list(list(
#&gt;                       list("connect(con, ...)"), " (optional)"), 
#&gt;                       list("\n", "Thread-safe version. sometimes you need to override this function instead\n", 
#&gt;                         "of ", list("@connect"), ", because ", 
#&gt;                         list("private$exclusive"), " requires ", 
#&gt;                         list("lockfile"), "\n", "to exist and to be locked. If you don't have lockers ready, or need to set\n", 
#&gt;                         "lockers during the connection, override this one.\n")), 
#&gt;                     "\n", list(list(list("destroy()"), " (optional)"), 
#&gt;                       list("\n", "Destroy a queue, free up space and call\n", 
#&gt;                         list("delayedAssign('.lockfile', {stop(...)}, assign.env=private)"), 
#&gt;                         " to raise\n", "error if a destroyed queue is called again later.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Methods"), 
#&gt;                 list("\n", "\n", "\n", "Usually don't need to override unless you know what you are doing.\n", 
#&gt;                   "\n", list("\n", list(list(list("push(value, message='',...)")), 
#&gt;                     list("\n", "Function to push an arbitrary R object to queue. ", 
#&gt;                       list("message"), " is a string\n", "giving notes to the pushed item. Usually message is stored with header,\n", 
#&gt;                       "separated from values. The goal is to describe the value. ", 
#&gt;                       list("..."), " is\n", "passed to ", list(
#&gt;                         "@append_header"), "\n")), "\n", list(
#&gt;                     list(list("pop(n = 1, preserve = FALSE)")), 
#&gt;                     list("\n", "Pop ", list("n"), " items from the queue. ", 
#&gt;                       list("preserve"), " indicates whether not to\n", 
#&gt;                       "free up the resources, though not always guaranteed.\n")), 
#&gt;                     "\n", list(list(list("print_item(item)"), 
#&gt;                       ", ", list("print_items(items)")), list(
#&gt;                       "\n", "To decode matrix returned by ", 
#&gt;                       list("log()"), ", returning named list or data frame\n", 
#&gt;                       "with four heads: `time`, `key`, `hash`, and `message`.\n")), 
#&gt;                     "\n", list(list(list("list(n=-1)")), list(
#&gt;                       "\n", "List items in the queue, decoded. If ", 
#&gt;                       list("n"), " is less equal than 0, then\n", 
#&gt;                       "list all results. The result is equivalent to\n", 
#&gt;                       list("self$print_items(self$log(n))"), 
#&gt;                       "\n")), "\n", list(list(list("log(n=-1,all=FALSE)")), 
#&gt;                       list("\n", "List items in the queue, encoded. This is used with ", 
#&gt;                         list("self$print_items"), ".\n", "When ", 
#&gt;                         list("all=TRUE"), ", result will list the  records ever pushed to the queue\n", 
#&gt;                         "since the last time queue is cleaned. When ", 
#&gt;                         list("all=FALSE"), ", results will be\n", 
#&gt;                         "items in the queue. ", list("n"), " is the number of items.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Active Bindings"), 
#&gt;                 list("\n", "\n", "\n", list("\n", list(list(list(
#&gt;                   "id")), list("\n", "Read-only property. Returns unique ID of current queue.\n")), 
#&gt;                   "\n", list(list(list("lockfile")), list("\n", 
#&gt;                     "The lock file.\n")), "\n", list(list(list(
#&gt;                     "head")), list("\n", "Integer, total number of items popped, i.e. inactive items.\n")), 
#&gt;                   "\n", list(list(list("total")), list("\n", 
#&gt;                     "Total number of items ever pushed to the queue since last cleaned, integer.\n")), 
#&gt;                   "\n", list(list(list("count")), list("\n", 
#&gt;                     "Integer, read-only, equals to total - head, number of active items in the\n", 
#&gt;                     "queue\n")), "\n"), "\n")), "\n", "\n", list(
#&gt;                 list("Private Methods or properties"), list("\n", 
#&gt;                   "\n", "\n", list("\n", list(list(list(".id")), 
#&gt;                     list("\n", "Don't use directly. Used to store queue ID.\n")), 
#&gt;                     "\n", list(list(list(".lockfile")), list(
#&gt;                       "\n", "Location of lock file.\n")), "\n", 
#&gt;                     list(list(list("lock")), list("\n", "Preserve the file lock.\n")), 
#&gt;                     "\n", list(list(list("exclusive(expr,...)")), 
#&gt;                       list("\n", "Function to make sure the methods are thread-safe\n")), 
#&gt;                     "\n", list(list(list("default_get_locker()")), 
#&gt;                       list("\n", "Default method to lock a queue\n")), 
#&gt;                     "\n", list(list(list("default_free_locker")), 
#&gt;                       list("\n", "Default method to free a queue\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n"), MasterEvaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("MasterEvaluator"), "\n", list("MasterEvaluator"), 
#&gt;             "\n", list("Generator Class for Asynchronous Evaluation"), 
#&gt;             "\n", list("\n", "Generator Class for Asynchronous Evaluation\n"), 
#&gt;             "\n"), PersistContainer.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/persist.R", 
#&gt;             "\n", list("PersistContainer"), "\n", list("PersistContainer"), 
#&gt;             "\n", list("Wrapper to cache key-value pairs and persist across sessions"), 
#&gt;             "\n", list("\n", "This class is designed to persist arbitrary R objects locally\n", 
#&gt;                 "and share across different sessions. The container consists two-level caches.\n", 
#&gt;                 "The first one is session-based, meaning it's only valid under current R\n", 
#&gt;                 "session and will be cleared once the session is shut down. The second is\n", 
#&gt;                 "the persist-level map, which will persist to hard drive and shared across\n", 
#&gt;                 "sessions. See ", list("cache"), " method in 'details'.\n"), 
#&gt;             "\n", list(list("Public Methods"), list("\n", "\n", 
#&gt;                 "\n", list("\n", list(list(list("initialize(..., backend = text_map)")), 
#&gt;                   list("\n", "The constructor. backend must inherit ", 
#&gt;                     list("AbstractMap"), ", ", list("..."), " will\n", 
#&gt;                     "be passed to ", list("backend$new(...)"), 
#&gt;                     ". To check available back-ends and their\n", 
#&gt;                     "use cases, see ", list(list("map")), ".\n")), 
#&gt;                   "\n", list(list(list("reset(all = FALSE)")), 
#&gt;                     list("\n", "Reset container. If all is set to be true, then reset session-based and\n", 
#&gt;                       "hard-drive-based, otherwise only reset session-based container.\n")), 
#&gt;                   "\n", list(list(list("destroy(all = FALSE)")), 
#&gt;                     list("\n", "destroy the container. Only use it when you want to finalize the container in\n", 
#&gt;                       list(list("reg.finalizer")), ".\n")), "\n", 
#&gt;                   list(list(list("has(key, signature = NULL)")), 
#&gt;                     list("\n", "returns a list of true/false (logical) vectors indicating whether keys exist\n", 
#&gt;                       "in the container, if signature is used when caching the key-value pairs, then\n", 
#&gt;                       "it also checks whether signature matches. This is very important as even if\n", 
#&gt;                       "the keys match but signature is wrong, the results will be false.\n")), 
#&gt;                   "\n", list(list(list("remove(keys, all = TRUE)")), 
#&gt;                     list("\n", "Remove keys in the container. Default is to remove the keys in both levels.\n", 
#&gt;                       "If ", list("all=FALSE"), ", then only remove the key in current session\n")), 
#&gt;                   "\n", list(list(list("cache(key, value, signature = NULL, replace = FALSE, persist = FALSE)")), 
#&gt;                     list("\n", list("key"), " and ", list("signature"), 
#&gt;                       " together form the unique identifier for the\n", 
#&gt;                       "value. By default ", list("signature"), 
#&gt;                       " is none, but it's very useful when value\n", 
#&gt;                       "if large, or ", list("key"), " is not a string. ", 
#&gt;                       list("replace"), " indicates whether\n", 
#&gt;                       "to force replace the key-value pairs even if the entry exists. If\n", 
#&gt;                       list("persist"), " is true, then the value is stored in hard-disks, otherwise\n", 
#&gt;                       "the value will be deleted once the session is closed.\n")), 
#&gt;                   "\n"), "\n")), "\n", "\n", list("\n", "\n", 
#&gt;                 "container = PersistContainer$new(tempfile())\n", 
#&gt;                 "\n", "# Reset the container so that values are cleared\n", 
#&gt;                 "container$reset(all = TRUE)\n", "\n", "# Store `1` to 'a' with signature 111 to a non-persist map\n", 
#&gt;                 "# returns 1\n", "container$cache(key = 'a', value = 1, signature = 111, persist = FALSE)\n", 
#&gt;                 "\n", "# Replace 'a' with 3\n", "# returns 3\n", 
#&gt;                 "container$cache(key = 'a', value = 3, signature = 111,\n", 
#&gt;                 "                persist = TRUE, replace = TRUE)\n", 
#&gt;                 "\n", "# check if 'a' exists with signature 111\n", 
#&gt;                 "container$has('a', signature = 111)    # TRUE\n", 
#&gt;                 "# When you only have 'a' but no signature\n", 
#&gt;                 "container$has('a')                     # TRUE\n", 
#&gt;                 "# check if 'a' exists with wrong signature 222\n", 
#&gt;                 "container$has('a', signature = 222)    # FALSE\n", 
#&gt;                 "\n", "\n", "# Store 'a' with 2 with same signature\n", 
#&gt;                 "# will fail and ignore the value (value will not be evaluated if signatured)\n", 
#&gt;                 "# Return 2 (Important! use cached values)\n", 
#&gt;                 "container$cache(key = 'a', value = {\n", "  print(123)\n", 
#&gt;                 "  return(2)\n", "}, signature = 111, replace = FALSE)\n", 
#&gt;                 "\n", "# When no signature is present\n", "# If the key exists (no signature provided), return stored value\n", 
#&gt;                 "# returns 3\n", "container$cache(key = 'a', value = 4)\n", 
#&gt;                 "\n", "# replace is TRUE (no signature provided), signature will be some default value\n", 
#&gt;                 "container$cache(key = 'a', value = 2, replace = TRUE)\n", 
#&gt;                 "\n", "# destroy the container to free disk space\n", 
#&gt;                 "container$destroy()\n"), "\n", list("\n", list(
#&gt;                 list("map")), "\n"), "\n"), actionButtonStyled.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("actionButtonStyled"), "\n", list("actionButtonStyled"), 
#&gt;             "\n", list("Action Button but with customized styles"), 
#&gt;             "\n", list("\n", "actionButtonStyled(\n", "  inputId,\n", 
#&gt;                 "  label,\n", "  icon = NULL,\n", "  width = NULL,\n", 
#&gt;                 "  type = \"primary\",\n", "  btn_type = \"button\",\n", 
#&gt;                 "  class = \"\",\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("inputId, label, icon, width, ..."), 
#&gt;                 list("passed to ", list("shiny::actionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type, choices are `default`, `primary`, `info`, `success`,\n", 
#&gt;                   "`warning`, and `danger`")), "\n", "\n", list(
#&gt;                   list("btn_type"), list("HTML tag type, either ", 
#&gt;                     list("\"button\""), " or ", list("\"a\""))), 
#&gt;                 "\n", "\n", list(list("class"), list("additional classes to be added to the button")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Action Button but with customized styles\n"), 
#&gt;             "\n", list("\n", "\n", "# demo('example-actionButtonStyled', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButtonStyled('btn', label = 'Click me', type = 'default'),\n", 
#&gt;                 "  actionButtonStyled('btn2', label = 'Click me2', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  btn_types = c('default', 'primary', 'info', 'success', 'warning', 'danger')\n", 
#&gt;                 "  observeEvent(input$btn, {\n", "    btype = btn_types[((input$btn-1) %% (length(btn_types)-1)) + 1]\n", 
#&gt;                 "    updateActionButtonStyled(session, 'btn2', type = btype)\n", 
#&gt;                 "  })\n", "  observeEvent(input$btn2, {\n", "    updateActionButtonStyled(session, 'btn',\n", 
#&gt;                 "                             disabled = c(FALSE,TRUE)[(input$btn2 %% 2) + 1])\n", 
#&gt;                 "  })\n", "}\n", "\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser=TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateActionButtonStyled")), 
#&gt;                 " for how to update the button.\n"), "\n"), ask_or_default.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("ask_or_default"), "\n", list("ask_or_default"), 
#&gt;             "\n", list("Read a Line from the Terminal, but with Default Values"), 
#&gt;             "\n", list("\n", "ask_or_default(..., default = \"\", end = \"\", level = \"INFO\")\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("default"), list("default value to return in case of blank input")), 
#&gt;                 "\n"), "\n", list("\n", "A character from the user's input, or the default value. See details.\n"), 
#&gt;             "\n", list("\n", "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask a question, providing defaults. Users\n", 
#&gt;                 "need to enter the answer. If the answer is blank (no space), then returns the\n", 
#&gt;                 "default, otherwise returns the user input.\n", 
#&gt;                 "\n", "This can only be used in an ", list(list(
#&gt;                   "interactive")), " session.\n"), "\n", list(
#&gt;                 "\n", "if(interactive()){\n", "ask_or_default('What is the best programming language?',\n", 
#&gt;                 "               default = 'PHP')\n", "}\n"), 
#&gt;             "\n", list("\n", list(list("cat2")), ", ", list(list(
#&gt;                 "readline")), ",\n", list(list("ask_yesno")), 
#&gt;                 "\n"), "\n"), ask_yesno.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("ask_yesno"), "\n", list("ask_yesno"), 
#&gt;             "\n", list("Ask and Return True or False from the Terminal"), 
#&gt;             "\n", list("\n", "ask_yesno(..., end = \"\", level = \"INFO\", error_if_canceled = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("error_if_canceled"), list("raise error if canceled.")), 
#&gt;                 "\n"), "\n", list("\n", "logical or ", list("NULL"), 
#&gt;                 " or raise an error. If \"yes\" is entered,\n", 
#&gt;                 "returns ", list("TRUE"), "; if \"no\" is entered, returns ", 
#&gt;                 list("FALSE"), "; if \"c\" is\n", "entered, ", 
#&gt;                 list("error_if_canceled=TRUE"), " will result in an error, otherwise\n", 
#&gt;                 "return ", list("NULL"), "\n"), "\n", list("\n", 
#&gt;                 "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask for an yes or no question. Users need to\n", 
#&gt;                 "enter \"y\", \"yes\" for yes, \"n\", \"no\" or no, and \"c\" for cancel\n", 
#&gt;                 "(case-insensitive).\n", "\n", "This can only be used in an ", 
#&gt;                 list(list("interactive")), " session.\n"), "\n", 
#&gt;             list("\n", "if(interactive()){\n", "ask_yesno('Do you know how hard it is to submit an R package and ',\n", 
#&gt;                 "          'pass the CRAN checks?')\n", "ask_yesno('Can I pass the CRAN check this time?')\n", 
#&gt;                 "}\n"), "\n", list("\n", list(list("cat2")), 
#&gt;                 ", ", list(list("readline")), ",\n", list(list(
#&gt;                   "ask_or_default")), "\n"), "\n"), async.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async"), "\n", list("async"), "\n", list("Evaluate expression in ", 
#&gt;                 list("async_expr")), "\n", list("\n", "async(expr)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression")), 
#&gt;                 "\n"), "\n", list("\n", "Evaluate expression in ", 
#&gt;                 list("async_expr"), "\n"), "\n", list("\n", list(
#&gt;                 list("async_expr")), "\n"), "\n"), async_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_expr"), "\n", list("async_expr"), "\n", 
#&gt;             list("Apply R expressions in a parallel way"), "\n", 
#&gt;             list("\n", "async_expr(\n", "  .X,\n", "  .expr,\n", 
#&gt;                 "  .varname = \"x\",\n", "  envir = parent.frame(),\n", 
#&gt;                 "  .pre_run = NULL,\n", "  .ncore = future::availableCores(),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 ".X"), list("a vector or a list to apply evaluation on")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression, unquoted")), 
#&gt;                 "\n", "\n", list(list(".varname"), list("variable name representing element of each ", 
#&gt;                   list(".X"))), "\n", "\n", list(list("envir"), 
#&gt;                   list("environment to evaluate expressions")), 
#&gt;                 "\n", "\n", list(list(".pre_run"), list("expressions to be evaluated before looping.")), 
#&gt;                 "\n", "\n", list(list(".ncore"), list("number of CPU cores")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("future::future"))), "\n"), "\n", list(
#&gt;                 "\n", "a list whose length equals to ", list(
#&gt;                   ".X"), ". The value of each item\n", "returned depends on whether ", 
#&gt;                 list("async"), " is called. See details for workflow.\n"), 
#&gt;             "\n", list("\n", "Apply R expressions in a parallel way\n"), 
#&gt;             "\n", list("\n", list("async_expr"), " uses ", list(
#&gt;                 "lapply"), " and ", list("future::future"), " internally.\n", 
#&gt;                 "Within each loop, an item in ", list("\".X\""), 
#&gt;                 " will be assigned to variable ", list("\"x\""), 
#&gt;                 "\n", "(defined by ", list("\".varname\""), ") and enter the evaluation. During the evaluation,\n", 
#&gt;                 "function ", list("async"), " is provided. Expressions within ", 
#&gt;                 list("async"), " will be\n", "evaluated in another session, otherwise will be evaluated in current session.\n", 
#&gt;                 "Below is the workflow:\n", list("\n", "  ", 
#&gt;                   list(), " Run ", list(".pre_run"), "\n", "  ", 
#&gt;                   list(), " For ", list("i"), " in ", list("seq_along(.X)"), 
#&gt;                   ":\n", "  ", list("\n", "    ", list(), " 1. Assign ", 
#&gt;                     list("x"), " with ", list(".X[[i]]"), ", variable name ", 
#&gt;                     list("x"), " is\n", "    defined by ", list(
#&gt;                       ".varname"), "\n", "    ", list(), " 2. Evaluate ", 
#&gt;                     list("expr"), " in current session.\n", "    ", 
#&gt;                     list("\n", "      ", list(), " a. If ", list(
#&gt;                       "async"), " is not called, return evaluated ", 
#&gt;                       list("expr"), "\n", "      ", list(), " b. If ", 
#&gt;                       list("async(aync_expr)"), " is called, evaluate ", 
#&gt;                       list("aync_expr"), "\n", "      in another session, and return the evaluation results if ", 
#&gt;                       list("aync_expr"), "\n", "    "), "\n", 
#&gt;                     "  "), "\n"), "\n"), "\n"), async_flapply.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_flapply"), "\n", list("async_flapply"), 
#&gt;             "\n", list("Wrapper for ", list("future.apply::future_lapply")), 
#&gt;             "\n", list("\n", "async_flapply(X, FUN, ...)\n"), 
#&gt;             "\n", list("\n", list(list("X, FUN, ..."), list("passing to ", 
#&gt;                 list("future.apply::future_lapply"))), "\n"), 
#&gt;             "\n", list("\n", "Wrapper for ", list("future.apply::future_lapply"), 
#&gt;                 "\n"), "\n", list("\n", list(list("future_lapply")), 
#&gt;                 "\n"), "\n"), base64_to_image.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("base64_to_image"), "\n", list("base64_to_image"), 
#&gt;             "\n", list("Save \"Base64\" Data to Images"), "\n", 
#&gt;             list("\n", "base64_to_image(data, path)\n"), "\n", 
#&gt;             list("\n", list(list("data"), list("characters, encoded \"Base64\" data for images")), 
#&gt;                 "\n", "\n", list(list("path"), list("file path to save to")), 
#&gt;                 "\n"), "\n", list("\n", "Absolute path of the saved file\n"), 
#&gt;             "\n", list("\n", "Save \"Base64\" Data to Images\n"), 
#&gt;             "\n"), baseline_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-baseline_array.R", 
#&gt;             "\n", list("baseline_array"), "\n", list("baseline_array"), 
#&gt;             "\n", list("Calculate Contrasts of Arrays in Different Methods"), 
#&gt;             "\n", list("\n", "baseline_array(\n", "  x,\n", "  along_dim,\n", 
#&gt;                 "  baseline_indexpoints,\n", "  unit_dims = seq_along(dim(x))[-along_dim],\n", 
#&gt;                 "  method = c(\"percentage\", \"sqrt_percentage\", \"decibel\", \"zscore\", \"sqrt_zscore\")\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("x"), list(
#&gt;                 "array (tensor) to calculate contrast")), "\n", 
#&gt;                 "\n", list(list("along_dim"), list("integer range from 1 to the maximum dimension of ", 
#&gt;                   list("x"), ".\n", "baseline along this dimension, this is usually the time dimension.")), 
#&gt;                 "\n", "\n", list(list("baseline_indexpoints"), 
#&gt;                   list("integer vector, which index points are counted\n", 
#&gt;                     "into baseline window? Each index ranges from 1 to ", 
#&gt;                     list("dim(x)[[along_dim]]"), ".\n", "See Details.")), 
#&gt;                 "\n", "\n", list(list("unit_dims"), list("integer vector, baseline unit: see Details.")), 
#&gt;                 "\n", "\n", list(list("method"), list("character, baseline method options are:\n", 
#&gt;                   list("\"percentage\""), ", ", list("\"sqrt_percentage\""), 
#&gt;                   ", ", list("\"decibel\""), ",\n", list("\"zscore\""), 
#&gt;                   ", and ", list("\"sqrt_zscore\""))), "\n"), 
#&gt;             "\n", list("\n", "Contrast array with the same dimension as ", 
#&gt;                 list("x"), ".\n"), "\n", list("\n", "Provides five methods to baseline an array and calculate\n", 
#&gt;                 "contrast.\n"), "\n", list("\n", "Consider a scenario where we want to baseline a bunch of signals recorded\n", 
#&gt;                 "from different locations. For each location, we record ", 
#&gt;                 list("n"), " sessions.\n", "For each session, the signal is further decomposed into frequency-time\n", 
#&gt;                 "domain. In this case, we have the input ", list(
#&gt;                   "x"), " in the following form:\n", list(list(
#&gt;                   "session x frequency x time x location")), 
#&gt;                 "\n", "Now we want to calibrate signals for each session, frequency and location\n", 
#&gt;                 "using the first 100 time points as baseline points, then the code will be\n", 
#&gt;                 list(list("baseline_array(x, along_dim=3, 1:100, unit_dims=c(1,2,4))")), 
#&gt;                 "\n", list("along_dim=3"), " is dimension of time, in this case, it's the\n", 
#&gt;                 "third dimension of ", list("x"), ". ", list(
#&gt;                   "baseline_indexpoints=1:100"), ", meaning\n", 
#&gt;                 "the first 100 time points are used to calculate baseline.\n", 
#&gt;                 list("unit_dims"), " defines the unit signal. Its value ", 
#&gt;                 list("c(1,2,4)"), "\n", "means the unit signal is per session (first dimension), per frequency\n", 
#&gt;                 "(second) and per location (fourth).\n", "\n", 
#&gt;                 "In some other cases, we might want to calculate baseline across frequencies\n", 
#&gt;                 "then the unit signal is ", list(list("frequency x time")), 
#&gt;                 ", i.e. signals that share the\n", "same session and location also share the same baseline. In this case,\n", 
#&gt;                 "we assign ", list("unit_dims=c(1,4)"), ".\n", 
#&gt;                 "\n", "There are five baseline methods. They fit for different types of data.\n", 
#&gt;                 "Denote ", list(list("z")), " is an unit signal, ", 
#&gt;                 list(list("z_0")), " is its baseline slice. Then\n", 
#&gt;                 "these baseline methods are:\n", "\n", list("\n", 
#&gt;                   list(list(list("\"percentage\"")), list("\n", 
#&gt;                     list(list("\n", "  \\frac{z - \\bar{z_{0}}}{\\bar{z_{0}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (z / mean(z_0) - 1) x 100%\n")), 
#&gt;                     "\n")), "\n", list(list(list("\"sqrt_percentage\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z} - \\bar{\\sqrt{z_{0}}}}{\\bar{\\sqrt{z_{0}}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (sqrt(z) / mean(sqrt(z_0)) - 1) x 100%\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"decibel\"")), 
#&gt;                     list("\n", list(list("\n", "  10 \\times ( \\log_{10}(z) - \\bar{\\log_{10}(z_{0})} )\n"), 
#&gt;                       list("\n", "  10 * ( log10 (z) - mean( log10(z_0) ) )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{z-\\bar{z_{0}}}{sd(z_{0})}\n"), 
#&gt;                       list("\n", "  (z - mean( z_0 )) / sd( z_0 )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"sqrt_zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z}-\\bar{\\sqrt{z_{0}}}}{sd(\\sqrt{z_{0}})}\n"), 
#&gt;                       list("\n", "  (sqrt(z) - mean( sqrt(z_0) )) / sd( sqrt(z_0) )\n")), 
#&gt;                       "\n")), "\n", "\n", "\n"), "\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(dipsaus)\n", "set.seed(1)\n", 
#&gt;                 "\n", "# Generate sample data\n", "dims = c(10,20,30,2)\n", 
#&gt;                 "x = array(rnorm(prod(dims))^2, dims)\n", "\n", 
#&gt;                 "# Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "baseline_window = sample(30, 10)\n", "\n", "# ----- baseline percentage change ------\n", 
#&gt;                 "\n", "# Using base functions\n", "re1 &lt;- aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "  m &lt;- mean(y[baseline_window])\n", "  (y/m - 1) * 100\n", 
#&gt;                 "}), c(2,3,1,4))\n", "\n", "# Using dipsaus\n", 
#&gt;                 "re2 &lt;- baseline_array(x, 3, baseline_window, c(1,2,4),\n", 
#&gt;                 "                      method = 'percentage')\n", 
#&gt;                 "\n", "# Check different, should be very tiny (double precisions)\n", 
#&gt;                 "range(re2 - re1)\n", "\n", "# Check speed for large dataset\n", 
#&gt;                 "if(interactive()){\n", "  dims = c(200,20,300,2)\n", 
#&gt;                 "  x = array(rnorm(prod(dims))^2, dims)\n", "  # Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "  baseline_window = seq_len(100)\n", "  f1 &lt;- function(){\n", 
#&gt;                 "    aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "      m &lt;- mean(y[baseline_window])\n", "      (y/m - 1) * 100\n", 
#&gt;                 "    }), c(2,3,1,4))\n", "  }\n", "  f2 &lt;- function(){\n", 
#&gt;                 "    # equivalent as bl = x[,,baseline_window, ]\n", 
#&gt;                 "    #\n", "    baseline_array(x, along_dim = 3,\n", 
#&gt;                 "                   baseline_indexpoints = baseline_window,\n", 
#&gt;                 "                   unit_dims = c(1,2,4), method = 'sqrt_percentage')\n", 
#&gt;                 "  }\n", "  microbenchmark::microbenchmark(f1(), f2(), times = 3L)\n", 
#&gt;                 "}\n", "\n", "\n", "\n"), "\n"), cat2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("cat2"), "\n", list("cat2"), "\n", list("Color Output"), 
#&gt;             "\n", list("\n", "cat2(\n", "  ...,\n", "  level = \"DEBUG\",\n", 
#&gt;                 "  print_level = FALSE,\n", "  file = \"\",\n", 
#&gt;                 "  sep = \" \",\n", "  fill = FALSE,\n", "  labels = NULL,\n", 
#&gt;                 "  append = FALSE,\n", "  end = \"\\n\",\n", 
#&gt;                 "  pal = list(DEBUG = \"grey60\", INFO = \"#1d9f34\", WARNING = \"#ec942c\", ERROR =\n", 
#&gt;                 "    \"#f02c2c\", FATAL = \"#763053\", DEFAULT = \"grey60\"),\n", 
#&gt;                 "  use_cli = TRUE,\n", "  bullet = \"auto\"\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("..."), list(
#&gt;                 "to be printed")), "\n", "\n", list(list("level"), 
#&gt;                 list("'DEBUG', 'INFO', 'WARNING', 'ERROR', or 'FATAL' (total 5 levels)")), 
#&gt;                 "\n", "\n", list(list("print_level"), list("if true, prepend levels before messages")), 
#&gt;                 "\n", "\n", list(list("file, sep, fill, labels, append"), 
#&gt;                   list("pass to ", list("base::cat"))), "\n", 
#&gt;                 "\n", list(list("end"), list("character to append to the string")), 
#&gt;                 "\n", "\n", list(list("pal"), list("a named list defining colors see details")), 
#&gt;                 "\n", "\n", list(list("use_cli"), list("logical, whether to use package 'cli'")), 
#&gt;                 "\n", "\n", list(list("bullet"), list("character, if use 'cli', which symbol to show. see\n", 
#&gt;                   list(list("symbol")))), "\n"), "\n", list("\n", 
#&gt;                 "none.\n"), "\n", list("\n", "Color Output\n"), 
#&gt;             "\n", list("\n", "There are five levels of colors by default: 'DEBUG', 'INFO', 'WARNING', 'ERROR',\n", 
#&gt;                 "or FATAL. Default colors are: 'DEBUG' (", list(
#&gt;                   "grey60"), "), 'INFO' (", list("#1d9f34"), 
#&gt;                 "), 'WARNING'\n", "(", list("#ec942c"), "), 'ERROR' (", 
#&gt;                 list("#f02c2c"), "), 'FATAL' (", list("#763053"), 
#&gt;                 ") and\n", "'DEFAULT' (", list("#000000"), ", black). If level is not in preset five levels,\n", 
#&gt;                 "the color will be \"default\"-black color.\n"), 
#&gt;             "\n"), check_installed_packages.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("check_installed_packages"), "\n", list(
#&gt;                 "check_installed_packages"), "\n", list("Check If Packages Are Installed, Returns Missing Packages"), 
#&gt;             "\n", list("\n", "check_installed_packages(\n", "  pkgs,\n", 
#&gt;                 "  libs = base::.libPaths(),\n", "  auto_install = FALSE,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "pkgs"), list("vector of packages to install")), 
#&gt;                 "\n", "\n", list(list("libs"), list("paths of libraries")), 
#&gt;                 "\n", "\n", list(list("auto_install"), list("automatically install packages if missing")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters for ", 
#&gt;                   list("install.packages"))), "\n"), "\n", list(
#&gt;                 "\n", "package names that are not installed\n"), 
#&gt;             "\n", list("\n", "Check If Packages Are Installed, Returns Missing Packages\n"), 
#&gt;             "\n"), col2hexStr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("col2hexStr"), "\n", list("col2hexStr"), 
#&gt;             "\n", list("Convert color to Hex string"), "\n", 
#&gt;             list("\n", "col2hexStr(col, alpha = NULL, prefix = \"#\", ...)\n"), 
#&gt;             "\n", list("\n", list(list("col"), list("character or integer indicating color")), 
#&gt;                 "\n", "\n", list(list("alpha"), list(list("NULL"), 
#&gt;                   " or numeric, transparency. See ", list("grDevices::rgb"))), 
#&gt;                 "\n", "\n", list(list("prefix"), list("character, default is ", 
#&gt;                   list("\"#\""))), "\n", "\n", list(list("..."), 
#&gt;                   list("passing to  ", list(list("adjustcolor")))), 
#&gt;                 "\n"), "\n", list("\n", "characters containing the hex value of each color. See details\n"), 
#&gt;             "\n", list("\n", "Convert color to Hex string\n"), 
#&gt;             "\n", list("\n", list("col2hexStr"), " converts colors such as 1, 2, 3, \"red\", \"blue\", ... into\n", 
#&gt;                 "hex strings that can be easily recognized by `HTML`, `CSS` and `JavaScript`.\n", 
#&gt;                 "Internally this function uses ", list(list("adjustcolor")), 
#&gt;                 " with two differences:\n", list("\n", list(), 
#&gt;                   " the returned hex string does not contain alpha value if ", 
#&gt;                   list("alpha"), " is ", list("NULL"), ";\n", 
#&gt;                   list(), " the leading prefix \"#\" can be customized\n"), 
#&gt;                 "\n"), "\n", list("\n", "\n", "col2hexStr(1, prefix = '0x')      # \"0x000000\"\n", 
#&gt;                 "col2hexStr('blue')                # \"#0000FF\"\n", 
#&gt;                 "\n", "# Change default palette, see \"grDevices::colors()\"\n", 
#&gt;                 "grDevices::palette(c('orange3', 'skyblue1'))\n", 
#&gt;                 "col2hexStr(1)                     # Instead of #000000, #CD8500\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("adjustcolor")), 
#&gt;                 "\n"), "\n"), collapse.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("collapse"), "\n", list("collapse"), "\n", 
#&gt;             list("Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "collapse(x, keep, average = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A numeric multi-mode tensor (array), without ", 
#&gt;                 list("NA"))), "\n", "\n", list(list("keep"), 
#&gt;                 list("Which dimension to keep")), "\n", "\n", 
#&gt;                 list(list("average"), list("collapse to sum or mean")), 
#&gt;                 "\n"), "\n", list("\n", "a collapsed array with values to be mean or summation along\n", 
#&gt;                 "collapsing dimensions\n"), "\n", list("\n", 
#&gt;                 "Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "# Example 1\n", 
#&gt;                 "x = matrix(1:16, 4)\n", "\n", "# Keep the first dimension and calculate sums along the rest\n", 
#&gt;                 "collapse(x, keep = 1)\n", "rowSums(x)  # Should yield the same result\n", 
#&gt;                 "\n", "# Example 2\n", "x = array(1:120, dim = c(2,3,4,5))\n", 
#&gt;                 "result = collapse(x, keep = c(3,2))\n", "compare = apply(x, c(3,2), sum)\n", 
#&gt;                 "sum(abs(result - compare)) # The same, yield 0 or very small number (1e-10)\n", 
#&gt;                 "\n", "# Example 3 (performance)\n", "RcppParallel::setThreadOptions(numThreads = -1) # auto multicores\n", 
#&gt;                 "# Small data, no big difference, even slower\n", 
#&gt;                 "x = array(rnorm(240), dim = c(4,5,6,2))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L, check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  }\n", ")\n", "\n", "# large data big difference\n", 
#&gt;                 "x = array(rnorm(prod(300,200,105)), c(300,200,105,1))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L , check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  })\n", "\n"), "\n"), compoundInput2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("compoundInput2"), "\n", list("compoundInput2"), 
#&gt;             "\n", list("Compound input that combines and extends shiny inputs"), 
#&gt;             "\n", list("\n", "compoundInput2(\n", "  inputId,\n", 
#&gt;                 "  label = \"Group\",\n", "  components = shiny::tagList(),\n", 
#&gt;                 "  initial_ncomp = 1,\n", "  min_ncomp = 0,\n", 
#&gt;                 "  max_ncomp = 10,\n", "  value = NULL,\n", "  label_color = 1,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "inputId"), list("character, shiny input ID")), 
#&gt;                 "\n", "\n", list(list("label"), list("character, will show on each groups")), 
#&gt;                 "\n", "\n", list(list("components"), list("`HTML` tags that defines and combines HTML components within groups")), 
#&gt;                 "\n", "\n", list(list("initial_ncomp"), list(
#&gt;                   "numeric initial number of groups to show, non-negative")), 
#&gt;                 "\n", "\n", list(list("min_ncomp"), list("minimum number of groups, default is 0, non-negative")), 
#&gt;                 "\n", "\n", list(list("max_ncomp"), list("maximum number of groups, default is 10, greater or equal\n", 
#&gt;                   "than ", list("min_ncomp"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, initial values of each inputs, see examples.")), 
#&gt;                 "\n", "\n", list(list("label_color"), list("integer or characters, length of 1 or ", 
#&gt;                   list("max_ncomp"), ",\n", "assigning colors to each group labels,")), 
#&gt;                 "\n", "\n", list(list("..."), list("will be ignored")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Compound input that combines and extends shiny inputs\n"), 
#&gt;             "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    list(),                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "# Source - system.file('demo/example-compountInput2.R', package='dipsaus')\n", 
#&gt;                 "\n", "# demo('example-compountInput2', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  fluidRow(\n", "    column(\n", 
#&gt;                 "      width = 4,\n", "      compoundInput2(\n", 
#&gt;                 "        'compound', 'Group Label', label_color = 1:10,\n", 
#&gt;                 "        components = div(\n", "          textInput('txt', 'Text'),\n", 
#&gt;                 "          selectInput('sel', 'Select', choices = 1:10, multiple = TRUE),\n", 
#&gt;                 "          sliderInput('sli', 'Slider', max=1, min=0, val=0.5)\n", 
#&gt;                 "        ),\n", "        value = list(\n", "          list(txt = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "          '',                # no settings for second group\n", 
#&gt;                 "          list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "        )\n", "      ),\n", "      hr(),\n", 
#&gt;                 "      actionButton('action', 'Update compound input')\n", 
#&gt;                 "    )\n", "  )\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observe({\n", "    print(input$compound)\n", 
#&gt;                 "  })\n", "  observe({\n", "    # Getting specific input at group 1\n", 
#&gt;                 "    print(input$compound_txt_1)\n", "  })\n", 
#&gt;                 "  observeEvent(input$action, {\n", "    updateCompoundInput2(\n", 
#&gt;                 "      session, 'compound',\n", "      # Update values for each components\n", 
#&gt;                 "      value = lapply(1:5, function(ii){\n", 
#&gt;                 "        list(\n", "          txt = sample(LETTERS, 1),\n", 
#&gt;                 "          sel = sample(1:10, 3),\n", "          sli = runif(1)\n", 
#&gt;                 "        )\n", "      }), ncomp = NULL, txt = list(label = as.character(Sys.time())))\n", 
#&gt;                 "  })\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser = TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateCompoundInput2")), 
#&gt;                 " for how to update inputs\n"), "\n"), decorate_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("decorate_function"), "\n", list("decorate_function"), 
#&gt;             "\n", list("%D%"), "\n", list("Python-style decorator"), 
#&gt;             "\n", list("\n", "decorate_function(orig, decor, ...)\n", 
#&gt;                 "\n", "lhs %D% rhs\n"), "\n", list("\n", list(
#&gt;                 list("orig, lhs"), list("any function")), "\n", 
#&gt;                 "\n", list(list("decor, rhs"), list("decorator function that takes ", 
#&gt;                   list("orig"), " as its first\n", "argument")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("decor"))), "\n"), "\n", list("\n", "Python-style decorator\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# Example 1: basic usage\n", 
#&gt;                 "# Decorator that prints summary of results and return results itself\n", 
#&gt;                 "verbose_summary &lt;- function(...){\n", "  summary_args &lt;- list(...)\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      results &lt;- f(...)\n", 
#&gt;                 "\n", "\n", "      print(do.call(\n", "        summary,\n", 
#&gt;                 "        c(list(results), summary_args)\n", "      ))\n", 
#&gt;                 "      results\n", "\n", "    }\n", "  }\n", 
#&gt;                 "\n", "}\n", "\n", "# runs as.list, but through verbose_summary\n", 
#&gt;                 "as_list2 &lt;- decorate_function(as.list, verbose_summary)\n", 
#&gt;                 "\n", "# run test\n", "res &lt;- as_list2(1:3)  # will verbose summary\n", 
#&gt;                 "identical(res, as.list(1:3))\n", "\n", "# Example 2\n", 
#&gt;                 "x &lt;- 1:20\n", "y &lt;- x + rnorm(20)\n", "\n", 
#&gt;                 "# decorator, add a line with slope 1 with given intercept\n", 
#&gt;                 "abline_xy &lt;- function(b){\n", "  function(f){\n", 
#&gt;                 "    function(...){\n", "      f(...)\n", "      intercept &lt;- get_dots('intercept', 0, ...)\n", 
#&gt;                 "      abline(a = intercept, b = b)\n", "    }\n", 
#&gt;                 "  }\n", "}\n", "\n", "# orig, plot whatever x vs jittered+intercept\n", 
#&gt;                 "plot_xy &lt;- function(x, intercept = rnorm(1)){\n", 
#&gt;                 "  plot(x, jitter(x, amount = 3) + intercept)\n", 
#&gt;                 "}\n", "\n", "# new function that decorate plot_xy with abline_xy, and\n", 
#&gt;                 "# returns the intercept\n", "plot_xy2 &lt;- decorate_function(plot_xy, abline_xy, b = 1)\n", 
#&gt;                 "\n", "# alternatively, you might also want to try\n", 
#&gt;                 "plot_xy2 &lt;- plot_xy %D% abline_xy(b = 1)\n", 
#&gt;                 "\n", "plot_xy2(x = 1:20)\n", "\n"), "\n"), deparse_svec.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("deparse_svec"), "\n", list("deparse_svec"), 
#&gt;             "\n", list("Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "deparse_svec(\n", 
#&gt;                 "  nums,\n", "  connect = \"-\",\n", "  concatenate = TRUE,\n", 
#&gt;                 "  collapse = \",\",\n", "  max_lag = 1\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("nums"), list("integer vector")), 
#&gt;                 "\n", "\n", list(list("connect"), list("character used to connect consecutive numbers")), 
#&gt;                 "\n", "\n", list(list("concatenate"), list("connect strings if there are multiples")), 
#&gt;                 "\n", "\n", list(list("collapse"), list("if concatenate, character used to connect strings")), 
#&gt;                 "\n", "\n", list(list("max_lag"), list("defines \"consecutive\", min = 1")), 
#&gt;                 "\n"), "\n", list("\n", "strings representing the input vector. For example, ", 
#&gt;                 list("c(1, 2, 3)"), " returns \"1-3\".\n"), "\n", 
#&gt;             list("\n", "Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "deparse_svec(c(1:10, 15:18))\n"), 
#&gt;             "\n", list("\n", list(list("parse_svec")), "\n"), 
#&gt;             "\n"), dev_create.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/graphics.R", 
#&gt;             "\n", list("dev_create"), "\n", list("dev_create"), 
#&gt;             "\n", list("Create a group of named graphic devices"), 
#&gt;             "\n", list("\n", "dev_create(..., env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("named expressions to launch devices")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate expressions")), 
#&gt;                 "\n"), "\n", list("\n", "A list of functions to query, control, and switch between devices\n"), 
#&gt;             "\n", list("\n", "Create a group of named graphic devices\n"), 
#&gt;             "\n", list("\n", list(" ## Unix-specific example\n", 
#&gt;                 "\n", "# Create multiple named devices\n", "devs &lt;- dev_create(line = X11(), points = x11())\n", 
#&gt;                 "\n", "# switch to device named \"points\"\n", 
#&gt;                 "\n", "devs$dev_which('points')\n", "plot(1:10)\n", 
#&gt;                 "\n", "# switch to \"line\" device\n", "devs$dev_switch('line')\n", 
#&gt;                 "plot(1:100, type='l')\n", "\n", "# Create another group with conflict name\n", 
#&gt;                 "dev_another &lt;- dev_create(line = X11())\n", 
#&gt;                 "\n", "# Query device name with 'line'\n", "dev_another$dev_which('line')  # 4\n", 
#&gt;                 "devs$dev_which('line')  # 2, doesn't conflict with the new groups\n", 
#&gt;                 "\n", "dev.list()\n", "# close one or more device\n", 
#&gt;                 "dev_another$dev_off('line')\n", "dev.list()\n", 
#&gt;                 "\n", "# close all devices\n", "devs$dev_off()\n", 
#&gt;                 "dev.list()\n", "\n"), "\n"), "\n"), do_aggregate.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("do_aggregate"), "\n", list("do_aggregate"), 
#&gt;             "\n", list("Make aggregate pipe-friendly"), "\n", 
#&gt;             list("\n", "do_aggregate(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("an R object")), "\n", 
#&gt;                 "\n", list(list("..."), list("other parameters passed to ", 
#&gt;                   list(list("aggregate")))), "\n"), "\n", list(
#&gt;                 "\n", "Results from ", list(list("aggregate")), 
#&gt;                 "\n"), "\n", list("\n", "A pipe-friendly wrapper of ", 
#&gt;                 list(list("aggregate")), "\n", "when using formula as input.\n"), 
#&gt;             "\n", list("\n", "\n", "library(magrittr)\n", "data(ToothGrowth)\n", 
#&gt;                 "\n", "ToothGrowth %&gt;%\n", "  do_aggregate(len ~ ., mean)\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("aggregate")), 
#&gt;                 "\n"), "\n"), drop_nulls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("drop_nulls"), "\n", list("drop_nulls"), 
#&gt;             "\n", list("Drop ", list("NULL"), " values from list or vectors"), 
#&gt;             "\n", list("\n", "drop_nulls(x, .invalids = list(\"is.null\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("list to check")), 
#&gt;                 "\n", "\n", list(list(".invalids"), list("a list of functions, or function name. Default is 'is.null'.")), 
#&gt;                 "\n"), "\n", list("\n", "list or vector containing no invalid values\n"), 
#&gt;             "\n", list("\n", "Drop ", list("NULL"), " values from list or vectors\n"), 
#&gt;             "\n", list("\n", "\n", "x &lt;- list(NULL,NULL,1,2)\n", 
#&gt;                 "drop_nulls(x)  # length of 2\n", "\n"), "\n"), 
#&gt;         eval_dirty.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("eval_dirty"), "\n", list("eval_dirty"), 
#&gt;             "\n", list("Evaluate expressions"), "\n", list("\n", 
#&gt;                 "eval_dirty(expr, env = parent.frame(), data = NULL, quoted = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression or 'rlang' quo")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate")), 
#&gt;                 "\n", "\n", list(list("data"), list("dataframe or list")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("Is the expression quoted? By default, this is ", 
#&gt;                   list("TRUE"), ".\n", "This is useful when you don't want to use an expression that is stored in a\n", 
#&gt;                   "variable; see examples")), "\n"), "\n", list(
#&gt;                 "\n", "the executed results of ", list("expr"), 
#&gt;                 " evaluated with side effects.\n"), "\n", list(
#&gt;                 "\n", "Evaluate expressions\n"), "\n", list("\n", 
#&gt;                 list("eval_dirty"), " uses ", list("base::eval()"), 
#&gt;                 " function to evaluate\n", "expressions. Compare to ", 
#&gt;                 list("rlang::eval_tidy"), ", which won't affect original\n", 
#&gt;                 "environment, ", list("eval_dirty"), " causes changes to the environment. Therefore\n", 
#&gt;                 "if ", list("expr"), " contains assignment, environment will be changed in this case.\n"), 
#&gt;             "\n", list("\n", "\n", "env = new.env(); env$a = 1\n", 
#&gt;                 "rlang::eval_tidy(quote({a &lt;- 111}), env = env)\n", 
#&gt;                 "print(env$a)  # Will be 1. This is because eval_tidy has no side effect\n", 
#&gt;                 "\n", "eval_dirty(quote({a &lt;- 111}), env)\n", 
#&gt;                 "print(env$a)  # 111, a is changed\n", "\n", 
#&gt;                 "# Unquoted case\n", "eval_dirty({a &lt;- 222}, env, quoted = FALSE)\n", 
#&gt;                 "print(env$a)\n", "\n"), "\n"), fastmap2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fastmap2.R", "\n", 
#&gt;             list("fastmap2"), "\n", list("fastmap2"), "\n", list(
#&gt;                 "[[.fastmap2"), "\n", list("$.fastmap2"), "\n", 
#&gt;             list("[[&lt;-.fastmap2"), "\n", list("$&lt;-.fastmap2"), 
#&gt;             "\n", list("[.fastmap2"), "\n", list("[&lt;-.fastmap2"), 
#&gt;             "\n", list("names.fastmap2"), "\n", list("print.fastmap2"), 
#&gt;             "\n", list("length.fastmap2"), "\n", list("as.list.fastmap2"), 
#&gt;             "\n", list("A Wrapper for ", list("fastmap::fastmap")), 
#&gt;             "\n", list("\n", "fastmap2(missing_default = NULL)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...)\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...) &lt;- value\n", 
#&gt;                 "\n", list(list("names"), list("fastmap2")), 
#&gt;                 "(x)\n", "\n", list(list("print"), list("fastmap2")), 
#&gt;                 "(x, ...)\n", "\n", list(list("length"), list(
#&gt;                   "fastmap2")), "(x)\n", "\n", list(list("as.list"), 
#&gt;                   list("fastmap2")), "(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("missing_default"), list("passed to ", 
#&gt;                   list("fastmap::fastmap"))), "\n", "\n", list(
#&gt;                   list("x"), list("a ", list("'fastmap2'"), " object")), 
#&gt;                 "\n", "\n", list(list("name"), list("name, or key of the value")), 
#&gt;                 "\n", "\n", list(list("value"), list("any R object")), 
#&gt;                 "\n", "\n", list(list("i, j"), list("vector of names")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to other methods")), 
#&gt;                 "\n"), "\n", list("\n", "A list of ", list("'fastmap2'"), 
#&gt;                 " instance\n"), "\n", list("\n", list(list("fastmap")), 
#&gt;                 "\n", "provides a key-value store where the keys are strings and the\n", 
#&gt;                 "values are any R objects. It differs from normal environment that\n", 
#&gt;                 list(list("fastmap")), " avoids memory leak. ", 
#&gt;                 list("fastmap2"), "\n", "is a wrapper for ", 
#&gt;                 list("fastmap"), ", which provides several generic\n", 
#&gt;                 "functions such that it has similar behaviors to lists or\n", 
#&gt;                 "environments\n"), "\n", list("\n", "\n", "## --------------------------- Basic Usage --------------------------\n", 
#&gt;                 "map &lt;- fastmap2()\n", "map$a = 1\n", "map$b = 2\n", 
#&gt;                 "print(map)\n", "\n", "map[c('a', 'b')]\n", "# Alternative way\n", 
#&gt;                 "map['a', 'b']\n", "\n", "map[c('c', 'd')] &lt;- 3:4\n", 
#&gt;                 "# or\n", "map['e', 'f'] &lt;- 5:6\n", "\n", "# The order is not guaranteed, unless sort=TRUE\n", 
#&gt;                 "as.list(map)\n", "as.list(map, sort=TRUE)\n", 
#&gt;                 "\n", "names(map)\n", "length(map)\n", "\n", 
#&gt;                 "## ----------------------- NULL value handles -----------------------\n", 
#&gt;                 "map$b &lt;- NULL\n", "names(map)   # 'b' still exists!\n", 
#&gt;                 "as.list(map) # 'b' is NULL, but still there\n", 
#&gt;                 "\n", "# to remove 'b', you have to use `@remove` method\n", 
#&gt;                 "map$`@remove`('b')\n", "\n", "## ---------------- Native fastmap::fastmap methods -----------------\n", 
#&gt;                 "\n", "# whether map has 'a'\n", "map$`@has`('a')\n", 
#&gt;                 "\n", "# Remove a name from list\n", "map$`@remove`('a')\n", 
#&gt;                 "\n", "# remove all from list\n", "map$`@reset`()\n", 
#&gt;                 "print(map)\n", "\n"), "\n"), forelse.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("forelse"), "\n", list("forelse"), "\n", list(
#&gt;                 "Python-style ", list("\"for-else\""), " function"), 
#&gt;             "\n", list("\n", "forelse(x, FUN, ALT_FUN = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("iterative R objects such as list, vector, etc.")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("function that applies to each ", 
#&gt;                   list("x"))), "\n", "\n", list(list("ALT_FUN"), 
#&gt;                   list("function that takes no argument or other types of R\n", 
#&gt;                     "object")), "\n"), "\n", list("\n", "If any ", 
#&gt;                 list("FUN"), " returns anything other than ", 
#&gt;                 list("NULL"), ",\n", "then the function returns the first none ", 
#&gt;                 list("NULL"), " object. If\n", "all ", list("x"), 
#&gt;                 " fed to ", list("FUN"), " return ", list("NULL"), 
#&gt;                 ", then this\n", "function returns ", list("ALT_FUN"), 
#&gt;                 " (if ", list("ALT_FUN"), " is not a function)\n", 
#&gt;                 "or the result of ", list("ALT_FUN()"), ".\n"), 
#&gt;             "\n", list("\n", "Provide Python-style ", list("\"for-else\""), 
#&gt;                 " that works as\n", "follows: for each element, execute \"for\" block, if there is break\n", 
#&gt;                 "while executing \"for\" block, then just stop and ignore the \"else\"\n", 
#&gt;                 "statement, otherwise run \"else\" block.\n"), 
#&gt;             "\n", list("\n", "\n", "# --------------------------- Basic Usage ------------------------------\n", 
#&gt;                 "\n", "# 1. ALT_FUN get executed because FUN returns NULL for all items in x\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x &gt; 10) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  function(){\n", "    cat('ALT_FUN is executed!\\n')\n", 
#&gt;                 "    'wow'\n", "  }\n", ")\n", "\n", "# 2. FUN returns non-NULL object\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  'wow'\n", ")\n", "\n", "# --------------------------- Performance ------------------------------\n", 
#&gt;                 "FUN &lt;- function(x){\n", "  Sys.sleep(0.01)\n", 
#&gt;                 "  if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "}\n", "\n", "microbenchmark::microbenchmark({\n", 
#&gt;                 "  forelse(1:10, FUN, 'wow')\n", "}, {\n", "  y &lt;- unlist(lapply(1:10, FUN))\n", 
#&gt;                 "  if(length(y)){\n", "    y &lt;- y[[1]]\n", "  }else{\n", 
#&gt;                 "    y &lt;- 'wow'\n", "  }\n", "}, {\n", "  y &lt;- NULL\n", 
#&gt;                 "  for(x in 1:10){ y &lt;- FUN(x) }\n", "  if(is.null(y)){ y &lt;- 'wow' }\n", 
#&gt;                 "}, times = 3)\n", "\n", "\n"), "\n"), getInputBinding.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("getInputBinding"), "\n", list("getInputBinding"), 
#&gt;             "\n", list("Obtain registered input bindings"), "\n", 
#&gt;             list("\n", "getInputBinding(fname, pkg = NULL, envir = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("input function name, character or quoted expression\n", 
#&gt;                 "such as ", list("'shiny::textInput'"), " or ", 
#&gt;                 list("numericInput"), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("(optional), name of package")), 
#&gt;                 "\n", "\n", list(list("envir"), list("environment to evaluate ", 
#&gt;                   list("fname"), " if ", list("pkg"), " is not provided")), 
#&gt;                 "\n"), "\n", list("\n", "a list containing: 1. `JavaScript` input binding name; 2. `R` updating function name\n"), 
#&gt;             "\n", list("\n", "Obtain registered input bindings\n"), 
#&gt;             "\n", list("\n", "\n", "library(dipsaus)\n", "\n", 
#&gt;                 "# Most recommended usage\n", "getInputBinding('compoundInput2', pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Other usages\n", "getInputBinding('shiny::textInput')\n", 
#&gt;                 "\n", "\n", "getInputBinding(shiny::textInput)\n", 
#&gt;                 "\n", "getInputBinding(compoundInput2, pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Bad usage, raise errors in some cases\n", 
#&gt;                 list("\n", "## You need to library(shiny), or set envir=asNamespace('shiny'), or pkg='shiny'\n", 
#&gt;                   "getInputBinding('textInput')\n", "getInputBinding(textInput) # also fails\n", 
#&gt;                   "\n", "## Always fails\n", "getInputBinding('dipsaus::compoundInput2', pkg = 'dipsaus')\n"), 
#&gt;                 "\n", "\n"), "\n"), get_cpu.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_cpu"), "\n", list("get_cpu"), "\n", 
#&gt;             list("Get CPU Chip-set Information"), "\n", list(
#&gt;                 "\n", "get_cpu()\n"), "\n", list("\n", "a list of vendor ID and CPU model name\n"), 
#&gt;             "\n", list("\n", "Get CPU Chip-set Information\n"), 
#&gt;             "\n"), get_dots.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("get_dots"), "\n", list("get_dots"), "\n", 
#&gt;             list("Get element from dots ", list("'...'")), "\n", 
#&gt;             list("\n", "get_dots(..name, ..default = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("..name"), list("character name of the argument")), 
#&gt;                 "\n", "\n", list(list("..default"), list("R object to return if argument not found")), 
#&gt;                 "\n", "\n", list(list("..."), list("dots that contains argument")), 
#&gt;                 "\n"), "\n", list("\n", "Get specific key values from ", 
#&gt;                 list("'...'"), " without\n", "evaluating the rest of arguments.\n"), 
#&gt;             "\n", list("\n", "One could use ", list("list(...)[[name]]"), 
#&gt;                 " to extract any keys\n", "from the dots. However, such way reduces code readability. If\n", 
#&gt;                 "some arguments have not evaluated, ", list("list(...)"), 
#&gt;                 " will\n", list(list("force")), " evaluating them. Normally it's fine if\n", 
#&gt;                 "these expressions take little time to run, but if the\n", 
#&gt;                 "expression require time to run, ", list(list(
#&gt;                   "get_dots")), " avoids\n", "unnecessary evaluations.\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# ------------------------ Basic Usage ---------------------------\n", 
#&gt;                 "plot2 &lt;- function(...){\n", "  title = get_dots('main', 'There is no title', ...)\n", 
#&gt;                 "  plot(...)\n", "  title\n", "}\n", "\n", "plot2(1:10)\n", 
#&gt;                 "plot2(1:10, main = 'Scatter Plot of 1:10')\n", 
#&gt;                 "\n", "# ------------------------ Comparisons ----------------------------\n", 
#&gt;                 "f1 &lt;- function(...){ get_dots('x', ...) }\n", 
#&gt;                 "f2 &lt;- function(...){ list(...)[['x']] }\n", 
#&gt;                 "delayedAssign('y', { cat('y is evaluated!') })\n", 
#&gt;                 "\n", "# y will not evaluate\n", "f1(x = 1, y = y)\n", 
#&gt;                 "\n", "# y gets evaluated\n", "f2(x = 1, y = y)\n", 
#&gt;                 "\n", "# -------------------- Decorator example --------------------------\n", 
#&gt;                 "ret_range &lt;- function(which_range = 'y'){\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      f(...)\n", 
#&gt;                 "      y_range &lt;- range(get_dots(which_range, 0, ...))\n", 
#&gt;                 "      y_range\n", "    }\n", "  }\n", "}\n", 
#&gt;                 "plot_ret_yrange &lt;- plot %D% ret_range('y')\n", 
#&gt;                 "plot_ret_yrange(x = 1:10, y = rnorm(10))\n", 
#&gt;                 "\n", "\n"), "\n"), get_ram.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_ram"), "\n", list("get_ram"), "\n", 
#&gt;             list("Get Memory Size"), "\n", list("\n", "get_ram()\n"), 
#&gt;             "\n", list("\n", "numeric in Bytes how big your system RAM is\n"), 
#&gt;             "\n", list("\n", "Get Memory Size\n"), "\n"), `grapes-equals-greater-than-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%=&gt;%"), "\n", list("%=&gt;%"), "\n", list("A JavaScript style of creating functions"), 
#&gt;             "\n", list("\n", "args %=&gt;% expr\n"), "\n", list(
#&gt;                 "\n", list(list("args"), list("function arguments: see ", 
#&gt;                   list(list("formals")))), "\n", "\n", list(list(
#&gt;                   "expr"), list("R expression that forms the body of functions: see ", 
#&gt;                   list(list("body")))), "\n"), "\n", list("\n", 
#&gt;                 "A function that takes ", list("args"), " as parameters and ", 
#&gt;                 list("expr"), " as\n", "the function body\n"), 
#&gt;             "\n", list("\n", "A JavaScript style of creating functions\n"), 
#&gt;             "\n", list("\n", "# Formal arguments\n", "c(a) %=&gt;% {\n", 
#&gt;                 "  print(a)\n", "}\n", "\n", "# Informal arguments\n", 
#&gt;                 "list(a=) %=&gt;% {\n", "  print(a)\n", "}\n", "\n", 
#&gt;                 "# Multiple inputs\n", "c(a, b = 2, ...) %=&gt;% {\n", 
#&gt;                 "  print(c(a, b, ...))\n", "}\n", "\n", "# ----- JavaScript style of forEach -----\n", 
#&gt;                 "# ### Equivalent JavaScript Code:\n", "# LETTERS.forEach((el, ii) =&gt; {\n", 
#&gt;                 "#   console.log('The index of letter ' + el + ' in \"x\" is: ' + ii);\n", 
#&gt;                 "# });\n", "\n", "iapply(LETTERS, c(el, ii) %=&gt;% {\n", 
#&gt;                 "  cat2('The index of letter ', el, ' in ', sQuote('x'), ' is: ', ii)\n", 
#&gt;                 "}) -&gt; results\n"), "\n"), `grapes-help-set-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%?&lt;-%"), "\n", list("%?&lt;-%"), "\n", list("Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens."), 
#&gt;             "\n", list("\n", "lhs %?&lt;-% value\n"), "\n", list(
#&gt;                 "\n", list(list("lhs"), list("an object to check or assign")), 
#&gt;                 "\n", "\n", list(list("value"), list("value to be assigned if lhs is NULL")), 
#&gt;                 "\n"), "\n", list("\n", "Assign value on the right-hand side to the left-hand side if\n", 
#&gt;                 list("lhs"), " does not exist or is ", list("NULL"), 
#&gt;                 "\n"), "\n", list("\n", "Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens.\n"), 
#&gt;             "\n", list("\n", "# Prepare, remove aaa if exists\n", 
#&gt;                 "if(exists('aaa', envir = globalenv(), inherits = FALSE)){\n", 
#&gt;                 "  rm(aaa, envir = globalenv())\n", "}\n", "\n", 
#&gt;                 "# Assign\n", "aaa %?&lt;-% 1; print(aaa)\n", "\n", 
#&gt;                 "# However, if assigned, nothing happens\n", 
#&gt;                 "aaa = 1;\n", "aaa %?&lt;-% 2;\n", "print(aaa)\n", 
#&gt;                 "\n", "# in a list\n", "a = list()\n", "a$e %?&lt;-% 1; print(a$e)\n", 
#&gt;                 "a$e %?&lt;-% 2; print(a$e)\n", "\n"), "\n"), `grapes-plus-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%+-%"), "\n", list("%+-%"), "\n", list("Plus-minus operator"), 
#&gt;             "\n", list("\n", "a %+-% b\n"), "\n", list("\n", 
#&gt;                 list(list("a, b"), list("numeric vectors, matrices or arrays")), 
#&gt;                 "\n"), "\n", list("\n", list("a +/- b"), ", the dimension depends on ", 
#&gt;                 list("a+b"), ". If ", list("a+b"), " is\n", "a scalar, returns a vector of two; in the case of vector, returns a matrix;\n", 
#&gt;                 "all other cases will return an array with the last dimension equal to 2.\n"), 
#&gt;             "\n", list("\n", "Plus-minus operator\n"), "\n", 
#&gt;             list("\n", "\n", "# scalar\n", "1 %+-% 2   # -1, 3\n", 
#&gt;                 "\n", "# vector input\n", "c(1,2,3) %+-% 2   # matrix\n", 
#&gt;                 "\n", "# matrix input\n", "matrix(1:9, 3) %+-% 2   # 3x3x2 array\n", 
#&gt;                 "\n"), "\n"), handler_dipsaus_progress.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("handler_dipsaus_progress"), "\n", list(
#&gt;                 "handler_dipsaus_progress"), "\n", list("Progress-bar Handler"), 
#&gt;             "\n", list("\n", "handler_dipsaus_progress(\n", "  title = getOption(\"dipsaus.progressr.title\", \"Progress\"),\n", 
#&gt;                 "  intrusiveness = getOption(\"progressr.intrusiveness.gui\", 1),\n", 
#&gt;                 "  target = if (is.null(shiny::getDefaultReactiveDomain())) \"terminal\" else \"gui\",\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "title"), list("default title of ", list(list(
#&gt;                 "progress2")))), "\n", "\n", list(list("intrusiveness"), 
#&gt;                 list("A non-negative scalar on how intrusive\n", 
#&gt;                   "(disruptive) the reporter to the user")), 
#&gt;                 "\n", "\n", list(list("target"), list("where progression updates are rendered")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("make_progression_handler")))), "\n"), 
#&gt;             "\n", list("\n", "Handler for ", list(list("progress2")), 
#&gt;                 " to support\n", list("progressr::handlers"), 
#&gt;                 ". See examples for detailed use case\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(progressr)\n", "library(shiny)\n", 
#&gt;                 "library(future)\n", "\n", "## ------------------------------ Setup! -------------------------------\n", 
#&gt;                 "handlers(handler_dipsaus_progress())\n", "\n", 
#&gt;                 "# ------------------------------ A simple usage ------------------------\n", 
#&gt;                 "xs &lt;- 1:5\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- lapply(xs, function(x) {\n", "    p(sprintf(\"x=%g\", x))\n", 
#&gt;                 "    Sys.sleep(0.1)\n", "    sqrt(x)\n", "  })\n", 
#&gt;                 "})\n", "\n", "# ------------------------ A future.apply case -------------------------\n", 
#&gt;                 "plan(sequential)\n", "# test it yourself with plan(multisession)\n", 
#&gt;                 "\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- future.apply::future_lapply(xs, function(x) {\n", 
#&gt;                 "    p(sprintf(\"x=%g\", x))\n", "    Sys.sleep(0.1)\n", 
#&gt;                 "    sqrt(x)\n", "  })\n", "})\n", "\n", "# ------------------------ A shiny case --------------------------------\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButton('ok', 'Run Demo')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  handlers(handler_dipsaus_progress())\n", "  make_forked_clusters()\n", 
#&gt;                 "\n", "  observeEvent(input$ok, {\n", "    with_progress({\n", 
#&gt;                 "      p &lt;- progressor(along = 1:100)\n", "      y &lt;- future.apply::future_lapply(1:100, function(x) {\n", 
#&gt;                 "        p(sprintf(\"Input %d|Result %d\", x, x+1))\n", 
#&gt;                 "        Sys.sleep(1)\n", "        x+1\n", "      })\n", 
#&gt;                 "    })\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n", 
#&gt;                 "\n"), "\n"), iapply.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/apply.R", 
#&gt;             "\n", list("iapply"), "\n", list("iapply"), "\n", 
#&gt;             list("Apply each elements with index as second input"), 
#&gt;             "\n", list("\n", "iapply(X, FUN, ..., .method = c(\"sapply\", \"lapply\", \"vapply\"))\n"), 
#&gt;             "\n", list("\n", list(list("X"), list("a vector (atomic or list)")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("the function to be applied to each element of ", 
#&gt;                   list("X"), ": see `Details`.")), "\n", "\n", 
#&gt;                 list(list("..."), list("passed to apply methods")), 
#&gt;                 "\n", "\n", list(list(".method"), list("method to use, default is ", 
#&gt;                   list(list("sapply")))), "\n"), "\n", list("\n", 
#&gt;                 "a list or matrix depends on ", list(".method"), 
#&gt;                 ". See ", list(list("lapply")), "\n"), "\n", 
#&gt;             list("\n", "Apply function with an index variable as the second input.\n"), 
#&gt;             "\n", list("\n", list("FUN"), " will be further passed to the apply methods. Unlike\n", 
#&gt;                 list(list("lapply")), ", ", list("FUN"), " is expected to have at least two arguments.\n", 
#&gt;                 "The first argument is each element of ", list(
#&gt;                   "X"), ", the second argument is the\n", "index number of the element.\n"), 
#&gt;             "\n"), lapply_async2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels-future.R", 
#&gt;             "\n", list("lapply_async2"), "\n", list("lapply_async2"), 
#&gt;             "\n", list("Apply, but in parallel"), "\n", list(
#&gt;                 "\n", "lapply_async2(\n", "  x,\n", "  FUN,\n", 
#&gt;                 "  FUN.args = list(),\n", "  callback = NULL,\n", 
#&gt;                 "  plan = TRUE,\n", "  future.chunk.size = NULL,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("vector, list")), "\n", "\n", list(
#&gt;                 list("FUN"), list("function to apply on each element of ", 
#&gt;                   list("x"))), "\n", "\n", list(list("FUN.args"), 
#&gt;                 list("more arguments to feed into ", list("FUN"))), 
#&gt;                 "\n", "\n", list(list("callback"), list("function to run after each iteration")), 
#&gt;                 "\n", "\n", list(list("plan"), list("logical, or character or ", 
#&gt;                   list("future"), " plan; see Details.")), "\n", 
#&gt;                 "\n", list(list("future.chunk.size"), list("see also\n", 
#&gt;                   list(list("future_eapply")), ". If you want the callbacks\n", 
#&gt;                   "to be called immediately after each loop, then set it to ", 
#&gt;                   list("1"), ",\n", "which is not optimal but the only way right now.")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("plan")))), "\n"), "\n", list("\n", 
#&gt;                 "same as\n", list("with(FUN.args, lapply(x, function(el){eval(body(FUN))}))"), 
#&gt;                 "\n"), "\n", list("\n", "Apply, but in parallel\n"), 
#&gt;             "\n", list("\n", "When ", list("plan"), " is logical, ", 
#&gt;                 list("FALSE"), " means use current plan.\n", 
#&gt;                 "If ", list("plan=TRUE"), ", then it equals to ", 
#&gt;                 list("plan='multicore'"), ". For\n", "characters, ", 
#&gt;                 list("plan"), " can be ", list("'multicore'"), 
#&gt;                 ", ", list("'callr'"), ",\n", list("'sequential'"), 
#&gt;                 ", ", list("'multisession'"), ", ", list("'multiprocess'"), 
#&gt;                 ",\n", "etc. Alternatively, you could pass future ", 
#&gt;                 list(list("plan")), "\n", "objects.\n"), "\n", 
#&gt;             list("\n", "\n", "library(future)\n", "plan(sequential)\n", 
#&gt;                 "\n", "# Use sequential plan\n", "# 1. Change `plan` to 'multicore', 'multisession', or TRUE to enable\n", 
#&gt;                 "# multi-core, but still with progress information\n", 
#&gt;                 "# 2. Change plan=FALSE will use current future plan\n", 
#&gt;                 "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = function(e){\n", 
#&gt;                 "  sprintf('Input=%d', e)\n", "}, plan = 'sequential')\n", 
#&gt;                 "\n", "# Disable callback message, then the function reduce to\n", 
#&gt;                 "# normal `future.apply::future_lapply`\n", "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = NULL, plan = FALSE)\n", 
#&gt;                 "\n", "\n"), "\n"), lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lock.R", 
#&gt;             "\n", list("lock"), "\n", list("lock"), "\n", list(
#&gt;                 "dipsaus_lock"), "\n", list("dipsaus_unlock"), 
#&gt;             "\n", list("Create or Unlock a Lock"), "\n", list(
#&gt;                 "\n", "dipsaus_lock(name, exclusive = TRUE, timeout = 10)\n", 
#&gt;                 "\n", "dipsaus_unlock(name, exclusive = TRUE, timeout = 10)\n"), 
#&gt;             "\n", list("\n", list(list("name"), list("character, the locker's name, must be only letters and digits")), 
#&gt;                 "\n", "\n", list(list("exclusive"), list("logical whether the locker is exclusive. True for write\n", 
#&gt;                   "access, False for read access. Default is true.")), 
#&gt;                 "\n", "\n", list(list("timeout"), list("numeric, seconds to wait for the locker to lock or unlock")), 
#&gt;                 "\n"), "\n", list("\n", "Logical, whether the operation succeed.\n"), 
#&gt;             "\n", list("\n", "A wrapper for ", list(list("lock")), 
#&gt;                 ", but user can\n", "interrupt the lock procedure anytime, and don't have to worry about\n", 
#&gt;                 "whether the lock exists or not.\n"), "\n", list(
#&gt;                 "\n", "# unlock to prepare for the example\n", 
#&gt;                 "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "# Create a locker, return TRUE\n", "lock_success = dipsaus_lock('testlocker')\n", 
#&gt;                 "if(lock_success){\n", "  cat2('testlocker has been locked')\n", 
#&gt;                 "}\n", "\n", "# test whether locker has been locked\n", 
#&gt;                 "lock_success = dipsaus_lock('testlocker', timeout = 0.01)\n", 
#&gt;                 "if(!lock_success){\n", "  cat2('attempt to lock testlocker failed')\n", 
#&gt;                 "}\n", "\n", "# unlock\n", "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "\n"), "\n"), make_async_evaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("make_async_evaluator"), "\n", list("make_async_evaluator"), 
#&gt;             "\n", list("Create Asynchronous Evaluator to Queue Tasks"), 
#&gt;             "\n", list("\n", "make_async_evaluator(\n", "  name,\n", 
#&gt;                 "  path = tempfile(),\n", "  n_nodes = 1,\n", 
#&gt;                 "  n_subnodes = future::availableCores() - 1,\n", 
#&gt;                 "  verbose = FALSE,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("name"), list("unique name for the evaluator")), 
#&gt;                 "\n", "\n", list(list("path"), list("blank directory for evaluator to store data")), 
#&gt;                 "\n", "\n", list(list("n_nodes"), list("number of control nodes, default is 1")), 
#&gt;                 "\n", "\n", list(list("n_subnodes"), list("number of sub-sessions for each control node, default is\n", 
#&gt;                   "the number of CPU cores minus 1")), "\n", 
#&gt;                 "\n", list(list("verbose"), list("for internal debug use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to the constructor of ", 
#&gt;                   list(list("MasterEvaluator")))), "\n"), "\n", 
#&gt;             list("\n", "Asynchronous evaluator aims at queuing R evaluations from sub-processes\n", 
#&gt;                 "without blocking the main session. It's based on ", 
#&gt;                 list("'parallel'"), " and\n", list("'future'"), 
#&gt;                 " packages.\n"), "\n", list("\n", list("'parallel'"), 
#&gt;                 " blocks the main session when evaluating expressions.\n", 
#&gt;                 list("'future'"), " blocks the main session when the number of running futures\n", 
#&gt;                 "exceed the maximum number of workers. (For example if 4 workers are planned,\n", 
#&gt;                 "then running 5 future instances at the same time will freeze the session).\n", 
#&gt;                 "\n", "Asynchronous evaluator is designed to queue any number of R expressions\n", 
#&gt;                 "without blocking the main session. The incoming expressions are stored in\n", 
#&gt;                 list(list("AbstractQueue")), " instances, and main session monitors\n", 
#&gt;                 "the queue and is charge of notifying child sessions to evaluate these\n", 
#&gt;                 "expressions whenever available.\n", "\n", "Important: Asynchronous evaluator is not designed for super high-performance\n", 
#&gt;                 "computing. The internal scheduler schedules ", 
#&gt;                 list("n_nodes"), " evaluations for\n", "every 1 second. Therefore if each of the process can be finished within\n", 
#&gt;                 list("1 / n_nodes"), " seconds, then use `future` instead.\n"), 
#&gt;             "\n", list(list("Value"), list("\n", "\n", "\n", 
#&gt;                 "A list of functions to control the evaluator:\n", 
#&gt;                 "\n", list("\n", "\n", list(list(list("run(expr, success = NULL, failure = NULL, priority = 0,\n", 
#&gt;                   "persist = FALSE, quoted = FALSE, ..., .list = NULL)")), 
#&gt;                   list("\n", "Queue and run an R expression.\n", 
#&gt;                     "\n", list("\n", "\n", list(list(list("expr")), 
#&gt;                       list("\n", " can be anything except for\n", 
#&gt;                         list("q()"), ", which terminates the session. ", 
#&gt;                         list("'rlang'"), "\n", list(list("nse-force")), 
#&gt;                         " is also supported. For example, you\n", 
#&gt;                         "can use ", list("`!!`"), " to quasi-quote the expression and unquote the values.\n")), 
#&gt;                       "\n", "\n", list(list(list("..., .list")), 
#&gt;                         list("\n", "provides additional data for ", 
#&gt;                           list("expr"), ". For example,\n", list(
#&gt;                             "expr"), " uses a large data object ", 
#&gt;                           list("dat"), " in the main session, which\n", 
#&gt;                           "might not be available to the child sessions. Also because the object\n", 
#&gt;                           "is large, quasi-quotation could be slow or fail. By passing ", 
#&gt;                           list("dat=..."), "\n", "or ", list(
#&gt;                             ".list=list(dat=...)"), ", it's able to temporary store the data on\n", 
#&gt;                           "hard-drive and persist for evaluators. The back-end is using\n", 
#&gt;                           list(list("qs_map")), ", which is super fast for data that are no\n", 
#&gt;                           "more than ", list("2GB"), ".\n")), 
#&gt;                       "\n", "\n", list(list(list("success"), 
#&gt;                         " and ", list("failure")), list("\n", 
#&gt;                         "functions to handle the results once\n", 
#&gt;                         "the evaluator returns the value. Since it's almost impossible to know\n", 
#&gt;                         "when the evaluator returns values, it's recommended that these functions\n", 
#&gt;                         "to be simple.\n")), "\n", "\n", list(
#&gt;                         list(list("priority")), list("\n", "puts the priority of the expression. It can only be `0` or\n", 
#&gt;                           "`1`. Evaluators will run expressions with priority equal to 1 first.\n")), 
#&gt;                       "\n", "\n", list(list(list("persist")), 
#&gt;                         list("\n", "indicates whether to run the expression and persist\n", 
#&gt;                           "intermediate variables.\n")), "\n"), 
#&gt;                     "\n")), "\n", "\n", list(list(list("terminate()")), 
#&gt;                   list("\n", "Shut down and release all the resource.\n")), 
#&gt;                   "\n", "\n", list(list(list("scale_down(n_nodes, n_subnodes = 1)"), 
#&gt;                     ",\n", "      ", list("scale_up(n_nodes, n_subnodes = 1,\n", 
#&gt;                       "      create_if_missing = FALSE, path = tempfile())")), 
#&gt;                     list("\n", "Scale down or up the evaluator.\n", 
#&gt;                       list("\n", list(list(list("n_nodes"), " and ", 
#&gt;                         list("n_subnodes")), list(" see 'usage' ")), 
#&gt;                         "\n", list(list(list("create_if_missing")), 
#&gt;                           list("\n", "If the evaluator was previously terminated or shutdown, setting this to be\n", 
#&gt;                             "true ignores the `invalid` flags and re-initialize the evaluator\n")), 
#&gt;                         "\n", list(list(list("path")), list("\n", 
#&gt;                           "If ", list("create_if_missing"), " is true, then ", 
#&gt;                           list("path"), " will be passed to\n", 
#&gt;                           "the constructor of ", list(list("MasterEvaluator")), 
#&gt;                           ". See 'usage'.\n")), "\n"), "\n")), 
#&gt;                   "\n", "\n", "\n", list(list(list("workers(...)")), 
#&gt;                     list("\n", "Returns number of workers available in the evaluator. ", 
#&gt;                       list("`...`"), " is for\n", "debug use\n")), 
#&gt;                   "\n", "\n", list(list(list("progress()")), 
#&gt;                     list("\n", "Returns a vector of 4 integers. They are:\n", 
#&gt;                       list("\n", list(), list(" The total number evaluations. "), 
#&gt;                         "\n", list(), list(" Number of running evaluations. "), 
#&gt;                         "\n", list(), list(" Number of awaiting evaluations. "), 
#&gt;                         "\n", list(), list(" Number of finished evaluations. "), 
#&gt;                         "\n"), "\n")), "\n", "\n"), "\n")), "\n", 
#&gt;             "\n"), make_forked_clusters.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels.R", 
#&gt;             "\n", list("make_forked_clusters"), "\n", list("make_forked_clusters"), 
#&gt;             "\n", list("Create forked clusters"), "\n", list(
#&gt;                 "\n", "make_forked_clusters(\n", "  workers = future::availableCores(constraints = \"multicore\"),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "workers"), list("positive integer, number of cores to use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passing to ", 
#&gt;                   list("future::plan"))), "\n"), "\n", list("\n", 
#&gt;                 "number of cores\n"), "\n", list("\n", "Create forked clusters\n"), 
#&gt;             "\n", list("\n", "This is a wrapper for ", list("future::plan(future::multicore, ...)"), 
#&gt;                 ".\n", "However, since version 1.14.0, forked clusters are disabled in `RStudio` by\n", 
#&gt;                 "default, and you usually need to enable it manually. This function provides\n", 
#&gt;                 "a simple way of enable it and plan the future at the same time.\n"), 
#&gt;             "\n"), map.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-s3.R", 
#&gt;             "\n", list("map"), "\n", list("map"), "\n", list(
#&gt;                 "session_map"), "\n", list("rds_map"), "\n", 
#&gt;             list("text_map"), "\n", list("qs_map"), "\n", list(
#&gt;                 "redis_map"), "\n", list("Create R object map."), 
#&gt;             "\n", list("\n", "session_map(map = fastmap::fastmap())\n", 
#&gt;                 "\n", "rds_map(path = tempfile())\n", "\n", "text_map(path = tempfile())\n", 
#&gt;                 "\n", "qs_map(path = tempfile())\n", "\n", "redis_map(name = rand_string())\n"), 
#&gt;             "\n", list("\n", list(list("map"), list("a ", list(
#&gt;                 "fastmap::fastmap()"), " list")), "\n", "\n", 
#&gt;                 list(list("path"), list("directory path where map data should be stored")), 
#&gt;                 "\n", "\n", list(list("name"), list("character, map name. If map names are the same, the data\n", 
#&gt;                   "will be shared.")), "\n"), "\n", list("\n", 
#&gt;                 "An ", list("R6"), " instance that inherits ", 
#&gt;                 list(list("AbstractMap")), "\n"), "\n", list(
#&gt;                 "\n", "Provides five types of map that fit in different use cases.\n"), 
#&gt;             "\n", list("\n", "There are five types of map implemented. They all inherit class\n", 
#&gt;                 list(list("AbstractMap")), ". There are several differences in\n", 
#&gt;                 "use case scenarios and they backend implementations.\n", 
#&gt;                 "\n", list("\n", list(list(list(list("session_map"))), 
#&gt;                   list("\n", "A session map takes a ", list(list(
#&gt;                     "fastmap")), " object. All objects are\n", 
#&gt;                     "stored in current R session. This means you cannot access the map from other\n", 
#&gt;                     "process nor parent process. The goal of this map is to share the data across\n", 
#&gt;                     "different environments and to store global variables, as long as they share\n", 
#&gt;                     "the same map object. If you are looking for maps that can be shared\n", 
#&gt;                     "by different processes, check the rest map types. The closest map type is\n", 
#&gt;                     list("redis_map"), ", which is also memory-based.\n")), 
#&gt;                   "\n", list(list(list(list("rds_map"))), list(
#&gt;                     "\n", "An 'RDS' map uses file system to store values. The values are stored\n", 
#&gt;                     "separately in '.rds' files. Compared to session maps, 'RDS' map can be\n", 
#&gt;                     "shared across different R process. It's recommended to store\n", 
#&gt;                     "large files in ", list("rds_map"), ". If the value is not large in RAM,\n", 
#&gt;                     list("text_map"), " and ", list("redis_map"), 
#&gt;                     " are recommended.\n")), "\n", list(list(
#&gt;                     list(list("qs_map"))), list("\n", "A 'qs' map uses package 'qs' as backend. This map is very similar to\n", 
#&gt;                     list("rds_map"), ", but is especially designed for large values. For example,\n", 
#&gt;                     "pushing 1GB data to ", list("qs_map"), " will be 100 times faster than using\n", 
#&gt;                     list("rds_map"), ", and ", list("text_map"), 
#&gt;                     " will almost fail. However, compared\n", 
#&gt;                     "to ", list("rds_map"), " the stored data cannot be normally read by R as they\n", 
#&gt;                     "are compressed binary files. And ", list(
#&gt;                       "qs_map"), " is heavier than\n", list("text_map"), 
#&gt;                     ".\n")), "\n", list(list(list(list("text_map"))), 
#&gt;                     list("\n", "A 'text' map uses file system to store values. Similar to ", 
#&gt;                       list("rds_map"), ",\n", "it can be stored across multiple processes as long as the maps share the\n", 
#&gt;                       "same file directory. However, unlike ", 
#&gt;                       list("rds_map"), ", ", list("text_map"), 
#&gt;                       "\n", "the ", list("text_map"), " can only store basic data values, namely atom data types.\n", 
#&gt;                       "The supported types are: numeric, character, vector, list, matrix\n", 
#&gt;                       "It's highly recommended to convert factors to characters. Do NOT use if the\n", 
#&gt;                       "values are functions or environments. Please check\n", 
#&gt;                       list(list("write_yaml")), " for details. The recommended use case scenario\n", 
#&gt;                       "is when the speed is not the major concern, and you want to preserve data\n", 
#&gt;                       "with backward compatibility. Otherwise it's highly recommended to use\n", 
#&gt;                       list("redis_map"), ", ", list("qs_map"), 
#&gt;                       ", and ", list("rds_map"), ".\n")), "\n", 
#&gt;                   list(list(list(list("redis_map"))), list("\n", 
#&gt;                     "A 'Redis' map uses free open source software `Redis` and R package\n", 
#&gt;                     "'RcppRedis' as backend. Compared to session map, 'Redis' map can be\n", 
#&gt;                     "shared across sessions. Compared to 'text' and 'rds' maps, 'Redis' map\n", 
#&gt;                     "stores data in memory, meaning a potential of significant speed ups. To use\n", 
#&gt;                     list("redis_map"), ", you need to install `Redis` on your computer.\n", 
#&gt;                     list("\n", "  ", list(), " On Mac: use `", 
#&gt;                       list("brew install redis"), "` to install and\n", 
#&gt;                       "    `", list("brew services start redis"), 
#&gt;                       "` to start the service\n", "  ", list(), 
#&gt;                       " On Linux: use `", list("sudo apt-get install redis-server"), 
#&gt;                       "` to install\n", "    and `", list("sudo systemctl enable redis-server.service"), 
#&gt;                       "` to start the\n", "    service\n", "  ", 
#&gt;                       list(), " On Windows: Download from\n", 
#&gt;                       "    ", list("https://github.com/dmajkic/redis/downloads"), 
#&gt;                       " and double click\n", "    'redis-server.exe'\n"), 
#&gt;                     "\n")), "\n"), "\n"), "\n", list("\n", "# ----------------------Basic Usage ----------------------\n", 
#&gt;                 "\n", "# Define a path to your map.\n", "path = tempfile()\n", 
#&gt;                 "map &lt;- qs_map(path)\n", "\n", "# Reset\n", "map$reset()\n", 
#&gt;                 "\n", "# Check if the map is corrupted.\n", "map$validate()\n", 
#&gt;                 "\n", "# You have not set any key-value pairs yet.\n", 
#&gt;                 "# Let's say two parallel processes (A and B) are sharing this map.\n", 
#&gt;                 "# Process A set values\n", "map$keys()\n", "\n", 
#&gt;                 "# Start push\n", "# set a normal message\n", 
#&gt;                 "map$set(key = 'a', value = 1)\n", "\n", "# set a large object\n", 
#&gt;                 "map$set(key = 'b', value = rnorm(100000))\n", 
#&gt;                 "\n", "# set an object with hash of another object\n", 
#&gt;                 "map$set(key = 'c', value = 2, signature = list(\n", 
#&gt;                 "  parameter1 = 123,\n", "  parameter2 = 124\n", 
#&gt;                 "))\n", "\n", "# Check what's in the map from process B\n", 
#&gt;                 "mapB &lt;- qs_map(path)\n", "mapB$keys()\n", "mapB$keys(include_signatures = TRUE)\n", 
#&gt;                 "\n", "# Number of key-values pairs in the map.\n", 
#&gt;                 "mapB$size()\n", "\n", "# Check if key exists\n", 
#&gt;                 "mapB$has(c('1','a', 'c'))\n", "\n", "# Check if key exists and signature also matches\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 123,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Signature changed, then return FALSE. This is especially useful when\n", 
#&gt;                 "# value is really large and reading the value takes tons of time\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 1244444,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Destroy the map's files altogether.\n", 
#&gt;                 "mapB$destroy()\n", "\n", list("\n", "  # Once destroyed, validate will raise error\n", 
#&gt;                   "  mapB$validate()\n"), "\n", "\n", "\n"), 
#&gt;             "\n"), match_calls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("match_calls"), "\n", list("match_calls"), 
#&gt;             "\n", list("Recursively match calls and modify arguments"), 
#&gt;             "\n", list("\n", "match_calls(\n", "  call,\n", "  recursive = TRUE,\n", 
#&gt;                 "  replace_args = list(),\n", "  quoted = FALSE,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("an ", list(
#&gt;                 "R"), " expression")), "\n", "\n", list(list(
#&gt;                 "recursive"), list("logical, recursively match calls, default is true")), 
#&gt;                 "\n", "\n", list(list("replace_args"), list("named list of functions, see examples")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("logical, is ", 
#&gt;                   list("call"), " quoted")), "\n", "\n", list(
#&gt;                   list("envir"), list("which environment should call be evaluated")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters passing to ", 
#&gt;                   list("match.call"))), "\n"), "\n", list("\n", 
#&gt;                 "A nested call with all arguments matched\n"), 
#&gt;             "\n", list("\n", "Recursively match calls and modify arguments\n"), 
#&gt;             "\n", list("\n", "library(dipsaus); library(shiny)\n", 
#&gt;                 "\n", "# In shiny modules, we might want to add ns() to inputIds\n", 
#&gt;                 "# In this example, textInput(id) will become textInput(ns(id))\n", 
#&gt;                 "match_calls(lapply(1:20, function(i){\n", "  textInput(paste('id_', i), paste('Label ', i))\n", 
#&gt;                 "}), replace_args = list(\n", "  inputId = function(arg, call){ as.call(list(quote(ns), arg)) }\n", 
#&gt;                 "))\n", "\n"), "\n"), mem_limit2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("mem_limit2"), "\n", list("mem_limit2"), 
#&gt;             "\n", list("Get max RAM size\n", "This is an experimental function that is designed for non-windows systems"), 
#&gt;             "\n", list("\n", "mem_limit2()\n"), "\n", list("\n", 
#&gt;                 "a list of total free memory.\n"), "\n", list(
#&gt;                 "\n", "Get max RAM size\n", "This is an experimental function that is designed for non-windows systems\n"), 
#&gt;             "\n"), no_op.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("no_op"), "\n", list("no_op"), "\n", list(
#&gt;                 "Pipe-friendly no-operation function"), "\n", 
#&gt;             list("\n", "no_op(.x, .expr, ..., .check_fun = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("any R object")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression that produces side effects")), 
#&gt;                 "\n", "\n", list(list("..., .check_fun"), list(
#&gt;                   "see `details`")), "\n"), "\n", list("\n", 
#&gt;                 "The value of ", list(".x"), "\n"), "\n", list(
#&gt;                 "\n", "returns the first input with side effects\n"), 
#&gt;             "\n", list("\n", list("no_op"), " is a pipe-friendly function that takes any values in,\n", 
#&gt;                 "evaluate expressions but still returns input. This is very useful when\n", 
#&gt;                 "you have the same input across multiple functions and you want to use pipes.\n", 
#&gt;                 "\n", list(".expr"), " is evaluated with a special object ", 
#&gt;                 list("'.'"), ", you can use\n", list("'.'"), 
#&gt;                 " to represent ", list(".x"), " in ", list(".expr"), 
#&gt;                 ". For example, if\n", list(".x=1:100"), ", then ", 
#&gt;                 list("plot(x=seq(0,1,length.out = 100), y=.)"), 
#&gt;                 " is\n", "equivalent to ", list("plot(x=seq(0,1,length.out = 100), y=1:100)"), 
#&gt;                 ".\n", "\n", list(".check_fun"), " checks whether ", 
#&gt;                 list(".expr"), " returns a function, if yes,\n", 
#&gt;                 "then the function is called with argument ", 
#&gt;                 list(".x"), " and ", list("..."), "\n"), "\n", 
#&gt;             list("\n", "\n", "library(magrittr)\n", "\n", "## 1. Basic usage\n", 
#&gt;                 "\n", "# Will print('a') and return 'a'\n", "no_op('a', print)\n", 
#&gt;                 "\n", "# Will do nothing and return 'a' because .check_fun is false\n", 
#&gt;                 "no_op('a', print, .check_fun = FALSE)\n", "\n", 
#&gt;                 "# Will print('a') and return 'a'\n", "no_op('a', print(.), .check_fun = FALSE)\n", 
#&gt;                 "\n", "## 2. Toy example\n", "library(graphics)\n", 
#&gt;                 "\n", "par(mfrow = c(2,2))\n", "x &lt;- rnorm(100)\n", 
#&gt;                 "\n", "# hist and plot share the same input `rnorm(100)`\n", 
#&gt;                 "\n", "x %&gt;%\n", "  # .expr is a function, all ... are passed as other arguments\n", 
#&gt;                 "  no_op( hist, nclass = 10 ) %&gt;%\n", "  no_op( plot, x = seq(0,1,length.out = 100) ) %&gt;%\n", 
#&gt;                 "\n", "  # Repeat the previous two plots, but with different syntax\n", 
#&gt;                 "  no_op({ hist(., nclass = 10) }) %&gt;%\n", "  no_op({ plot(x = seq(0,1,length.out = 100), y = .) }) %&gt;%\n", 
#&gt;                 "\n", "  # The return statement is ignored\n", 
#&gt;                 "\n", "  no_op({ return(x + 1)}) -&gt;\n", "  y\n", 
#&gt;                 "\n", "# x is returned at the end\n", "\n", "identical(x, y)   # TRUE\n", 
#&gt;                 "\n"), "\n"), package_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("package_installed"), "\n", list("package_installed"), 
#&gt;             "\n", list("Check if a package is installed"), "\n", 
#&gt;             list("\n", "package_installed(pkgs, all = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("pkgs"), list("vector of package names")), 
#&gt;                 "\n", "\n", list(list("all"), list("only returns TRUE if all packages are installed. Default is FALSE.")), 
#&gt;                 "\n"), "\n", list("\n", "logical, if packages are installed or not. If ", 
#&gt;                 list("all=TRUE"), ", return\n", "a logical value of whether all packages a re installed.\n"), 
#&gt;             "\n", list("\n", "Check if a package is installed\n"), 
#&gt;             "\n", list("\n", "\n", "# Check if package base and dipsaus are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'))\n", 
#&gt;                 "\n", "# Check if all required packages are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'), all = TRUE)\n", 
#&gt;                 "\n"), "\n"), parse_svec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("parse_svec"), "\n", list("parse_svec"), 
#&gt;             "\n", list("Parse Text Into Numeric Vectors\n", "\n", 
#&gt;                 "(stable)"), "\n", list("\n", "parse_svec(text, sep = \",\", connect = \"-:|\", sort = FALSE, unique = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("text"), list("string with chunks, e.g. ", 
#&gt;                 list("\"1-10, 14, 16-20, 18-30\""), " has 4 chunks")), 
#&gt;                 "\n", "\n", list(list("sep"), list("default is \",\", character used to separate chunks")), 
#&gt;                 "\n", "\n", list(list("connect"), list("characters defining connection links for example \"1:10\" is the same as \"1-10\"")), 
#&gt;                 "\n", "\n", list(list("sort"), list("sort the result")), 
#&gt;                 "\n", "\n", list(list("unique"), list("extract unique elements")), 
#&gt;                 "\n"), "\n", list("\n", "a numeric vector. For example, \"1-3\" returns ", 
#&gt;                 list("c(1, 2, 3)"), "\n"), "\n", list("\n", "Parse Text Into Numeric Vectors\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "parse_svec('1-10, 13:15,14-20')\n"), 
#&gt;             "\n", list("\n", list(list("deparse_svec")), "\n"), 
#&gt;             "\n"), prepare_install.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("prepare_install"), "\n", list("prepare_install"), 
#&gt;             "\n", list("Install Packages at Next Startup"), "\n", 
#&gt;             list("\n", "prepare_install(\n", "  packages,\n", 
#&gt;                 "  update_all = FALSE,\n", "  restart = FALSE,\n", 
#&gt;                 "  repos = getOption(\"repos\")\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("packages"), list("characters, vector of package names")), 
#&gt;                 "\n", "\n", list(list("update_all"), list("whether to update all installed packages before\n", 
#&gt;                   "installation; default is false")), "\n", "\n", 
#&gt;                 list(list("restart"), list("whether to restart session automatically")), 
#&gt;                 "\n", "\n", list(list("repos"), list("repositories to search for packages")), 
#&gt;                 "\n"), "\n", list("\n", "None\n"), "\n", list(
#&gt;                 "\n", "Register temporary code that will install packages at\n", 
#&gt;                 "next session. The code will be automatically removed once executed.\n"), 
#&gt;             "\n", list("\n", "Installing packages in R session could require restarts if\n", 
#&gt;                 "a package to be updated has been loaded. Normally restarting R\n", 
#&gt;                 "fixes the problem. However, under some circumstances, such as with a\n", 
#&gt;                 "startup code in profile, restarting R might still fail the\n", 
#&gt;                 "installation. ", list("prepare_install"), " inserts the installation\n", 
#&gt;                 "code prior to the startup code so that next time the code will get\n", 
#&gt;                 "executed before any other packages are loaded.\n", 
#&gt;                 "Once the temporary code get executed, no matter succeeded or not,\n", 
#&gt;                 "it will be removed from startup profile.\n"), 
#&gt;             "\n"), progress2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("progress2"), "\n", list("progress2"), 
#&gt;             "\n", list("'Shiny' progress bar, but can run without reactive context"), 
#&gt;             "\n", list("\n", "progress2(\n", "  title,\n", "  max = 1,\n", 
#&gt;                 "  ...,\n", "  quiet = FALSE,\n", "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  shiny_auto_close = FALSE,\n", "  log = NULL\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("title"), 
#&gt;                 list("character, task description")), "\n", "\n", 
#&gt;                 list(list("max"), list("maximum number of items in the queue")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("shiny::Progress$new(...)"))), "\n", "\n", 
#&gt;                 list(list("quiet"), list("suppress console output, ignored in shiny context.")), 
#&gt;                 "\n", "\n", list(list("session"), list("'shiny' session, default is current reactive domain")), 
#&gt;                 "\n", "\n", list(list("shiny_auto_close"), list(
#&gt;                   "logical, automatically close 'shiny' progress bar\n", 
#&gt;                   "once current observer is over. Default is ", 
#&gt;                   list("FALSE"), ". If setting to\n", list("TRUE"), 
#&gt;                   ", then it's equivalent to\n", list("p &lt;- progress2(...); on.exit({p$close()}, add = TRUE)"), 
#&gt;                   ".")), "\n", "\n", list(list("log"), list("function when running locally, default is ", 
#&gt;                   list("NULL"), ",\n", "which redirects to ", 
#&gt;                   list(list("cat2")))), "\n"), "\n", list("\n", 
#&gt;                 "A list of functions:\n", list("\n", list(list(
#&gt;                   list("inc(detail, message = NULL, amount = 1, ...)")), 
#&gt;                   list("\n", "Increase progress bar by ", list(
#&gt;                     "amount"), " (default is 1).\n")), "\n", 
#&gt;                   list(list(list("close()")), list("\n", "Close the progress\n")), 
#&gt;                   "\n", list(list(list("reset(detail = '', message = '', value = 0)")), 
#&gt;                     list("\n", "Reset the progress to ", list(
#&gt;                       "value"), " (default is 0), and reset information\n")), 
#&gt;                   "\n", list(list(list("get_value()")), list(
#&gt;                     "\n", "Get current progress value\n")), "\n", 
#&gt;                   list(list(list("is_closed()")), list("\n", 
#&gt;                     "Returns logical value if the progress is closed or not.\n")), 
#&gt;                   "\n"), "\n"), "\n", list("\n", "'Shiny' progress bar, but can run without reactive context\n"), 
#&gt;             "\n", list("\n", "\n", "progress &lt;- progress2('Task A', max = 2)\n", 
#&gt;                 "progress$inc('Detail 1')\n", "progress$inc('Detail 2')\n", 
#&gt;                 "progress$close()\n", "\n", "# Check if progress is closed\n", 
#&gt;                 "progress$is_closed()\n", "\n", "# ------------------------------ Shiny Example ------------------------------\n", 
#&gt;                 "library(shiny)\n", "library(dipsaus)\n", "\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  actionButtonStyled('do', 'Click Here', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    updateActionButtonStyled(session, 'do', disabled = TRUE)\n", 
#&gt;                 "    progress &lt;- progress2('Task A', max = 10, shiny_auto_close = TRUE)\n", 
#&gt;                 "    lapply(1:10, function(ii){\n", "      progress$inc(sprintf('Detail %d', ii))\n", 
#&gt;                 "      Sys.sleep(0.2)\n", "    })\n", "    updateActionButtonStyled(session, 'do', disabled = FALSE)\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         registerInputBinding.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("registerInputBinding"), "\n", list("registerInputBinding"), 
#&gt;             "\n", list("Register customized input to enable support by compound input"), 
#&gt;             "\n", list("\n", "registerInputBinding(fname, pkg, shiny_binding, update_function = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("character, function name, such as ", 
#&gt;                 list("\"textInput\""))), "\n", "\n", list(list(
#&gt;                 "pkg"), list("character, package name, like ", 
#&gt;                 list("\"shiny\""))), "\n", "\n", list(list("shiny_binding"), 
#&gt;                 list("character, 'JavaScript' binding name.See examples")), 
#&gt;                 "\n", "\n", list(list("update_function"), list(
#&gt;                   "character, update function such as ", list(
#&gt;                     "\"shiny::textInput\""))), "\n"), "\n", list(
#&gt;                 "\n", "a list of binding functions, one is `JavaScript` object key in\n", 
#&gt;                 list("Shiny.inputBindings"), ", the other is `shiny` update function in R end.\n"), 
#&gt;             "\n", list("\n", "Register customized input to enable support by compound input\n"), 
#&gt;             "\n", list("\n", "\n", "# register shiny textInput\n", 
#&gt;                 "registerInputBinding('textInput', 'shiny',\n", 
#&gt;                 "                     'shiny.textInput', 'shiny::updateTextInput')\n", 
#&gt;                 "\n", "# Register shiny actionLink\n", "# In \"Shiny.inputbindings\", the binding name is \"shiny.actionButtonInput\",\n", 
#&gt;                 "# Shiny update function is \"shiny::updateActionButton\"\n", 
#&gt;                 "registerInputBinding('actionLink', 'shiny',\n", 
#&gt;                 "                     'shiny.actionButtonInput', 'shiny::updateActionButton')\n", 
#&gt;                 "\n"), "\n"), screenshot.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("screenshot"), "\n", list("screenshot"), 
#&gt;             "\n", list("Take a screenshot in shiny apps"), "\n", 
#&gt;             list("\n", "screenshot(inputId, session = shiny::getDefaultReactiveDomain())\n"), 
#&gt;             "\n", list("\n", list(list("inputId"), list("the input id where the screenshot should be")), 
#&gt;                 "\n", "\n", list(list("session"), list("shiny session")), 
#&gt;                 "\n"), "\n", list("\n", "None. However, the screenshot results can be accessed from\n", 
#&gt;                 "shiny input\n"), "\n", list("\n", "Take a screenshot of the whole page and save encoded\n", 
#&gt;                 list("DataURI"), " that can be accessed via ", 
#&gt;                 list("input[[inputId]]"), ".\n"), "\n", list(
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  tagList(\n", "    shiny::singleton(shiny::tags$head(\n", 
#&gt;                 "      shiny::tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"dipsaus/dipsaus.css\"),\n", 
#&gt;                 "      shiny::tags$script(src=\"dipsaus/dipsaus-dipterix-lib.js\")\n", 
#&gt;                 "    ))\n", "  ),\n", "  actionButtonStyled('do', 'Take Screenshot'),\n", 
#&gt;                 "  compoundInput2('group', label = 'Group', components = list(\n", 
#&gt;                 "    textInput('txt', 'Enter something here')\n", 
#&gt;                 "  ))\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    screenshot('screeshot_result')\n", 
#&gt;                 "  })\n", "  observeEvent(input$screeshot_result, {\n", 
#&gt;                 "    showModal(modalDialog(\n", "      tags$img(src = input$screeshot_result, width = '100%')\n", 
#&gt;                 "    ))\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         set_shiny_input.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("set_shiny_input"), "\n", list("set_shiny_input"), 
#&gt;             "\n", list("Set Shiny Input"), "\n", list("\n", "set_shiny_input(\n", 
#&gt;                 "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  inputId,\n", "  value,\n", "  priority = c(\"event\", \"deferred\", \"immediate\"),\n", 
#&gt;                 "  method = c(\"proxy\", \"serialize\", \"value\", \"expression\"),\n", 
#&gt;                 "  quoted = TRUE\n", ")\n"), "\n", list("\n", 
#&gt;                 list(list("session"), list("shiny session, see shiny ", 
#&gt;                   list(list("domains")))), "\n", "\n", list(list(
#&gt;                   "inputId"), list("character, input ID")), "\n", 
#&gt;                 "\n", list(list("value"), list("the value to assign")), 
#&gt;                 "\n", "\n", list(list("priority"), list("characters, options are \"event\", \"deferred\", and \"immediate\".\n", 
#&gt;                   "\"event\" and \"immediate\" are similar, they always fire changes. \"deferred\"\n", 
#&gt;                   "fire signals to other reactive/observers only when the input value has been\n", 
#&gt;                   "changed")), "\n", "\n", list(list("method"), 
#&gt;                   list("characters, options are \"proxy\", \"serialize\", \"value\",\n", 
#&gt;                     "\"expression\". \"proxy\" is recommended, other methods are experimental.")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("is value quoted? Only used when method is \"expression\"")), 
#&gt;                 "\n"), "\n", list("\n", "Shiny `input' object is read-only reactive list. When try to\n", 
#&gt;                 "assign values to input, errors usually occur. This method provides several\n", 
#&gt;                 "work-around to set values to input. Please use along with\n", 
#&gt;                 list(list("use_shiny_dipsaus")), ".\n"), "\n", 
#&gt;             list("\n", "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  # Register widgets\n", 
#&gt;                 "  use_shiny_dipsaus(),\n", "  actionButton('run', 'Set Input'),\n", 
#&gt;                 "  verbatimTextOutput('input_value')\n", ")\n", 
#&gt;                 "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  start = Sys.time()\n", "\n", "  output$input_value &lt;- renderPrint({\n", 
#&gt;                 "\n", "    now &lt;- input$key\n", "    now %?&lt;-% start\n", 
#&gt;                 "    cat('This app has been opened for ',\n", 
#&gt;                 "        difftime(now, start, units = 'sec'), ' seconds')\n", 
#&gt;                 "  })\n", "\n", "  observeEvent(input$run, {\n", 
#&gt;                 "    # setting input$key to Sys.time()\n", "    set_shiny_input(session, 'key', Sys.time())\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n"), 
#&gt;             "\n"), shift_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("shift_array"), "\n", list("shift_array"), 
#&gt;             "\n", list("Shift Array by Index"), "\n", list("\n", 
#&gt;                 "shift_array(x, shift_idx, shift_by, shift_amount)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("array, must have at least matrix")), 
#&gt;                 "\n", "\n", list(list("shift_idx"), list("which index is to be shifted")), 
#&gt;                 "\n", "\n", list(list("shift_by"), list("which dimension decides ", 
#&gt;                   list("shift_amount"))), "\n", "\n", list(list(
#&gt;                   "shift_amount"), list("shift amount along ", 
#&gt;                   list("shift_idx"))), "\n"), "\n", list("\n", 
#&gt;                 "Re-arrange arrays in parallel\n"), "\n", list(
#&gt;                 "\n", "A simple use-case for this function is to think of a matrix where each row\n", 
#&gt;                 "is a signal and columns stand for time. The objective is to align (time-lock)\n", 
#&gt;                 "each signal according to certain events. For each signal, we want to shift\n", 
#&gt;                 "the time points by certain amount.\n", "\n", 
#&gt;                 "In this case, the shift amount is defined by ", 
#&gt;                 list("shift_amount"), ", whose\n", "length equals to number of signals. ", 
#&gt;                 list("shift_idx=2"), " as we want to shift\n", 
#&gt;                 "time points (column, the second dimension) for each signal. ", 
#&gt;                 list("shift_by=1"), "\n", "because the shift amount is depend on the signal number.\n"), 
#&gt;             "\n", list("\n", "x &lt;- matrix(1:10, nrow = 2, byrow = TRUE)\n", 
#&gt;                 "z &lt;- shift_array(x, 2, 1, c(1,2))\n", "\n", 
#&gt;                 "y &lt;- NA * x\n", "y[1,1:4] = x[1,2:5]\n", "y[2,1:3] = x[2,3:5]\n", 
#&gt;                 "\n", "# Check if z ang y are the same\n", "z - y\n", 
#&gt;                 "\n", "# array case\n", "# x is Trial x Frequency x Time\n", 
#&gt;                 "x &lt;- array(1:27, c(3,3,3))\n", "\n", "# Shift time for each trial, amount is 1, -1, 0\n", 
#&gt;                 "shift_amount &lt;- c(1,-1,0)\n", "z &lt;- shift_array(x, 3, 1, shift_amount)\n", 
#&gt;                 "par(mfrow = c(3, 2))\n", "for( ii in 1:3 ){\n", 
#&gt;                 "  image(t(x[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Trial', ii))\n", "  image(t(z[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Shifted amount:', shift_amount[ii]))\n", 
#&gt;                 "}\n", "\n"), "\n"), sync_shiny_inputs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-syncInputs.R", 
#&gt;             "\n", list("sync_shiny_inputs"), "\n", list("sync_shiny_inputs"), 
#&gt;             "\n", list("Synchronize Shiny Inputs"), "\n", list(
#&gt;                 "\n", "sync_shiny_inputs(\n", "  input,\n", "  session,\n", 
#&gt;                 "  inputIds,\n", "  uniform = rep(\"I\", length(inputIds)),\n", 
#&gt;                 "  updates,\n", "  snap = 250\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("input, session"), list("shiny reactive objects")), 
#&gt;                 "\n", "\n", list(list("inputIds"), list("input ids to be synchronized")), 
#&gt;                 "\n", "\n", list(list("uniform"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", converting inputs\n", 
#&gt;                   "to a uniform values")), "\n", "\n", list(list(
#&gt;                   "updates"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", updating input values")), 
#&gt;                 "\n", "\n", list(list("snap"), list("numeric, milliseconds to defer the changes")), 
#&gt;                 "\n"), "\n", list("\n", "none.\n"), "\n", list(
#&gt;                 "\n", "Synchronize Shiny Inputs\n"), "\n", list(
#&gt;                 "\n", "\n", "library(shiny)\n", "\n", "ui &lt;- fluidPage(\n", 
#&gt;                 "  textInput('a', 'a', value = 'a'),\n", "  sliderInput('b', 'b', value = 1, min = 0, max = 1000)\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  sync_shiny_inputs(input, session, inputIds = c('a', 'b'), uniform = list(\n", 
#&gt;                 "    function(a){as.numeric(a)},\n", "    'I'\n", 
#&gt;                 "  ), updates = list(\n", "    function(a){updateTextInput(session, 'a', value = a)},\n", 
#&gt;                 "    function(b){updateSliderInput(session, 'b', value = b)}\n", 
#&gt;                 "  ))\n", "\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         time_delta.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("time_delta"), "\n", list("time_delta"), 
#&gt;             "\n", list("Calculate time difference and return a number"), 
#&gt;             "\n", list("\n", "time_delta(t1, t2, units = \"secs\")\n"), 
#&gt;             "\n", list("\n", list(list("t1"), list("time start")), 
#&gt;                 "\n", "\n", list(list("t2"), list("time end")), 
#&gt;                 "\n", "\n", list(list("units"), list("character, choices are ", 
#&gt;                   list("'secs'"), ", ", list("'mins'"), ", ", 
#&gt;                   list("'hours'"), ", and ", list("'days'"))), 
#&gt;                 "\n"), "\n", list("\n", "numeric difference of time in units specified\n"), 
#&gt;             "\n", list("\n", "Calculate time difference and return a number\n"), 
#&gt;             "\n", list("\n", "a = Sys.time()\n", "Sys.sleep(0.3)\n", 
#&gt;                 "b = Sys.time()\n", "\n", "time_delta(a, b) # In seconds, around 0.3\n", 
#&gt;                 "time_delta(a, b, 'mins') # in minutes, around 0.005\n", 
#&gt;                 "\n"), "\n"), to_datauri.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_datauri"), "\n", list("to_datauri"), 
#&gt;             "\n", list("Convert file to 'base64' format"), "\n", 
#&gt;             list("\n", "to_datauri(file, mime = \"\")\n"), "\n", 
#&gt;             list("\n", list(list("file"), list("file path")), 
#&gt;                 "\n", "\n", list(list("mime"), list("'mime' type, default is blank")), 
#&gt;                 "\n"), "\n", list("\n", "a 'base64' data string looks like ", 
#&gt;                 list("'data:;base64,AEF6986...'"), "\n"), "\n", 
#&gt;             list("\n", "Convert file to 'base64' format\n"), 
#&gt;             "\n"), to_ram_size.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_ram_size"), "\n", list("to_ram_size"), 
#&gt;             "\n", list("Convert bytes to KB, MB, GB,..."), "\n", 
#&gt;             list("\n", "to_ram_size(s, kb_to_b = 1000)\n"), "\n", 
#&gt;             list("\n", list(list("s"), list("size")), "\n", "\n", 
#&gt;                 list(list("kb_to_b"), list("how many bytes counts one KB, 1000 by default")), 
#&gt;                 "\n"), "\n", list("\n", "numeric equaling to ", 
#&gt;                 list("s"), " but formatted\n"), "\n", list("\n", 
#&gt;                 "Convert bytes to KB, MB, GB,...\n"), "\n"), 
#&gt;         updateActionButtonStyled.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("updateActionButtonStyled"), "\n", list(
#&gt;                 "updateActionButtonStyled"), "\n", list("Update styled action button"), 
#&gt;             "\n", list("\n", "updateActionButtonStyled(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  label = NULL,\n", "  icon = NULL,\n", 
#&gt;                 "  type = NULL,\n", "  disabled = NULL,\n", "  ...\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("session, inputId, label, icon"), 
#&gt;                 list("passed to ", list("shiny::updateActionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type to update")), 
#&gt;                 "\n", "\n", list(list("disabled"), list("whether to disable the button")), 
#&gt;                 "\n", "\n", list(list("..."), list("ignored")), 
#&gt;                 "\n"), "\n", list("\n", "none\n"), "\n", list(
#&gt;                 "\n", "Update styled action button\n"), "\n", 
#&gt;             list("\n", list(list("actionButtonStyled")), " for how to define the button.\n"), 
#&gt;             "\n"), updateCompoundInput2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("updateCompoundInput2"), "\n", list("updateCompoundInput2"), 
#&gt;             "\n", list("Update compound inputs"), "\n", list(
#&gt;                 "\n", "updateCompoundInput2(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  value = NULL,\n", "  ncomp = NULL,\n", 
#&gt;                 "  initialization = NULL,\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("session"), list("shiny session or session proxy")), 
#&gt;                 "\n", "\n", list(list("inputId"), list("character see ", 
#&gt;                   list("compoundInput2"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, see ", 
#&gt;                     list("compoundInput2"), " or examples")), 
#&gt;                 "\n", "\n", list(list("ncomp"), list("integer, non-negative number of groups to update, ", 
#&gt;                   list("NULL"), " to\n", "remain unchanged")), 
#&gt;                 "\n", "\n", list(list("initialization, ..."), 
#&gt;                   list("named list of other updates")), "\n"), 
#&gt;             "\n", list("\n", "none\n"), "\n", list("\n", "Update compound inputs\n"), 
#&gt;             "\n", list("\n", "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "\n", "## UI side\n", "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    '',                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "## server side:\n", "updateCompoundInput2(session, 'inputid',\n", 
#&gt;                 "                     # Change the first 3 groups\n", 
#&gt;                 "                     value = lapply(1:3, function(ii){\n", 
#&gt;                 "                       list(sli = runif(1))\n", 
#&gt;                 "                     }),\n", "                     # Change text label for all groups\n", 
#&gt;                 "                     initialization = list(\n", 
#&gt;                 "                       text = list(label = as.character(Sys.time()))\n", 
#&gt;                 "                     ))\n"), "\n", "\n"), "\n", 
#&gt;             list("\n", list(list("compoundInput2")), " for how to define components.\n"), 
#&gt;             "\n"), update_fastmap2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fastmap2.R", 
#&gt;             "\n", list("update_fastmap2"), "\n", list("update_fastmap2"), 
#&gt;             "\n", list("Migrate a ", list("fastmap2"), " object to a new one"), 
#&gt;             "\n", list("\n", "update_fastmap2(from, to, override = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("from, to"), list(list(
#&gt;                 "fastmap2"), " object")), "\n", "\n", list(list(
#&gt;                 "override"), list("whether to override keys in ", 
#&gt;                 list("to"), " if they exist")), "\n"), "\n", 
#&gt;             list("\n", "Map ", list("to"), "\n"), "\n", list(
#&gt;                 "\n", "Migrate a ", list("fastmap2"), " object to a new one\n"), 
#&gt;             "\n", list("\n", list(list("fastmap2")), "\n"), "\n"), 
#&gt;         use_shiny_dipsaus.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("use_shiny_dipsaus"), "\n", list("use_shiny_dipsaus"), 
#&gt;             "\n", list("Set up shiny plugins"), "\n", list("\n", 
#&gt;                 "use_shiny_dipsaus()\n"), "\n", list("\n", "This function must be called from a Shiny app's UI in order for\n", 
#&gt;                 "some widgets to work.\n"), "\n")), source = list(
#&gt;         AbstractMap.Rd = "R/map-abstract.R", AbstractQueue.Rd = "R/queue-abstract.R", 
#&gt;         MasterEvaluator.Rd = "R/parallels-workers.R", PersistContainer.Rd = "R/persist.R", 
#&gt;         actionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         ask_or_default.Rd = "R/strings.R", ask_yesno.Rd = "R/strings.R", 
#&gt;         async.Rd = "R/parallels.R", async_expr.Rd = "R/parallels.R", 
#&gt;         async_flapply.Rd = "R/parallels.R", base64_to_image.Rd = "R/screenshot.R", 
#&gt;         baseline_array.Rd = "R/cpp-baseline_array.R", cat2.Rd = "R/strings.R", 
#&gt;         check_installed_packages.Rd = "R/utils-package.R", col2hexStr.Rd = "R/strings.R", 
#&gt;         collapse.Rd = "R/cpp-collapse.R", compoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         decorate_function.Rd = "R/language.R", deparse_svec.Rd = "R/strings.R", 
#&gt;         dev_create.Rd = "R/graphics.R", do_aggregate.Rd = "R/apply.R", 
#&gt;         drop_nulls.Rd = "R/utils.R", eval_dirty.Rd = "R/language.R", 
#&gt;         fastmap2.Rd = "R/fastmap2.R", forelse.Rd = "R/apply.R", 
#&gt;         getInputBinding.Rd = "R/shiny-inputbindings.R", get_cpu.Rd = "R/systems.R", 
#&gt;         get_dots.Rd = "R/language.R", get_ram.Rd = "R/systems.R", 
#&gt;         `grapes-equals-greater-than-grapes.Rd` = "R/language.R", 
#&gt;         `grapes-help-set-grapes.Rd` = "R/language.R", `grapes-plus-grapes.Rd` = "R/language.R", 
#&gt;         handler_dipsaus_progress.Rd = "R/shiny-progress.R", iapply.Rd = "R/apply.R", 
#&gt;         lapply_async2.Rd = "R/parallels-future.R", lock.Rd = "R/lock.R", 
#&gt;         make_async_evaluator.Rd = "R/parallels-workers.R", make_forked_clusters.Rd = "R/parallels.R", 
#&gt;         map.Rd = "R/map-s3.R", match_calls.Rd = "R/language.R", 
#&gt;         mem_limit2.Rd = "R/strings.R", no_op.Rd = "R/language.R", 
#&gt;         package_installed.Rd = "R/utils-package.R", parse_svec.Rd = "R/strings.R", 
#&gt;         prepare_install.Rd = "R/utils-package.R", progress2.Rd = "R/shiny-progress.R", 
#&gt;         registerInputBinding.Rd = "R/shiny-inputbindings.R", 
#&gt;         screenshot.Rd = "R/screenshot.R", set_shiny_input.Rd = "R/shiny-setInputs.R", 
#&gt;         shift_array.Rd = "R/cpp-collapse.R", sync_shiny_inputs.Rd = "R/shiny-syncInputs.R", 
#&gt;         time_delta.Rd = "R/utils.R", to_datauri.Rd = "R/strings.R", 
#&gt;         to_ram_size.Rd = "R/strings.R", updateActionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         updateCompoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         update_fastmap2.Rd = "R/fastmap2.R", use_shiny_dipsaus.Rd = "R/shiny-setInputs.R"), 
#&gt;         keywords = list(character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0)), concepts = list(
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0)), internal = c(FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE)), tutorials = list(name = character(0), file_out = character(0), 
#&gt;         title = character(0), pagetitle = character(0), url = character(0)), 
#&gt;     vignettes = list(name = c("async_evaluator", "r_expr_addons", 
#&gt;     "shiny_customized_widgets", "utility_functions"), file_in = c("vignettes/async_evaluator.Rmd", 
#&gt;     "vignettes/r_expr_addons.Rmd", "vignettes/shiny_customized_widgets.Rmd", 
#&gt;     "vignettes/utility_functions.Rmd"), file_out = c("articles/async_evaluator.html", 
#&gt;     "articles/r_expr_addons.html", "articles/shiny_customized_widgets.html", 
#&gt;     "articles/utility_functions.html"), title = c("Asynchronous Evaluator", 
#&gt;     "R Expression Add-ons", "Shiny Customized Widgets", "Utility Functions"
#&gt;     ), description = c(NA_character_, NA_character_, NA_character_, 
#&gt;     NA_character_)), topic_index = c(`[.fastmap2` = "fastmap2", 
#&gt;     `[[.fastmap2` = "fastmap2", `[[&lt;-.fastmap2` = "fastmap2", 
#&gt;     `[&lt;-.fastmap2` = "fastmap2", `%?&lt;-%` = "grapes-help-set-grapes", 
#&gt;     `%+-%` = "grapes-plus-grapes", `%=&gt;%` = "grapes-equals-greater-than-grapes", 
#&gt;     `%D%` = "decorate_function", `$.fastmap2` = "fastmap2", `$&lt;-.fastmap2` = "fastmap2", 
#&gt;     AbstractMap = "AbstractMap", AbstractQueue = "AbstractQueue", 
#&gt;     actionButtonStyled = "actionButtonStyled", as.list.fastmap2 = "fastmap2", 
#&gt;     ask_or_default = "ask_or_default", ask_yesno = "ask_yesno", 
#&gt;     async = "async", async_expr = "async_expr", async_flapply = "async_flapply", 
#&gt;     base64_to_image = "base64_to_image", baseline_array = "baseline_array", 
#&gt;     cat2 = "cat2", check_installed_packages = "check_installed_packages", 
#&gt;     col2hexStr = "col2hexStr", collapse = "collapse", compoundInput2 = "compoundInput2", 
#&gt;     decorate_function = "decorate_function", deparse_svec = "deparse_svec", 
#&gt;     dev_create = "dev_create", dipsaus_lock = "lock", dipsaus_unlock = "lock", 
#&gt;     do_aggregate = "do_aggregate", drop_nulls = "drop_nulls", 
#&gt;     eval_dirty = "eval_dirty", fastmap2 = "fastmap2", forelse = "forelse", 
#&gt;     get_cpu = "get_cpu", get_dots = "get_dots", get_ram = "get_ram", 
#&gt;     getInputBinding = "getInputBinding", handler_dipsaus_progress = "handler_dipsaus_progress", 
#&gt;     iapply = "iapply", lapply_async2 = "lapply_async2", length.fastmap2 = "fastmap2", 
#&gt;     lock = "lock", make_async_evaluator = "make_async_evaluator", 
#&gt;     make_forked_clusters = "make_forked_clusters", map = "map", 
#&gt;     MasterEvaluator = "MasterEvaluator", match_calls = "match_calls", 
#&gt;     mem_limit2 = "mem_limit2", names.fastmap2 = "fastmap2", no_op = "no_op", 
#&gt;     package_installed = "package_installed", parse_svec = "parse_svec", 
#&gt;     PersistContainer = "PersistContainer", prepare_install = "prepare_install", 
#&gt;     print.fastmap2 = "fastmap2", progress2 = "progress2", qs_map = "map", 
#&gt;     rds_map = "map", redis_map = "map", registerInputBinding = "registerInputBinding", 
#&gt;     screenshot = "screenshot", session_map = "map", set_shiny_input = "set_shiny_input", 
#&gt;     shift_array = "shift_array", sync_shiny_inputs = "sync_shiny_inputs", 
#&gt;     text_map = "map", time_delta = "time_delta", to_datauri = "to_datauri", 
#&gt;     to_ram_size = "to_ram_size", update_fastmap2 = "update_fastmap2", 
#&gt;     updateActionButtonStyled = "updateActionButtonStyled", updateCompoundInput2 = "updateCompoundInput2", 
#&gt;     use_shiny_dipsaus = "use_shiny_dipsaus"), article_index = c(async_evaluator = "async_evaluator.html", 
#&gt;     r_expr_addons = "r_expr_addons.html", shiny_customized_widgets = "shiny_customized_widgets.html", 
#&gt;     utility_functions = "utility_functions.html")), examples = TRUE, 
#&gt;     run_dont_run = FALSE, seed = 1014, lazy = FALSE, override = list(), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE)
#&gt; 
#&gt; [[13]]
#&gt; pkgdown::build_site(...)
#&gt; 
#&gt; [[14]]
#&gt; build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, lazy = lazy, override = override, preview = preview, 
#&gt;     devel = devel)
#&gt; 
#&gt; [[15]]
#&gt; build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, override = override, preview = FALSE, devel = devel)
#&gt; 
#&gt; [[16]]
#&gt; purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, 
#&gt;     examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[17]]
#&gt; .f(.x[[i]], ...)
#&gt; 
#&gt; [[18]]
#&gt; data_reference_topic(topic, pkg, examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[19]]
#&gt; run_examples(tags$tag_examples[[1]], env = new.env(parent = globalenv()), 
#&gt;     topic = tools::file_path_sans_ext(topic$file_in), run_examples = examples, 
#&gt;     run_dont_run = run_dont_run)
#&gt; 
#&gt; [[20]]
#&gt; highlight_examples(code, topic, env = env)
#&gt; 
#&gt; [[21]]
#&gt; evaluate::evaluate(x, child_env(env), new_device = TRUE)
#&gt; 
#&gt; [[22]]
#&gt; evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
#&gt;     debug = debug, last = i == length(out), use_try = stop_on_error != 
#&gt;         2L, keep_warning = keep_warning, keep_message = keep_message, 
#&gt;     output_handler = output_handler, include_timing = include_timing)
#&gt; 
#&gt; [[23]]
#&gt; handle(pv &lt;- withCallingHandlers(withVisible(value_fun(ev$value, 
#&gt;     ev$visible)), warning = wHandler, error = eHandler, message = mHandler))
#&gt; 
#&gt; [[24]]
#&gt; try(f, silent = TRUE)
#&gt; 
#&gt; [[25]]
#&gt; tryCatch(expr, error = function(e) {
#&gt;     call &lt;- conditionCall(e)
#&gt;     if (!is.null(call)) {
#&gt;         if (identical(call[[1L]], quote(doTryCatch))) 
#&gt;             call &lt;- sys.call(-4L)
#&gt;         dcall &lt;- deparse(call)[1L]
#&gt;         prefix &lt;- paste("Error in", dcall, ": ")
#&gt;         LONG &lt;- 75L
#&gt;         sm &lt;- strsplit(conditionMessage(e), "\n")[[1L]]
#&gt;         w &lt;- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
#&gt;         if (is.na(w)) 
#&gt;             w &lt;- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
#&gt;                 type = "b")
#&gt;         if (w &gt; LONG) 
#&gt;             prefix &lt;- paste0(prefix, "\n  ")
#&gt;     }
#&gt;     else prefix &lt;- "Error : "
#&gt;     msg &lt;- paste0(prefix, conditionMessage(e), "\n")
#&gt;     .Internal(seterrmessage(msg[1L]))
#&gt;     if (!silent &amp;&amp; isTRUE(getOption("show.error.messages"))) {
#&gt;         cat(msg, file = outFile)
#&gt;         .Internal(printDeferredWarnings())
#&gt;     }
#&gt;     invisible(structure(msg, class = "try-error", condition = e))
#&gt; })
#&gt; 
#&gt; [[26]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[27]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[28]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[29]]
#&gt; withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), 
#&gt;     warning = wHandler, error = eHandler, message = mHandler)
#&gt; 
#&gt; [[30]]
#&gt; withVisible(value_fun(ev$value, ev$visible))
#&gt; 
#&gt; [[31]]
#&gt; value_fun(ev$value, ev$visible)
#&gt; 
#&gt; [[32]]
#&gt; value_handler(x)
#&gt; 
#&gt; [[33]]
#&gt; print(x)
#&gt; 
#&gt; [[34]]
#&gt; print.default(x)
#&gt; 
#&gt; [[35]]
#&gt; (function (x, ...) 
#&gt; UseMethod("print"))(x)
#&gt; 
#&gt; [[36]]
#&gt; print.progression_handler(x)
#&gt; 
#&gt; Progression calling handler of class ‘progression_handler’:
#&gt;  * configuration:
#&gt;    - name: ‘&lt;NULL&gt;’
#&gt;    - max_steps: &lt;NULL&gt;
#&gt;    - enable: FALSE
#&gt;    - enable_after: 0 seconds
#&gt;    - times: 0
#&gt;    - interval: 0 seconds
#&gt;    - intrusiveness: 1
#&gt;    - auto_finish: TRUE
#&gt;    - clear: TRUE
#&gt;    - target: ‘terminal’
#&gt;    - milestones: &lt;NULL&gt;
#&gt;    - owner: &lt;NULL&gt;
#&gt;  * state:
#&gt;    - enabled: FALSE
#&gt;    - finished: FALSE
#&gt;    - step: &lt;NULL&gt;
#&gt;    - message: &lt;NULL&gt;
#&gt;    - prev_milestone: &lt;NULL&gt;
#&gt;    - timestamps: &lt;NULL&gt;
#&gt; </div><div class='input'><span class='fu'><a href='https://rdrr.io/pkg/progressr/man/with_progress.html'>with_progress</a></span>({
  <span class='no'>p</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/progressr/man/progressor.html'>progressor</a></span>(<span class='kw'>along</span> <span class='kw'>=</span> <span class='no'>xs</span>)
  <span class='no'>y</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span>(<span class='no'>xs</span>, <span class='kw'>function</span>(<span class='no'>x</span>) {
    <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/builder.html'>p</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/sprintf.html'>sprintf</a></span>(<span class='st'>"x=%g"</span>, <span class='no'>x</span>))
    <span class='fu'><a href='https://rdrr.io/r/base/Sys.sleep.html'>Sys.sleep</a></span>(<span class='fl'>0.1</span>)
    <span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span>(<span class='no'>x</span>)
  })
})

<span class='co'># ------------------------ A future.apply case -------------------------</span>
<span class='fu'><a href='https://rdrr.io/pkg/future/man/plan.html'>plan</a></span>(<span class='no'>sequential</span>)
<span class='co'># test it yourself with plan(multisession)</span>

<span class='fu'><a href='https://rdrr.io/pkg/progressr/man/handlers.html'>handlers</a></span>(<span class='fu'>handler_dipsaus_progress</span>())</div><div class='output co'>#&gt; [[1]]
#&gt; [[1]]
#&gt; tryCatch(withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try(signalCondition(e))
#&gt; }), error = function(e) {
#&gt;     NULL
#&gt;     try(stop(e))
#&gt; }, interrupt = function(e) {
#&gt;     NULL
#&gt;     e
#&gt; })
#&gt; 
#&gt; [[2]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[3]]
#&gt; tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), 
#&gt;     names[nh], parentenv, handlers[[nh]])
#&gt; 
#&gt; [[4]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[5]]
#&gt; tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
#&gt; 
#&gt; [[6]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[7]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[8]]
#&gt; withCallingHandlers({
#&gt;     NULL
#&gt;     saveRDS(do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;         list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36")
#&gt;     flush(stdout())
#&gt;     flush(stderr())
#&gt;     NULL
#&gt;     invisible()
#&gt; }, error = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, interrupt = function(e) {
#&gt;     {
#&gt;         callr_data &lt;- as.environment("tools:callr")$`__callr_data__`
#&gt;         err &lt;- callr_data$err
#&gt;         capture.output(assign(".Traceback", traceback(9), envir = baseenv()))
#&gt;         dump.frames("__callr_dump__")
#&gt;         assign(".Last.dump", .GlobalEnv$`__callr_dump__`, envir = callr_data)
#&gt;         rm("__callr_dump__", envir = .GlobalEnv)
#&gt;         e2 &lt;- err$new_error(conditionMessage(e), call. = conditionCall(e))
#&gt;         class(e2) &lt;- c("callr_remote_error", class(e2))
#&gt;         e2$error &lt;- e
#&gt;         calls &lt;- sys.calls()
#&gt;         dcframe &lt;- which(vapply(calls, function(x) length(x) &gt;= 
#&gt;             1 &amp;&amp; identical(x[[1]], quote(do.call)), logical(1)))[1]
#&gt;         if (!is.na(dcframe)) 
#&gt;             e2$`_ignore` &lt;- list(c(1, dcframe + 1L))
#&gt;         e2$`_pid` &lt;- Sys.getpid()
#&gt;         e2$`_timestamp` &lt;- Sys.time()
#&gt;         if (inherits(e, "rlib_error")) 
#&gt;             e2$parent &lt;- e$parent
#&gt;         e2 &lt;- err$add_trace_back(e2)
#&gt;         saveRDS(list("error", e2), file = paste0("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36", 
#&gt;             ".error"))
#&gt;     }
#&gt; }, callr_message = function(e) {
#&gt;     try(signalCondition(e))
#&gt; })
#&gt; 
#&gt; [[9]]
#&gt; saveRDS(do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv), file = "/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-res-5e3028413e36")
#&gt; 
#&gt; [[10]]
#&gt; do.call(do.call, c(readRDS("/var/folders/rh/4bkfl5z50wgbbjd85xvc695c0000gn/T//RtmpnouknF/callr-fun-5e301f2aa336"), 
#&gt;     list(envir = .GlobalEnv)), envir = .GlobalEnv)
#&gt; 
#&gt; [[11]]
#&gt; (function (what, args, quote = FALSE, envir = parent.frame()) 
#&gt; {
#&gt;     if (!is.list(args)) 
#&gt;         stop("second argument must be a list")
#&gt;     if (quote) 
#&gt;         args &lt;- lapply(args, enquote)
#&gt;     .Internal(do.call(what, args, envir))
#&gt; })(function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; }, list(pkg = list(package = "dipsaus", version = "0.0.6", src_path = "/Users/beauchamplab/Dropbox/projects/dipsaus", 
#&gt;     dst_path = "/Users/beauchamplab/Dropbox/projects/dipsaus/docs", 
#&gt;     desc = &lt;environment&gt;, meta = list(), figures = list(dev = "grDevices::png", 
#&gt;         dpi = 96L, dev.args = list(), fig.ext = "png", fig.width = 7.29166666666667, 
#&gt;         fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839), 
#&gt;     repo = list(url = list(home = "https://github.com/dipterix/dipsaus/", 
#&gt;         source = "https://github.com/dipterix/dipsaus/blob/master/", 
#&gt;         issue = "https://github.com/dipterix/dipsaus/issues/", 
#&gt;         user = "https://github.com/")), development = list(destination = "dev", 
#&gt;         mode = "release", version_label = "default", version_tooltip = "Released version", 
#&gt;         in_dev = FALSE), topics = list(name = c(AbstractMap.Rd = "AbstractMap", 
#&gt;     AbstractQueue.Rd = "AbstractQueue", MasterEvaluator.Rd = "MasterEvaluator", 
#&gt;     PersistContainer.Rd = "PersistContainer", actionButtonStyled.Rd = "actionButtonStyled", 
#&gt;     ask_or_default.Rd = "ask_or_default", ask_yesno.Rd = "ask_yesno", 
#&gt;     async.Rd = "async", async_expr.Rd = "async_expr", async_flapply.Rd = "async_flapply", 
#&gt;     base64_to_image.Rd = "base64_to_image", baseline_array.Rd = "baseline_array", 
#&gt;     cat2.Rd = "cat2", check_installed_packages.Rd = "check_installed_packages", 
#&gt;     col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", compoundInput2.Rd = "compoundInput2", 
#&gt;     decorate_function.Rd = "decorate_function", deparse_svec.Rd = "deparse_svec", 
#&gt;     dev_create.Rd = "dev_create", do_aggregate.Rd = "do_aggregate", 
#&gt;     drop_nulls.Rd = "drop_nulls", eval_dirty.Rd = "eval_dirty", 
#&gt;     fastmap2.Rd = "fastmap2", forelse.Rd = "forelse", getInputBinding.Rd = "getInputBinding", 
#&gt;     get_cpu.Rd = "get_cpu", get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", 
#&gt;     `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", `grapes-help-set-grapes.Rd` = "%?&lt;-%", 
#&gt;     `grapes-plus-grapes.Rd` = "%+-%", handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;     iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;     lock.Rd = "lock", make_async_evaluator.Rd = "make_async_evaluator", 
#&gt;     make_forked_clusters.Rd = "make_forked_clusters", map.Rd = "map", 
#&gt;     match_calls.Rd = "match_calls", mem_limit2.Rd = "mem_limit2", 
#&gt;     no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;     parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;     progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;     screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;     shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;     time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;     to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;     updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;     use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), file_in = c("AbstractMap.Rd", 
#&gt;     "AbstractQueue.Rd", "MasterEvaluator.Rd", "PersistContainer.Rd", 
#&gt;     "actionButtonStyled.Rd", "ask_or_default.Rd", "ask_yesno.Rd", 
#&gt;     "async.Rd", "async_expr.Rd", "async_flapply.Rd", "base64_to_image.Rd", 
#&gt;     "baseline_array.Rd", "cat2.Rd", "check_installed_packages.Rd", 
#&gt;     "col2hexStr.Rd", "collapse.Rd", "compoundInput2.Rd", "decorate_function.Rd", 
#&gt;     "deparse_svec.Rd", "dev_create.Rd", "do_aggregate.Rd", "drop_nulls.Rd", 
#&gt;     "eval_dirty.Rd", "fastmap2.Rd", "forelse.Rd", "getInputBinding.Rd", 
#&gt;     "get_cpu.Rd", "get_dots.Rd", "get_ram.Rd", "grapes-equals-greater-than-grapes.Rd", 
#&gt;     "grapes-help-set-grapes.Rd", "grapes-plus-grapes.Rd", "handler_dipsaus_progress.Rd", 
#&gt;     "iapply.Rd", "lapply_async2.Rd", "lock.Rd", "make_async_evaluator.Rd", 
#&gt;     "make_forked_clusters.Rd", "map.Rd", "match_calls.Rd", "mem_limit2.Rd", 
#&gt;     "no_op.Rd", "package_installed.Rd", "parse_svec.Rd", "prepare_install.Rd", 
#&gt;     "progress2.Rd", "registerInputBinding.Rd", "screenshot.Rd", 
#&gt;     "set_shiny_input.Rd", "shift_array.Rd", "sync_shiny_inputs.Rd", 
#&gt;     "time_delta.Rd", "to_datauri.Rd", "to_ram_size.Rd", "updateActionButtonStyled.Rd", 
#&gt;     "updateCompoundInput2.Rd", "update_fastmap2.Rd", "use_shiny_dipsaus.Rd"
#&gt;     ), file_out = c("AbstractMap.html", "AbstractQueue.html", 
#&gt;     "MasterEvaluator.html", "PersistContainer.html", "actionButtonStyled.html", 
#&gt;     "ask_or_default.html", "ask_yesno.html", "async.html", "async_expr.html", 
#&gt;     "async_flapply.html", "base64_to_image.html", "baseline_array.html", 
#&gt;     "cat2.html", "check_installed_packages.html", "col2hexStr.html", 
#&gt;     "collapse.html", "compoundInput2.html", "decorate_function.html", 
#&gt;     "deparse_svec.html", "dev_create.html", "do_aggregate.html", 
#&gt;     "drop_nulls.html", "eval_dirty.html", "fastmap2.html", "forelse.html", 
#&gt;     "getInputBinding.html", "get_cpu.html", "get_dots.html", 
#&gt;     "get_ram.html", "grapes-equals-greater-than-grapes.html", 
#&gt;     "grapes-help-set-grapes.html", "grapes-plus-grapes.html", 
#&gt;     "handler_dipsaus_progress.html", "iapply.html", "lapply_async2.html", 
#&gt;     "lock.html", "make_async_evaluator.html", "make_forked_clusters.html", 
#&gt;     "map.html", "match_calls.html", "mem_limit2.html", "no_op.html", 
#&gt;     "package_installed.html", "parse_svec.html", "prepare_install.html", 
#&gt;     "progress2.html", "registerInputBinding.html", "screenshot.html", 
#&gt;     "set_shiny_input.html", "shift_array.html", "sync_shiny_inputs.html", 
#&gt;     "time_delta.html", "to_datauri.html", "to_ram_size.html", 
#&gt;     "updateActionButtonStyled.html", "updateCompoundInput2.html", 
#&gt;     "update_fastmap2.html", "use_shiny_dipsaus.html"), alias = list(
#&gt;         AbstractMap.Rd = "AbstractMap", AbstractQueue.Rd = "AbstractQueue", 
#&gt;         MasterEvaluator.Rd = "MasterEvaluator", PersistContainer.Rd = "PersistContainer", 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled", ask_or_default.Rd = "ask_or_default", 
#&gt;         ask_yesno.Rd = "ask_yesno", async.Rd = "async", async_expr.Rd = "async_expr", 
#&gt;         async_flapply.Rd = "async_flapply", base64_to_image.Rd = "base64_to_image", 
#&gt;         baseline_array.Rd = "baseline_array", cat2.Rd = "cat2", 
#&gt;         check_installed_packages.Rd = "check_installed_packages", 
#&gt;         col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", 
#&gt;         compoundInput2.Rd = "compoundInput2", decorate_function.Rd = c("decorate_function", 
#&gt;         "%D%"), deparse_svec.Rd = "deparse_svec", dev_create.Rd = "dev_create", 
#&gt;         do_aggregate.Rd = "do_aggregate", drop_nulls.Rd = "drop_nulls", 
#&gt;         eval_dirty.Rd = "eval_dirty", fastmap2.Rd = c("fastmap2", 
#&gt;         "[[.fastmap2", "$.fastmap2", "[[&lt;-.fastmap2", "$&lt;-.fastmap2", 
#&gt;         "[.fastmap2", "[&lt;-.fastmap2", "names.fastmap2", "print.fastmap2", 
#&gt;         "length.fastmap2", "as.list.fastmap2"), forelse.Rd = "forelse", 
#&gt;         getInputBinding.Rd = "getInputBinding", get_cpu.Rd = "get_cpu", 
#&gt;         get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", 
#&gt;         `grapes-help-set-grapes.Rd` = "%?&lt;-%", `grapes-plus-grapes.Rd` = "%+-%", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;         iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;         lock.Rd = c("lock", "dipsaus_lock", "dipsaus_unlock"), 
#&gt;         make_async_evaluator.Rd = "make_async_evaluator", make_forked_clusters.Rd = "make_forked_clusters", 
#&gt;         map.Rd = c("map", "session_map", "rds_map", "text_map", 
#&gt;         "qs_map", "redis_map"), match_calls.Rd = "match_calls", 
#&gt;         mem_limit2.Rd = "mem_limit2", no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;         parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;         progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;         screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;         shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;         time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;         to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), funs = list(
#&gt;         AbstractMap.Rd = character(0), AbstractQueue.Rd = character(0), 
#&gt;         MasterEvaluator.Rd = character(0), PersistContainer.Rd = character(0), 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled()", ask_or_default.Rd = "ask_or_default()", 
#&gt;         ask_yesno.Rd = "ask_yesno()", async.Rd = "async()", async_expr.Rd = "async_expr()", 
#&gt;         async_flapply.Rd = "async_flapply()", base64_to_image.Rd = "base64_to_image()", 
#&gt;         baseline_array.Rd = "baseline_array()", cat2.Rd = "cat2()", 
#&gt;         check_installed_packages.Rd = "check_installed_packages()", 
#&gt;         col2hexStr.Rd = "col2hexStr()", collapse.Rd = "collapse()", 
#&gt;         compoundInput2.Rd = "compoundInput2()", decorate_function.Rd = c("decorate_function()", 
#&gt;         "`%D%`"), deparse_svec.Rd = "deparse_svec()", dev_create.Rd = "dev_create()", 
#&gt;         do_aggregate.Rd = "do_aggregate()", drop_nulls.Rd = "drop_nulls()", 
#&gt;         eval_dirty.Rd = "eval_dirty()", fastmap2.Rd = c("fastmap2()", 
#&gt;         "`[[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "names(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "print(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "length(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "as.list(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)"
#&gt;         ), forelse.Rd = "forelse()", getInputBinding.Rd = "getInputBinding()", 
#&gt;         get_cpu.Rd = "get_cpu()", get_dots.Rd = "get_dots()", 
#&gt;         get_ram.Rd = "get_ram()", `grapes-equals-greater-than-grapes.Rd` = "`%=&amp;gt;%`", 
#&gt;         `grapes-help-set-grapes.Rd` = "`%?&amp;lt;-%`", `grapes-plus-grapes.Rd` = "`%+-%`", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress()", 
#&gt;         iapply.Rd = "iapply()", lapply_async2.Rd = "lapply_async2()", 
#&gt;         lock.Rd = c("dipsaus_lock()", "dipsaus_unlock()"), make_async_evaluator.Rd = "make_async_evaluator()", 
#&gt;         make_forked_clusters.Rd = "make_forked_clusters()", map.Rd = c("session_map()", 
#&gt;         "rds_map()", "text_map()", "qs_map()", "redis_map()"), 
#&gt;         match_calls.Rd = "match_calls()", mem_limit2.Rd = "mem_limit2()", 
#&gt;         no_op.Rd = "no_op()", package_installed.Rd = "package_installed()", 
#&gt;         parse_svec.Rd = "parse_svec()", prepare_install.Rd = "prepare_install()", 
#&gt;         progress2.Rd = "progress2()", registerInputBinding.Rd = "registerInputBinding()", 
#&gt;         screenshot.Rd = "screenshot()", set_shiny_input.Rd = "set_shiny_input()", 
#&gt;         shift_array.Rd = "shift_array()", sync_shiny_inputs.Rd = "sync_shiny_inputs()", 
#&gt;         time_delta.Rd = "time_delta()", to_datauri.Rd = "to_datauri()", 
#&gt;         to_ram_size.Rd = "to_ram_size()", updateActionButtonStyled.Rd = "updateActionButtonStyled()", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2()", update_fastmap2.Rd = "update_fastmap2()", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus()"), title = c(AbstractMap.Rd = "Abstract Map to store key-value pairs", 
#&gt;     AbstractQueue.Rd = "Defines abstract queue class", MasterEvaluator.Rd = "Generator Class for Asynchronous Evaluation", 
#&gt;     PersistContainer.Rd = "Wrapper to cache key-value pairs and persist across sessions", 
#&gt;     actionButtonStyled.Rd = "Action Button but with customized styles", 
#&gt;     ask_or_default.Rd = "Read a Line from the Terminal, but with Default Values", 
#&gt;     ask_yesno.Rd = "Ask and Return True or False from the Terminal", 
#&gt;     async.Rd = "Evaluate expression in &lt;code&gt;async_expr&lt;/code&gt;", 
#&gt;     async_expr.Rd = "Apply R expressions in a parallel way", 
#&gt;     async_flapply.Rd = "Wrapper for &lt;code&gt;future.apply::future_lapply&lt;/code&gt;", 
#&gt;     base64_to_image.Rd = "Save \"Base64\" Data to Images", baseline_array.Rd = "Calculate Contrasts of Arrays in Different Methods", 
#&gt;     cat2.Rd = "Color Output", check_installed_packages.Rd = "Check If Packages Are Installed, Returns Missing Packages", 
#&gt;     col2hexStr.Rd = "Convert color to Hex string", collapse.Rd = "Collapse Sensors And Calculate Summations/Mean\n\n(stable)", 
#&gt;     compoundInput2.Rd = "Compound input that combines and extends shiny inputs", 
#&gt;     decorate_function.Rd = "Python-style decorator", deparse_svec.Rd = "Convert Integer Vectors To String\n\n(stable)", 
#&gt;     dev_create.Rd = "Create a group of named graphic devices", 
#&gt;     do_aggregate.Rd = "Make aggregate pipe-friendly", drop_nulls.Rd = "Drop &lt;code&gt;NULL&lt;/code&gt; values from list or vectors", 
#&gt;     eval_dirty.Rd = "Evaluate expressions", fastmap2.Rd = "A Wrapper for &lt;code&gt;fastmap::fastmap&lt;/code&gt;", 
#&gt;     forelse.Rd = "Python-style &lt;code&gt;\"for-else\"&lt;/code&gt; function", 
#&gt;     getInputBinding.Rd = "Obtain registered input bindings", 
#&gt;     get_cpu.Rd = "Get CPU Chip-set Information", get_dots.Rd = "Get element from dots &lt;code&gt;'...'&lt;/code&gt;", 
#&gt;     get_ram.Rd = "Get Memory Size", `grapes-equals-greater-than-grapes.Rd` = "A JavaScript style of creating functions", 
#&gt;     `grapes-help-set-grapes.Rd` = "Assign if not exists, or NULL\nProvides a way to assign default values to variables. If the statement\n`&lt;code&gt;lhs&lt;/code&gt;` is invalid or &lt;code&gt;NULL&lt;/code&gt;, this function will try to assign\n&lt;code&gt;value&lt;/code&gt;, otherwise nothing happens.", 
#&gt;     `grapes-plus-grapes.Rd` = "Plus-minus operator", handler_dipsaus_progress.Rd = "Progress-bar Handler", 
#&gt;     iapply.Rd = "Apply each elements with index as second input", 
#&gt;     lapply_async2.Rd = "Apply, but in parallel", lock.Rd = "Create or Unlock a Lock", 
#&gt;     make_async_evaluator.Rd = "Create Asynchronous Evaluator to Queue Tasks", 
#&gt;     make_forked_clusters.Rd = "Create forked clusters", map.Rd = "Create R object map.", 
#&gt;     match_calls.Rd = "Recursively match calls and modify arguments", 
#&gt;     mem_limit2.Rd = "Get max RAM size\nThis is an experimental function that is designed for non-windows systems", 
#&gt;     no_op.Rd = "Pipe-friendly no-operation function", package_installed.Rd = "Check if a package is installed", 
#&gt;     parse_svec.Rd = "Parse Text Into Numeric Vectors\n\n(stable)", 
#&gt;     prepare_install.Rd = "Install Packages at Next Startup", 
#&gt;     progress2.Rd = "'Shiny' progress bar, but can run without reactive context", 
#&gt;     registerInputBinding.Rd = "Register customized input to enable support by compound input", 
#&gt;     screenshot.Rd = "Take a screenshot in shiny apps", set_shiny_input.Rd = "Set Shiny Input", 
#&gt;     shift_array.Rd = "Shift Array by Index", sync_shiny_inputs.Rd = "Synchronize Shiny Inputs", 
#&gt;     time_delta.Rd = "Calculate time difference and return a number", 
#&gt;     to_datauri.Rd = "Convert file to 'base64' format", to_ram_size.Rd = "Convert bytes to KB, MB, GB,...", 
#&gt;     updateActionButtonStyled.Rd = "Update styled action button", 
#&gt;     updateCompoundInput2.Rd = "Update compound inputs", update_fastmap2.Rd = "Migrate a &lt;code&gt;fastmap2&lt;/code&gt; object to a new one", 
#&gt;     use_shiny_dipsaus.Rd = "Set up shiny plugins"), rd = list(
#&gt;         AbstractMap.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-abstract.R", 
#&gt;             "\n", list("AbstractMap"), "\n", list("AbstractMap"), 
#&gt;             "\n", list("Abstract Map to store key-value pairs"), 
#&gt;             "\n", list("\n", "Abstract Map to store key-value pairs\n"), 
#&gt;             "\n"), AbstractQueue.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/queue-abstract.R", 
#&gt;             "\n", list("AbstractQueue"), "\n", list("AbstractQueue"), 
#&gt;             "\n", list("Defines abstract queue class"), "\n", 
#&gt;             list("\n", "This class is inspired by ", list("https://cran.r-project.org/package=txtq"), 
#&gt;                 ".\n", "The difference is ", list("AbstractQueue"), 
#&gt;                 " introduce an abstract class that can\n", "be extended and can queue not only text messages, but also arbitrary R\n", 
#&gt;                 "objects, including expressions and environments. All the queue types in this\n", 
#&gt;                 "package inherit this class.\n"), "\n", list(
#&gt;                 list("Abstract Public Methods"), list("\n", "\n", 
#&gt;                   "\n", "Methods start with ", list("@..."), 
#&gt;                   " are not thread-safe. Most of them are not\n", 
#&gt;                   "used directly by users. However, you might want to override them if you\n", 
#&gt;                   "inherit this abstract class. Methods marked as \"(override)\" are not\n", 
#&gt;                   "implemented, meaning you are supposed to implement the details. Methods\n", 
#&gt;                   "marked as \"(optional)\" usually have default alternatives.\n", 
#&gt;                   "\n", list("\n", list(list(list("initialize(...)"), 
#&gt;                     " (override)"), list("\n", "The constructor. Usually three things to do during the process:\n", 
#&gt;                     "1. set ", list("get_locker"), " ", list(
#&gt;                       "free_locker"), " if you don't want to use the\n", 
#&gt;                     "default lockers. 2. set lock file (if using default lockers). 3. call\n", 
#&gt;                     list("self$connect(...)"), "\n")), "\n", 
#&gt;                     list(list(list("get_locker()"), ", ", list(
#&gt;                       "free_locker()"), " (optional)"), list(
#&gt;                       "\n", "Default is ", list("NULL"), " for each methods, and queue uses an internal\n", 
#&gt;                       list("private$default_get_locker"), " and ", 
#&gt;                       list("private$default_free_locker"), ".\n", 
#&gt;                       "These two methods are for customized locker, please\n", 
#&gt;                       "implement these two methods as functions during ", 
#&gt;                       list("self$initialization"), "\n", list(
#&gt;                         "get_locker"), " obtains and lock access (exclusive), and ", 
#&gt;                       list("free_locker"), "\n", "frees the locker. Once implemented, ", 
#&gt;                       list("private$exclusive"), " will take care\n", 
#&gt;                       "the rest. Type: function; parameters: none; return: none\n")), 
#&gt;                     "\n", list(list(list("@get_head()"), ", ", 
#&gt;                       list("@set_head(v)"), " (override)"), list(
#&gt;                       "\n", "Get head so that we know where we are in the queue ", 
#&gt;                       list("self$@get_head()"), "\n", "should return a integer indicating where we are at the queue\n", 
#&gt;                       list("self$@set_head(v)"), " stores that integer. Parameter ", 
#&gt;                       list("v"), " is always\n", "non-negative, this is guaranteed. Users are not supposed to call these\n", 
#&gt;                       "methods directly, use ", list("self$head"), 
#&gt;                       " and ", list("self$head&lt;-"), " instead.\n", 
#&gt;                       "However, if you inherit this class, you are supposed to override the methods.\n")), 
#&gt;                     "\n", list(list(list("@get_total()"), ", ", 
#&gt;                       list("@set_total(v)"), " (override)"), 
#&gt;                       list("\n", "Similar to ", list("@get_head"), 
#&gt;                         " and ", list("@set_head"), ", defines the total items\n", 
#&gt;                         "ever stored in the queue. total-head equals current items in the queue.\n")), 
#&gt;                     "\n", list(list(list("@inc_total(n=1)"), 
#&gt;                       " (optional)"), list("\n", "Increase total, usually this doesn't need to be override, unless you are\n", 
#&gt;                       "using files to store total and want to decrease number of file connections\n")), 
#&gt;                     "\n", list(list(list("@append_header(msg, ...)"), 
#&gt;                       " (override)"), list("\n", list("msg"), 
#&gt;                       " will be vector of strings, separated by \"|\", containing encoded\n", 
#&gt;                       "headers: `time`, `key`, `hash`, and `message`. to decode what's inside, you\n", 
#&gt;                       "can use ", list("self$print_items(stringr::str_split_fixed(msg, '\\|', 4))"), 
#&gt;                       ".\n", list("Make sure"), " to return a number, indicating number of items stored.\n", 
#&gt;                       "Unless handled elsewhere, usually ", list(
#&gt;                         "return(length(msg))"), ".\n")), "\n", 
#&gt;                     list(list(list("@store_value(value, key)"), 
#&gt;                       " (override)"), list("\n", "Defines how to store value. `key` is unique identifier generated from\n", 
#&gt;                       "time, queue ID, and value. Usually I use it as file name or key ID in\n", 
#&gt;                       "database. value is an arbitrary R object to store. you need to store value\n", 
#&gt;                       "somewhere and return a string that will be passed as `hash` in\n", 
#&gt;                       list("self$restore_value"), ".\n")), "\n", 
#&gt;                     list(list(list("restore_value(hash, key, preserve = FALSE)"), 
#&gt;                       " (override)"), list("\n", "Method to restore value from given combination of `hash` and `key`.\n", 
#&gt;                       "`hash` is the string returned by ", list(
#&gt;                         "@store_value"), ", and `key` is the same\n", 
#&gt;                       "as key in ", list("@store_value"), ". preserve is a indicator of whether to\n", 
#&gt;                       "preserve the value for future use. If set to ", 
#&gt;                       list("FALSE"), ", then you are\n", "supposed to free up the resource related to the value. (such as free memory\n", 
#&gt;                       "or disk space)\n")), "\n", list(list(list(
#&gt;                       "@log(n = -1, all = FALSE) (override)")), 
#&gt;                       list("\n", "get ", list("n"), " items from what you saved to during ", 
#&gt;                         list("@append_header"), ".\n", list("n"), 
#&gt;                         " less equal than 0 means listing all possible items.\n", 
#&gt;                         "If ", list("all=TRUE"), ", return all items (number of rows should equals to\n", 
#&gt;                         list("self$total"), "), including popped items. If ", 
#&gt;                         list("all=FALSE"), ", only\n", "return items in the queue (number of rows is ", 
#&gt;                         list("self$count"), "). The\n", "returned value should be a ", 
#&gt;                         list("n x 4"), " matrix. Usually I use\n", 
#&gt;                         list("stringr::str_split_fixed(..., '\\|', 4)"), 
#&gt;                         ". Please see all other\n", "types implemented for example.\n")), 
#&gt;                     "\n", list(list(list("@reset(...)"), " (override)"), 
#&gt;                       list("\n", "Reset queue, remove all items and reset head, total to be 0.\n")), 
#&gt;                     "\n", list(list(list("@clean()"), " (override)"), 
#&gt;                       list("\n", "Clean the queue, remove all the popped items.\n")), 
#&gt;                     "\n", list(list(list("@validate()"), " (override)"), 
#&gt;                       list("\n", "Validate the queue. Stop if the queue is broken.\n")), 
#&gt;                     "\n", list(list(list("@connect(con, ...)"), 
#&gt;                       " (override)"), list("\n", "Set up connection. Usually should be called at the end of\n", 
#&gt;                       list("self$initialization"), " to connect to a database, a folder, or an\n", 
#&gt;                       "existing queue you should do checks whether the connection is new or it's\n", 
#&gt;                       "an existing queue.\n")), "\n", list(list(
#&gt;                       list("connect(con, ...)"), " (optional)"), 
#&gt;                       list("\n", "Thread-safe version. sometimes you need to override this function instead\n", 
#&gt;                         "of ", list("@connect"), ", because ", 
#&gt;                         list("private$exclusive"), " requires ", 
#&gt;                         list("lockfile"), "\n", "to exist and to be locked. If you don't have lockers ready, or need to set\n", 
#&gt;                         "lockers during the connection, override this one.\n")), 
#&gt;                     "\n", list(list(list("destroy()"), " (optional)"), 
#&gt;                       list("\n", "Destroy a queue, free up space and call\n", 
#&gt;                         list("delayedAssign('.lockfile', {stop(...)}, assign.env=private)"), 
#&gt;                         " to raise\n", "error if a destroyed queue is called again later.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Methods"), 
#&gt;                 list("\n", "\n", "\n", "Usually don't need to override unless you know what you are doing.\n", 
#&gt;                   "\n", list("\n", list(list(list("push(value, message='',...)")), 
#&gt;                     list("\n", "Function to push an arbitrary R object to queue. ", 
#&gt;                       list("message"), " is a string\n", "giving notes to the pushed item. Usually message is stored with header,\n", 
#&gt;                       "separated from values. The goal is to describe the value. ", 
#&gt;                       list("..."), " is\n", "passed to ", list(
#&gt;                         "@append_header"), "\n")), "\n", list(
#&gt;                     list(list("pop(n = 1, preserve = FALSE)")), 
#&gt;                     list("\n", "Pop ", list("n"), " items from the queue. ", 
#&gt;                       list("preserve"), " indicates whether not to\n", 
#&gt;                       "free up the resources, though not always guaranteed.\n")), 
#&gt;                     "\n", list(list(list("print_item(item)"), 
#&gt;                       ", ", list("print_items(items)")), list(
#&gt;                       "\n", "To decode matrix returned by ", 
#&gt;                       list("log()"), ", returning named list or data frame\n", 
#&gt;                       "with four heads: `time`, `key`, `hash`, and `message`.\n")), 
#&gt;                     "\n", list(list(list("list(n=-1)")), list(
#&gt;                       "\n", "List items in the queue, decoded. If ", 
#&gt;                       list("n"), " is less equal than 0, then\n", 
#&gt;                       "list all results. The result is equivalent to\n", 
#&gt;                       list("self$print_items(self$log(n))"), 
#&gt;                       "\n")), "\n", list(list(list("log(n=-1,all=FALSE)")), 
#&gt;                       list("\n", "List items in the queue, encoded. This is used with ", 
#&gt;                         list("self$print_items"), ".\n", "When ", 
#&gt;                         list("all=TRUE"), ", result will list the  records ever pushed to the queue\n", 
#&gt;                         "since the last time queue is cleaned. When ", 
#&gt;                         list("all=FALSE"), ", results will be\n", 
#&gt;                         "items in the queue. ", list("n"), " is the number of items.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Active Bindings"), 
#&gt;                 list("\n", "\n", "\n", list("\n", list(list(list(
#&gt;                   "id")), list("\n", "Read-only property. Returns unique ID of current queue.\n")), 
#&gt;                   "\n", list(list(list("lockfile")), list("\n", 
#&gt;                     "The lock file.\n")), "\n", list(list(list(
#&gt;                     "head")), list("\n", "Integer, total number of items popped, i.e. inactive items.\n")), 
#&gt;                   "\n", list(list(list("total")), list("\n", 
#&gt;                     "Total number of items ever pushed to the queue since last cleaned, integer.\n")), 
#&gt;                   "\n", list(list(list("count")), list("\n", 
#&gt;                     "Integer, read-only, equals to total - head, number of active items in the\n", 
#&gt;                     "queue\n")), "\n"), "\n")), "\n", "\n", list(
#&gt;                 list("Private Methods or properties"), list("\n", 
#&gt;                   "\n", "\n", list("\n", list(list(list(".id")), 
#&gt;                     list("\n", "Don't use directly. Used to store queue ID.\n")), 
#&gt;                     "\n", list(list(list(".lockfile")), list(
#&gt;                       "\n", "Location of lock file.\n")), "\n", 
#&gt;                     list(list(list("lock")), list("\n", "Preserve the file lock.\n")), 
#&gt;                     "\n", list(list(list("exclusive(expr,...)")), 
#&gt;                       list("\n", "Function to make sure the methods are thread-safe\n")), 
#&gt;                     "\n", list(list(list("default_get_locker()")), 
#&gt;                       list("\n", "Default method to lock a queue\n")), 
#&gt;                     "\n", list(list(list("default_free_locker")), 
#&gt;                       list("\n", "Default method to free a queue\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n"), MasterEvaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("MasterEvaluator"), "\n", list("MasterEvaluator"), 
#&gt;             "\n", list("Generator Class for Asynchronous Evaluation"), 
#&gt;             "\n", list("\n", "Generator Class for Asynchronous Evaluation\n"), 
#&gt;             "\n"), PersistContainer.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/persist.R", 
#&gt;             "\n", list("PersistContainer"), "\n", list("PersistContainer"), 
#&gt;             "\n", list("Wrapper to cache key-value pairs and persist across sessions"), 
#&gt;             "\n", list("\n", "This class is designed to persist arbitrary R objects locally\n", 
#&gt;                 "and share across different sessions. The container consists two-level caches.\n", 
#&gt;                 "The first one is session-based, meaning it's only valid under current R\n", 
#&gt;                 "session and will be cleared once the session is shut down. The second is\n", 
#&gt;                 "the persist-level map, which will persist to hard drive and shared across\n", 
#&gt;                 "sessions. See ", list("cache"), " method in 'details'.\n"), 
#&gt;             "\n", list(list("Public Methods"), list("\n", "\n", 
#&gt;                 "\n", list("\n", list(list(list("initialize(..., backend = text_map)")), 
#&gt;                   list("\n", "The constructor. backend must inherit ", 
#&gt;                     list("AbstractMap"), ", ", list("..."), " will\n", 
#&gt;                     "be passed to ", list("backend$new(...)"), 
#&gt;                     ". To check available back-ends and their\n", 
#&gt;                     "use cases, see ", list(list("map")), ".\n")), 
#&gt;                   "\n", list(list(list("reset(all = FALSE)")), 
#&gt;                     list("\n", "Reset container. If all is set to be true, then reset session-based and\n", 
#&gt;                       "hard-drive-based, otherwise only reset session-based container.\n")), 
#&gt;                   "\n", list(list(list("destroy(all = FALSE)")), 
#&gt;                     list("\n", "destroy the container. Only use it when you want to finalize the container in\n", 
#&gt;                       list(list("reg.finalizer")), ".\n")), "\n", 
#&gt;                   list(list(list("has(key, signature = NULL)")), 
#&gt;                     list("\n", "returns a list of true/false (logical) vectors indicating whether keys exist\n", 
#&gt;                       "in the container, if signature is used when caching the key-value pairs, then\n", 
#&gt;                       "it also checks whether signature matches. This is very important as even if\n", 
#&gt;                       "the keys match but signature is wrong, the results will be false.\n")), 
#&gt;                   "\n", list(list(list("remove(keys, all = TRUE)")), 
#&gt;                     list("\n", "Remove keys in the container. Default is to remove the keys in both levels.\n", 
#&gt;                       "If ", list("all=FALSE"), ", then only remove the key in current session\n")), 
#&gt;                   "\n", list(list(list("cache(key, value, signature = NULL, replace = FALSE, persist = FALSE)")), 
#&gt;                     list("\n", list("key"), " and ", list("signature"), 
#&gt;                       " together form the unique identifier for the\n", 
#&gt;                       "value. By default ", list("signature"), 
#&gt;                       " is none, but it's very useful when value\n", 
#&gt;                       "if large, or ", list("key"), " is not a string. ", 
#&gt;                       list("replace"), " indicates whether\n", 
#&gt;                       "to force replace the key-value pairs even if the entry exists. If\n", 
#&gt;                       list("persist"), " is true, then the value is stored in hard-disks, otherwise\n", 
#&gt;                       "the value will be deleted once the session is closed.\n")), 
#&gt;                   "\n"), "\n")), "\n", "\n", list("\n", "\n", 
#&gt;                 "container = PersistContainer$new(tempfile())\n", 
#&gt;                 "\n", "# Reset the container so that values are cleared\n", 
#&gt;                 "container$reset(all = TRUE)\n", "\n", "# Store `1` to 'a' with signature 111 to a non-persist map\n", 
#&gt;                 "# returns 1\n", "container$cache(key = 'a', value = 1, signature = 111, persist = FALSE)\n", 
#&gt;                 "\n", "# Replace 'a' with 3\n", "# returns 3\n", 
#&gt;                 "container$cache(key = 'a', value = 3, signature = 111,\n", 
#&gt;                 "                persist = TRUE, replace = TRUE)\n", 
#&gt;                 "\n", "# check if 'a' exists with signature 111\n", 
#&gt;                 "container$has('a', signature = 111)    # TRUE\n", 
#&gt;                 "# When you only have 'a' but no signature\n", 
#&gt;                 "container$has('a')                     # TRUE\n", 
#&gt;                 "# check if 'a' exists with wrong signature 222\n", 
#&gt;                 "container$has('a', signature = 222)    # FALSE\n", 
#&gt;                 "\n", "\n", "# Store 'a' with 2 with same signature\n", 
#&gt;                 "# will fail and ignore the value (value will not be evaluated if signatured)\n", 
#&gt;                 "# Return 2 (Important! use cached values)\n", 
#&gt;                 "container$cache(key = 'a', value = {\n", "  print(123)\n", 
#&gt;                 "  return(2)\n", "}, signature = 111, replace = FALSE)\n", 
#&gt;                 "\n", "# When no signature is present\n", "# If the key exists (no signature provided), return stored value\n", 
#&gt;                 "# returns 3\n", "container$cache(key = 'a', value = 4)\n", 
#&gt;                 "\n", "# replace is TRUE (no signature provided), signature will be some default value\n", 
#&gt;                 "container$cache(key = 'a', value = 2, replace = TRUE)\n", 
#&gt;                 "\n", "# destroy the container to free disk space\n", 
#&gt;                 "container$destroy()\n"), "\n", list("\n", list(
#&gt;                 list("map")), "\n"), "\n"), actionButtonStyled.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("actionButtonStyled"), "\n", list("actionButtonStyled"), 
#&gt;             "\n", list("Action Button but with customized styles"), 
#&gt;             "\n", list("\n", "actionButtonStyled(\n", "  inputId,\n", 
#&gt;                 "  label,\n", "  icon = NULL,\n", "  width = NULL,\n", 
#&gt;                 "  type = \"primary\",\n", "  btn_type = \"button\",\n", 
#&gt;                 "  class = \"\",\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("inputId, label, icon, width, ..."), 
#&gt;                 list("passed to ", list("shiny::actionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type, choices are `default`, `primary`, `info`, `success`,\n", 
#&gt;                   "`warning`, and `danger`")), "\n", "\n", list(
#&gt;                   list("btn_type"), list("HTML tag type, either ", 
#&gt;                     list("\"button\""), " or ", list("\"a\""))), 
#&gt;                 "\n", "\n", list(list("class"), list("additional classes to be added to the button")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Action Button but with customized styles\n"), 
#&gt;             "\n", list("\n", "\n", "# demo('example-actionButtonStyled', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButtonStyled('btn', label = 'Click me', type = 'default'),\n", 
#&gt;                 "  actionButtonStyled('btn2', label = 'Click me2', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  btn_types = c('default', 'primary', 'info', 'success', 'warning', 'danger')\n", 
#&gt;                 "  observeEvent(input$btn, {\n", "    btype = btn_types[((input$btn-1) %% (length(btn_types)-1)) + 1]\n", 
#&gt;                 "    updateActionButtonStyled(session, 'btn2', type = btype)\n", 
#&gt;                 "  })\n", "  observeEvent(input$btn2, {\n", "    updateActionButtonStyled(session, 'btn',\n", 
#&gt;                 "                             disabled = c(FALSE,TRUE)[(input$btn2 %% 2) + 1])\n", 
#&gt;                 "  })\n", "}\n", "\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser=TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateActionButtonStyled")), 
#&gt;                 " for how to update the button.\n"), "\n"), ask_or_default.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("ask_or_default"), "\n", list("ask_or_default"), 
#&gt;             "\n", list("Read a Line from the Terminal, but with Default Values"), 
#&gt;             "\n", list("\n", "ask_or_default(..., default = \"\", end = \"\", level = \"INFO\")\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("default"), list("default value to return in case of blank input")), 
#&gt;                 "\n"), "\n", list("\n", "A character from the user's input, or the default value. See details.\n"), 
#&gt;             "\n", list("\n", "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask a question, providing defaults. Users\n", 
#&gt;                 "need to enter the answer. If the answer is blank (no space), then returns the\n", 
#&gt;                 "default, otherwise returns the user input.\n", 
#&gt;                 "\n", "This can only be used in an ", list(list(
#&gt;                   "interactive")), " session.\n"), "\n", list(
#&gt;                 "\n", "if(interactive()){\n", "ask_or_default('What is the best programming language?',\n", 
#&gt;                 "               default = 'PHP')\n", "}\n"), 
#&gt;             "\n", list("\n", list(list("cat2")), ", ", list(list(
#&gt;                 "readline")), ",\n", list(list("ask_yesno")), 
#&gt;                 "\n"), "\n"), ask_yesno.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("ask_yesno"), "\n", list("ask_yesno"), 
#&gt;             "\n", list("Ask and Return True or False from the Terminal"), 
#&gt;             "\n", list("\n", "ask_yesno(..., end = \"\", level = \"INFO\", error_if_canceled = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("error_if_canceled"), list("raise error if canceled.")), 
#&gt;                 "\n"), "\n", list("\n", "logical or ", list("NULL"), 
#&gt;                 " or raise an error. If \"yes\" is entered,\n", 
#&gt;                 "returns ", list("TRUE"), "; if \"no\" is entered, returns ", 
#&gt;                 list("FALSE"), "; if \"c\" is\n", "entered, ", 
#&gt;                 list("error_if_canceled=TRUE"), " will result in an error, otherwise\n", 
#&gt;                 "return ", list("NULL"), "\n"), "\n", list("\n", 
#&gt;                 "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask for an yes or no question. Users need to\n", 
#&gt;                 "enter \"y\", \"yes\" for yes, \"n\", \"no\" or no, and \"c\" for cancel\n", 
#&gt;                 "(case-insensitive).\n", "\n", "This can only be used in an ", 
#&gt;                 list(list("interactive")), " session.\n"), "\n", 
#&gt;             list("\n", "if(interactive()){\n", "ask_yesno('Do you know how hard it is to submit an R package and ',\n", 
#&gt;                 "          'pass the CRAN checks?')\n", "ask_yesno('Can I pass the CRAN check this time?')\n", 
#&gt;                 "}\n"), "\n", list("\n", list(list("cat2")), 
#&gt;                 ", ", list(list("readline")), ",\n", list(list(
#&gt;                   "ask_or_default")), "\n"), "\n"), async.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async"), "\n", list("async"), "\n", list("Evaluate expression in ", 
#&gt;                 list("async_expr")), "\n", list("\n", "async(expr)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression")), 
#&gt;                 "\n"), "\n", list("\n", "Evaluate expression in ", 
#&gt;                 list("async_expr"), "\n"), "\n", list("\n", list(
#&gt;                 list("async_expr")), "\n"), "\n"), async_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_expr"), "\n", list("async_expr"), "\n", 
#&gt;             list("Apply R expressions in a parallel way"), "\n", 
#&gt;             list("\n", "async_expr(\n", "  .X,\n", "  .expr,\n", 
#&gt;                 "  .varname = \"x\",\n", "  envir = parent.frame(),\n", 
#&gt;                 "  .pre_run = NULL,\n", "  .ncore = future::availableCores(),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 ".X"), list("a vector or a list to apply evaluation on")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression, unquoted")), 
#&gt;                 "\n", "\n", list(list(".varname"), list("variable name representing element of each ", 
#&gt;                   list(".X"))), "\n", "\n", list(list("envir"), 
#&gt;                   list("environment to evaluate expressions")), 
#&gt;                 "\n", "\n", list(list(".pre_run"), list("expressions to be evaluated before looping.")), 
#&gt;                 "\n", "\n", list(list(".ncore"), list("number of CPU cores")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("future::future"))), "\n"), "\n", list(
#&gt;                 "\n", "a list whose length equals to ", list(
#&gt;                   ".X"), ". The value of each item\n", "returned depends on whether ", 
#&gt;                 list("async"), " is called. See details for workflow.\n"), 
#&gt;             "\n", list("\n", "Apply R expressions in a parallel way\n"), 
#&gt;             "\n", list("\n", list("async_expr"), " uses ", list(
#&gt;                 "lapply"), " and ", list("future::future"), " internally.\n", 
#&gt;                 "Within each loop, an item in ", list("\".X\""), 
#&gt;                 " will be assigned to variable ", list("\"x\""), 
#&gt;                 "\n", "(defined by ", list("\".varname\""), ") and enter the evaluation. During the evaluation,\n", 
#&gt;                 "function ", list("async"), " is provided. Expressions within ", 
#&gt;                 list("async"), " will be\n", "evaluated in another session, otherwise will be evaluated in current session.\n", 
#&gt;                 "Below is the workflow:\n", list("\n", "  ", 
#&gt;                   list(), " Run ", list(".pre_run"), "\n", "  ", 
#&gt;                   list(), " For ", list("i"), " in ", list("seq_along(.X)"), 
#&gt;                   ":\n", "  ", list("\n", "    ", list(), " 1. Assign ", 
#&gt;                     list("x"), " with ", list(".X[[i]]"), ", variable name ", 
#&gt;                     list("x"), " is\n", "    defined by ", list(
#&gt;                       ".varname"), "\n", "    ", list(), " 2. Evaluate ", 
#&gt;                     list("expr"), " in current session.\n", "    ", 
#&gt;                     list("\n", "      ", list(), " a. If ", list(
#&gt;                       "async"), " is not called, return evaluated ", 
#&gt;                       list("expr"), "\n", "      ", list(), " b. If ", 
#&gt;                       list("async(aync_expr)"), " is called, evaluate ", 
#&gt;                       list("aync_expr"), "\n", "      in another session, and return the evaluation results if ", 
#&gt;                       list("aync_expr"), "\n", "    "), "\n", 
#&gt;                     "  "), "\n"), "\n"), "\n"), async_flapply.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_flapply"), "\n", list("async_flapply"), 
#&gt;             "\n", list("Wrapper for ", list("future.apply::future_lapply")), 
#&gt;             "\n", list("\n", "async_flapply(X, FUN, ...)\n"), 
#&gt;             "\n", list("\n", list(list("X, FUN, ..."), list("passing to ", 
#&gt;                 list("future.apply::future_lapply"))), "\n"), 
#&gt;             "\n", list("\n", "Wrapper for ", list("future.apply::future_lapply"), 
#&gt;                 "\n"), "\n", list("\n", list(list("future_lapply")), 
#&gt;                 "\n"), "\n"), base64_to_image.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("base64_to_image"), "\n", list("base64_to_image"), 
#&gt;             "\n", list("Save \"Base64\" Data to Images"), "\n", 
#&gt;             list("\n", "base64_to_image(data, path)\n"), "\n", 
#&gt;             list("\n", list(list("data"), list("characters, encoded \"Base64\" data for images")), 
#&gt;                 "\n", "\n", list(list("path"), list("file path to save to")), 
#&gt;                 "\n"), "\n", list("\n", "Absolute path of the saved file\n"), 
#&gt;             "\n", list("\n", "Save \"Base64\" Data to Images\n"), 
#&gt;             "\n"), baseline_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-baseline_array.R", 
#&gt;             "\n", list("baseline_array"), "\n", list("baseline_array"), 
#&gt;             "\n", list("Calculate Contrasts of Arrays in Different Methods"), 
#&gt;             "\n", list("\n", "baseline_array(\n", "  x,\n", "  along_dim,\n", 
#&gt;                 "  baseline_indexpoints,\n", "  unit_dims = seq_along(dim(x))[-along_dim],\n", 
#&gt;                 "  method = c(\"percentage\", \"sqrt_percentage\", \"decibel\", \"zscore\", \"sqrt_zscore\")\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("x"), list(
#&gt;                 "array (tensor) to calculate contrast")), "\n", 
#&gt;                 "\n", list(list("along_dim"), list("integer range from 1 to the maximum dimension of ", 
#&gt;                   list("x"), ".\n", "baseline along this dimension, this is usually the time dimension.")), 
#&gt;                 "\n", "\n", list(list("baseline_indexpoints"), 
#&gt;                   list("integer vector, which index points are counted\n", 
#&gt;                     "into baseline window? Each index ranges from 1 to ", 
#&gt;                     list("dim(x)[[along_dim]]"), ".\n", "See Details.")), 
#&gt;                 "\n", "\n", list(list("unit_dims"), list("integer vector, baseline unit: see Details.")), 
#&gt;                 "\n", "\n", list(list("method"), list("character, baseline method options are:\n", 
#&gt;                   list("\"percentage\""), ", ", list("\"sqrt_percentage\""), 
#&gt;                   ", ", list("\"decibel\""), ",\n", list("\"zscore\""), 
#&gt;                   ", and ", list("\"sqrt_zscore\""))), "\n"), 
#&gt;             "\n", list("\n", "Contrast array with the same dimension as ", 
#&gt;                 list("x"), ".\n"), "\n", list("\n", "Provides five methods to baseline an array and calculate\n", 
#&gt;                 "contrast.\n"), "\n", list("\n", "Consider a scenario where we want to baseline a bunch of signals recorded\n", 
#&gt;                 "from different locations. For each location, we record ", 
#&gt;                 list("n"), " sessions.\n", "For each session, the signal is further decomposed into frequency-time\n", 
#&gt;                 "domain. In this case, we have the input ", list(
#&gt;                   "x"), " in the following form:\n", list(list(
#&gt;                   "session x frequency x time x location")), 
#&gt;                 "\n", "Now we want to calibrate signals for each session, frequency and location\n", 
#&gt;                 "using the first 100 time points as baseline points, then the code will be\n", 
#&gt;                 list(list("baseline_array(x, along_dim=3, 1:100, unit_dims=c(1,2,4))")), 
#&gt;                 "\n", list("along_dim=3"), " is dimension of time, in this case, it's the\n", 
#&gt;                 "third dimension of ", list("x"), ". ", list(
#&gt;                   "baseline_indexpoints=1:100"), ", meaning\n", 
#&gt;                 "the first 100 time points are used to calculate baseline.\n", 
#&gt;                 list("unit_dims"), " defines the unit signal. Its value ", 
#&gt;                 list("c(1,2,4)"), "\n", "means the unit signal is per session (first dimension), per frequency\n", 
#&gt;                 "(second) and per location (fourth).\n", "\n", 
#&gt;                 "In some other cases, we might want to calculate baseline across frequencies\n", 
#&gt;                 "then the unit signal is ", list(list("frequency x time")), 
#&gt;                 ", i.e. signals that share the\n", "same session and location also share the same baseline. In this case,\n", 
#&gt;                 "we assign ", list("unit_dims=c(1,4)"), ".\n", 
#&gt;                 "\n", "There are five baseline methods. They fit for different types of data.\n", 
#&gt;                 "Denote ", list(list("z")), " is an unit signal, ", 
#&gt;                 list(list("z_0")), " is its baseline slice. Then\n", 
#&gt;                 "these baseline methods are:\n", "\n", list("\n", 
#&gt;                   list(list(list("\"percentage\"")), list("\n", 
#&gt;                     list(list("\n", "  \\frac{z - \\bar{z_{0}}}{\\bar{z_{0}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (z / mean(z_0) - 1) x 100%\n")), 
#&gt;                     "\n")), "\n", list(list(list("\"sqrt_percentage\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z} - \\bar{\\sqrt{z_{0}}}}{\\bar{\\sqrt{z_{0}}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (sqrt(z) / mean(sqrt(z_0)) - 1) x 100%\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"decibel\"")), 
#&gt;                     list("\n", list(list("\n", "  10 \\times ( \\log_{10}(z) - \\bar{\\log_{10}(z_{0})} )\n"), 
#&gt;                       list("\n", "  10 * ( log10 (z) - mean( log10(z_0) ) )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{z-\\bar{z_{0}}}{sd(z_{0})}\n"), 
#&gt;                       list("\n", "  (z - mean( z_0 )) / sd( z_0 )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"sqrt_zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z}-\\bar{\\sqrt{z_{0}}}}{sd(\\sqrt{z_{0}})}\n"), 
#&gt;                       list("\n", "  (sqrt(z) - mean( sqrt(z_0) )) / sd( sqrt(z_0) )\n")), 
#&gt;                       "\n")), "\n", "\n", "\n"), "\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(dipsaus)\n", "set.seed(1)\n", 
#&gt;                 "\n", "# Generate sample data\n", "dims = c(10,20,30,2)\n", 
#&gt;                 "x = array(rnorm(prod(dims))^2, dims)\n", "\n", 
#&gt;                 "# Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "baseline_window = sample(30, 10)\n", "\n", "# ----- baseline percentage change ------\n", 
#&gt;                 "\n", "# Using base functions\n", "re1 &lt;- aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "  m &lt;- mean(y[baseline_window])\n", "  (y/m - 1) * 100\n", 
#&gt;                 "}), c(2,3,1,4))\n", "\n", "# Using dipsaus\n", 
#&gt;                 "re2 &lt;- baseline_array(x, 3, baseline_window, c(1,2,4),\n", 
#&gt;                 "                      method = 'percentage')\n", 
#&gt;                 "\n", "# Check different, should be very tiny (double precisions)\n", 
#&gt;                 "range(re2 - re1)\n", "\n", "# Check speed for large dataset\n", 
#&gt;                 "if(interactive()){\n", "  dims = c(200,20,300,2)\n", 
#&gt;                 "  x = array(rnorm(prod(dims))^2, dims)\n", "  # Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "  baseline_window = seq_len(100)\n", "  f1 &lt;- function(){\n", 
#&gt;                 "    aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "      m &lt;- mean(y[baseline_window])\n", "      (y/m - 1) * 100\n", 
#&gt;                 "    }), c(2,3,1,4))\n", "  }\n", "  f2 &lt;- function(){\n", 
#&gt;                 "    # equivalent as bl = x[,,baseline_window, ]\n", 
#&gt;                 "    #\n", "    baseline_array(x, along_dim = 3,\n", 
#&gt;                 "                   baseline_indexpoints = baseline_window,\n", 
#&gt;                 "                   unit_dims = c(1,2,4), method = 'sqrt_percentage')\n", 
#&gt;                 "  }\n", "  microbenchmark::microbenchmark(f1(), f2(), times = 3L)\n", 
#&gt;                 "}\n", "\n", "\n", "\n"), "\n"), cat2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("cat2"), "\n", list("cat2"), "\n", list("Color Output"), 
#&gt;             "\n", list("\n", "cat2(\n", "  ...,\n", "  level = \"DEBUG\",\n", 
#&gt;                 "  print_level = FALSE,\n", "  file = \"\",\n", 
#&gt;                 "  sep = \" \",\n", "  fill = FALSE,\n", "  labels = NULL,\n", 
#&gt;                 "  append = FALSE,\n", "  end = \"\\n\",\n", 
#&gt;                 "  pal = list(DEBUG = \"grey60\", INFO = \"#1d9f34\", WARNING = \"#ec942c\", ERROR =\n", 
#&gt;                 "    \"#f02c2c\", FATAL = \"#763053\", DEFAULT = \"grey60\"),\n", 
#&gt;                 "  use_cli = TRUE,\n", "  bullet = \"auto\"\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("..."), list(
#&gt;                 "to be printed")), "\n", "\n", list(list("level"), 
#&gt;                 list("'DEBUG', 'INFO', 'WARNING', 'ERROR', or 'FATAL' (total 5 levels)")), 
#&gt;                 "\n", "\n", list(list("print_level"), list("if true, prepend levels before messages")), 
#&gt;                 "\n", "\n", list(list("file, sep, fill, labels, append"), 
#&gt;                   list("pass to ", list("base::cat"))), "\n", 
#&gt;                 "\n", list(list("end"), list("character to append to the string")), 
#&gt;                 "\n", "\n", list(list("pal"), list("a named list defining colors see details")), 
#&gt;                 "\n", "\n", list(list("use_cli"), list("logical, whether to use package 'cli'")), 
#&gt;                 "\n", "\n", list(list("bullet"), list("character, if use 'cli', which symbol to show. see\n", 
#&gt;                   list(list("symbol")))), "\n"), "\n", list("\n", 
#&gt;                 "none.\n"), "\n", list("\n", "Color Output\n"), 
#&gt;             "\n", list("\n", "There are five levels of colors by default: 'DEBUG', 'INFO', 'WARNING', 'ERROR',\n", 
#&gt;                 "or FATAL. Default colors are: 'DEBUG' (", list(
#&gt;                   "grey60"), "), 'INFO' (", list("#1d9f34"), 
#&gt;                 "), 'WARNING'\n", "(", list("#ec942c"), "), 'ERROR' (", 
#&gt;                 list("#f02c2c"), "), 'FATAL' (", list("#763053"), 
#&gt;                 ") and\n", "'DEFAULT' (", list("#000000"), ", black). If level is not in preset five levels,\n", 
#&gt;                 "the color will be \"default\"-black color.\n"), 
#&gt;             "\n"), check_installed_packages.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("check_installed_packages"), "\n", list(
#&gt;                 "check_installed_packages"), "\n", list("Check If Packages Are Installed, Returns Missing Packages"), 
#&gt;             "\n", list("\n", "check_installed_packages(\n", "  pkgs,\n", 
#&gt;                 "  libs = base::.libPaths(),\n", "  auto_install = FALSE,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "pkgs"), list("vector of packages to install")), 
#&gt;                 "\n", "\n", list(list("libs"), list("paths of libraries")), 
#&gt;                 "\n", "\n", list(list("auto_install"), list("automatically install packages if missing")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters for ", 
#&gt;                   list("install.packages"))), "\n"), "\n", list(
#&gt;                 "\n", "package names that are not installed\n"), 
#&gt;             "\n", list("\n", "Check If Packages Are Installed, Returns Missing Packages\n"), 
#&gt;             "\n"), col2hexStr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("col2hexStr"), "\n", list("col2hexStr"), 
#&gt;             "\n", list("Convert color to Hex string"), "\n", 
#&gt;             list("\n", "col2hexStr(col, alpha = NULL, prefix = \"#\", ...)\n"), 
#&gt;             "\n", list("\n", list(list("col"), list("character or integer indicating color")), 
#&gt;                 "\n", "\n", list(list("alpha"), list(list("NULL"), 
#&gt;                   " or numeric, transparency. See ", list("grDevices::rgb"))), 
#&gt;                 "\n", "\n", list(list("prefix"), list("character, default is ", 
#&gt;                   list("\"#\""))), "\n", "\n", list(list("..."), 
#&gt;                   list("passing to  ", list(list("adjustcolor")))), 
#&gt;                 "\n"), "\n", list("\n", "characters containing the hex value of each color. See details\n"), 
#&gt;             "\n", list("\n", "Convert color to Hex string\n"), 
#&gt;             "\n", list("\n", list("col2hexStr"), " converts colors such as 1, 2, 3, \"red\", \"blue\", ... into\n", 
#&gt;                 "hex strings that can be easily recognized by `HTML`, `CSS` and `JavaScript`.\n", 
#&gt;                 "Internally this function uses ", list(list("adjustcolor")), 
#&gt;                 " with two differences:\n", list("\n", list(), 
#&gt;                   " the returned hex string does not contain alpha value if ", 
#&gt;                   list("alpha"), " is ", list("NULL"), ";\n", 
#&gt;                   list(), " the leading prefix \"#\" can be customized\n"), 
#&gt;                 "\n"), "\n", list("\n", "\n", "col2hexStr(1, prefix = '0x')      # \"0x000000\"\n", 
#&gt;                 "col2hexStr('blue')                # \"#0000FF\"\n", 
#&gt;                 "\n", "# Change default palette, see \"grDevices::colors()\"\n", 
#&gt;                 "grDevices::palette(c('orange3', 'skyblue1'))\n", 
#&gt;                 "col2hexStr(1)                     # Instead of #000000, #CD8500\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("adjustcolor")), 
#&gt;                 "\n"), "\n"), collapse.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("collapse"), "\n", list("collapse"), "\n", 
#&gt;             list("Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "collapse(x, keep, average = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A numeric multi-mode tensor (array), without ", 
#&gt;                 list("NA"))), "\n", "\n", list(list("keep"), 
#&gt;                 list("Which dimension to keep")), "\n", "\n", 
#&gt;                 list(list("average"), list("collapse to sum or mean")), 
#&gt;                 "\n"), "\n", list("\n", "a collapsed array with values to be mean or summation along\n", 
#&gt;                 "collapsing dimensions\n"), "\n", list("\n", 
#&gt;                 "Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "# Example 1\n", 
#&gt;                 "x = matrix(1:16, 4)\n", "\n", "# Keep the first dimension and calculate sums along the rest\n", 
#&gt;                 "collapse(x, keep = 1)\n", "rowSums(x)  # Should yield the same result\n", 
#&gt;                 "\n", "# Example 2\n", "x = array(1:120, dim = c(2,3,4,5))\n", 
#&gt;                 "result = collapse(x, keep = c(3,2))\n", "compare = apply(x, c(3,2), sum)\n", 
#&gt;                 "sum(abs(result - compare)) # The same, yield 0 or very small number (1e-10)\n", 
#&gt;                 "\n", "# Example 3 (performance)\n", "RcppParallel::setThreadOptions(numThreads = -1) # auto multicores\n", 
#&gt;                 "# Small data, no big difference, even slower\n", 
#&gt;                 "x = array(rnorm(240), dim = c(4,5,6,2))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L, check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  }\n", ")\n", "\n", "# large data big difference\n", 
#&gt;                 "x = array(rnorm(prod(300,200,105)), c(300,200,105,1))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L , check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  })\n", "\n"), "\n"), compoundInput2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("compoundInput2"), "\n", list("compoundInput2"), 
#&gt;             "\n", list("Compound input that combines and extends shiny inputs"), 
#&gt;             "\n", list("\n", "compoundInput2(\n", "  inputId,\n", 
#&gt;                 "  label = \"Group\",\n", "  components = shiny::tagList(),\n", 
#&gt;                 "  initial_ncomp = 1,\n", "  min_ncomp = 0,\n", 
#&gt;                 "  max_ncomp = 10,\n", "  value = NULL,\n", "  label_color = 1,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "inputId"), list("character, shiny input ID")), 
#&gt;                 "\n", "\n", list(list("label"), list("character, will show on each groups")), 
#&gt;                 "\n", "\n", list(list("components"), list("`HTML` tags that defines and combines HTML components within groups")), 
#&gt;                 "\n", "\n", list(list("initial_ncomp"), list(
#&gt;                   "numeric initial number of groups to show, non-negative")), 
#&gt;                 "\n", "\n", list(list("min_ncomp"), list("minimum number of groups, default is 0, non-negative")), 
#&gt;                 "\n", "\n", list(list("max_ncomp"), list("maximum number of groups, default is 10, greater or equal\n", 
#&gt;                   "than ", list("min_ncomp"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, initial values of each inputs, see examples.")), 
#&gt;                 "\n", "\n", list(list("label_color"), list("integer or characters, length of 1 or ", 
#&gt;                   list("max_ncomp"), ",\n", "assigning colors to each group labels,")), 
#&gt;                 "\n", "\n", list(list("..."), list("will be ignored")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Compound input that combines and extends shiny inputs\n"), 
#&gt;             "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    list(),                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "# Source - system.file('demo/example-compountInput2.R', package='dipsaus')\n", 
#&gt;                 "\n", "# demo('example-compountInput2', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  fluidRow(\n", "    column(\n", 
#&gt;                 "      width = 4,\n", "      compoundInput2(\n", 
#&gt;                 "        'compound', 'Group Label', label_color = 1:10,\n", 
#&gt;                 "        components = div(\n", "          textInput('txt', 'Text'),\n", 
#&gt;                 "          selectInput('sel', 'Select', choices = 1:10, multiple = TRUE),\n", 
#&gt;                 "          sliderInput('sli', 'Slider', max=1, min=0, val=0.5)\n", 
#&gt;                 "        ),\n", "        value = list(\n", "          list(txt = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "          '',                # no settings for second group\n", 
#&gt;                 "          list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "        )\n", "      ),\n", "      hr(),\n", 
#&gt;                 "      actionButton('action', 'Update compound input')\n", 
#&gt;                 "    )\n", "  )\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observe({\n", "    print(input$compound)\n", 
#&gt;                 "  })\n", "  observe({\n", "    # Getting specific input at group 1\n", 
#&gt;                 "    print(input$compound_txt_1)\n", "  })\n", 
#&gt;                 "  observeEvent(input$action, {\n", "    updateCompoundInput2(\n", 
#&gt;                 "      session, 'compound',\n", "      # Update values for each components\n", 
#&gt;                 "      value = lapply(1:5, function(ii){\n", 
#&gt;                 "        list(\n", "          txt = sample(LETTERS, 1),\n", 
#&gt;                 "          sel = sample(1:10, 3),\n", "          sli = runif(1)\n", 
#&gt;                 "        )\n", "      }), ncomp = NULL, txt = list(label = as.character(Sys.time())))\n", 
#&gt;                 "  })\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser = TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateCompoundInput2")), 
#&gt;                 " for how to update inputs\n"), "\n"), decorate_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("decorate_function"), "\n", list("decorate_function"), 
#&gt;             "\n", list("%D%"), "\n", list("Python-style decorator"), 
#&gt;             "\n", list("\n", "decorate_function(orig, decor, ...)\n", 
#&gt;                 "\n", "lhs %D% rhs\n"), "\n", list("\n", list(
#&gt;                 list("orig, lhs"), list("any function")), "\n", 
#&gt;                 "\n", list(list("decor, rhs"), list("decorator function that takes ", 
#&gt;                   list("orig"), " as its first\n", "argument")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("decor"))), "\n"), "\n", list("\n", "Python-style decorator\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# Example 1: basic usage\n", 
#&gt;                 "# Decorator that prints summary of results and return results itself\n", 
#&gt;                 "verbose_summary &lt;- function(...){\n", "  summary_args &lt;- list(...)\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      results &lt;- f(...)\n", 
#&gt;                 "\n", "\n", "      print(do.call(\n", "        summary,\n", 
#&gt;                 "        c(list(results), summary_args)\n", "      ))\n", 
#&gt;                 "      results\n", "\n", "    }\n", "  }\n", 
#&gt;                 "\n", "}\n", "\n", "# runs as.list, but through verbose_summary\n", 
#&gt;                 "as_list2 &lt;- decorate_function(as.list, verbose_summary)\n", 
#&gt;                 "\n", "# run test\n", "res &lt;- as_list2(1:3)  # will verbose summary\n", 
#&gt;                 "identical(res, as.list(1:3))\n", "\n", "# Example 2\n", 
#&gt;                 "x &lt;- 1:20\n", "y &lt;- x + rnorm(20)\n", "\n", 
#&gt;                 "# decorator, add a line with slope 1 with given intercept\n", 
#&gt;                 "abline_xy &lt;- function(b){\n", "  function(f){\n", 
#&gt;                 "    function(...){\n", "      f(...)\n", "      intercept &lt;- get_dots('intercept', 0, ...)\n", 
#&gt;                 "      abline(a = intercept, b = b)\n", "    }\n", 
#&gt;                 "  }\n", "}\n", "\n", "# orig, plot whatever x vs jittered+intercept\n", 
#&gt;                 "plot_xy &lt;- function(x, intercept = rnorm(1)){\n", 
#&gt;                 "  plot(x, jitter(x, amount = 3) + intercept)\n", 
#&gt;                 "}\n", "\n", "# new function that decorate plot_xy with abline_xy, and\n", 
#&gt;                 "# returns the intercept\n", "plot_xy2 &lt;- decorate_function(plot_xy, abline_xy, b = 1)\n", 
#&gt;                 "\n", "# alternatively, you might also want to try\n", 
#&gt;                 "plot_xy2 &lt;- plot_xy %D% abline_xy(b = 1)\n", 
#&gt;                 "\n", "plot_xy2(x = 1:20)\n", "\n"), "\n"), deparse_svec.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("deparse_svec"), "\n", list("deparse_svec"), 
#&gt;             "\n", list("Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "deparse_svec(\n", 
#&gt;                 "  nums,\n", "  connect = \"-\",\n", "  concatenate = TRUE,\n", 
#&gt;                 "  collapse = \",\",\n", "  max_lag = 1\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("nums"), list("integer vector")), 
#&gt;                 "\n", "\n", list(list("connect"), list("character used to connect consecutive numbers")), 
#&gt;                 "\n", "\n", list(list("concatenate"), list("connect strings if there are multiples")), 
#&gt;                 "\n", "\n", list(list("collapse"), list("if concatenate, character used to connect strings")), 
#&gt;                 "\n", "\n", list(list("max_lag"), list("defines \"consecutive\", min = 1")), 
#&gt;                 "\n"), "\n", list("\n", "strings representing the input vector. For example, ", 
#&gt;                 list("c(1, 2, 3)"), " returns \"1-3\".\n"), "\n", 
#&gt;             list("\n", "Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "deparse_svec(c(1:10, 15:18))\n"), 
#&gt;             "\n", list("\n", list(list("parse_svec")), "\n"), 
#&gt;             "\n"), dev_create.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/graphics.R", 
#&gt;             "\n", list("dev_create"), "\n", list("dev_create"), 
#&gt;             "\n", list("Create a group of named graphic devices"), 
#&gt;             "\n", list("\n", "dev_create(..., env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("named expressions to launch devices")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate expressions")), 
#&gt;                 "\n"), "\n", list("\n", "A list of functions to query, control, and switch between devices\n"), 
#&gt;             "\n", list("\n", "Create a group of named graphic devices\n"), 
#&gt;             "\n", list("\n", list(" ## Unix-specific example\n", 
#&gt;                 "\n", "# Create multiple named devices\n", "devs &lt;- dev_create(line = X11(), points = x11())\n", 
#&gt;                 "\n", "# switch to device named \"points\"\n", 
#&gt;                 "\n", "devs$dev_which('points')\n", "plot(1:10)\n", 
#&gt;                 "\n", "# switch to \"line\" device\n", "devs$dev_switch('line')\n", 
#&gt;                 "plot(1:100, type='l')\n", "\n", "# Create another group with conflict name\n", 
#&gt;                 "dev_another &lt;- dev_create(line = X11())\n", 
#&gt;                 "\n", "# Query device name with 'line'\n", "dev_another$dev_which('line')  # 4\n", 
#&gt;                 "devs$dev_which('line')  # 2, doesn't conflict with the new groups\n", 
#&gt;                 "\n", "dev.list()\n", "# close one or more device\n", 
#&gt;                 "dev_another$dev_off('line')\n", "dev.list()\n", 
#&gt;                 "\n", "# close all devices\n", "devs$dev_off()\n", 
#&gt;                 "dev.list()\n", "\n"), "\n"), "\n"), do_aggregate.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("do_aggregate"), "\n", list("do_aggregate"), 
#&gt;             "\n", list("Make aggregate pipe-friendly"), "\n", 
#&gt;             list("\n", "do_aggregate(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("an R object")), "\n", 
#&gt;                 "\n", list(list("..."), list("other parameters passed to ", 
#&gt;                   list(list("aggregate")))), "\n"), "\n", list(
#&gt;                 "\n", "Results from ", list(list("aggregate")), 
#&gt;                 "\n"), "\n", list("\n", "A pipe-friendly wrapper of ", 
#&gt;                 list(list("aggregate")), "\n", "when using formula as input.\n"), 
#&gt;             "\n", list("\n", "\n", "library(magrittr)\n", "data(ToothGrowth)\n", 
#&gt;                 "\n", "ToothGrowth %&gt;%\n", "  do_aggregate(len ~ ., mean)\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("aggregate")), 
#&gt;                 "\n"), "\n"), drop_nulls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("drop_nulls"), "\n", list("drop_nulls"), 
#&gt;             "\n", list("Drop ", list("NULL"), " values from list or vectors"), 
#&gt;             "\n", list("\n", "drop_nulls(x, .invalids = list(\"is.null\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("list to check")), 
#&gt;                 "\n", "\n", list(list(".invalids"), list("a list of functions, or function name. Default is 'is.null'.")), 
#&gt;                 "\n"), "\n", list("\n", "list or vector containing no invalid values\n"), 
#&gt;             "\n", list("\n", "Drop ", list("NULL"), " values from list or vectors\n"), 
#&gt;             "\n", list("\n", "\n", "x &lt;- list(NULL,NULL,1,2)\n", 
#&gt;                 "drop_nulls(x)  # length of 2\n", "\n"), "\n"), 
#&gt;         eval_dirty.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("eval_dirty"), "\n", list("eval_dirty"), 
#&gt;             "\n", list("Evaluate expressions"), "\n", list("\n", 
#&gt;                 "eval_dirty(expr, env = parent.frame(), data = NULL, quoted = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression or 'rlang' quo")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate")), 
#&gt;                 "\n", "\n", list(list("data"), list("dataframe or list")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("Is the expression quoted? By default, this is ", 
#&gt;                   list("TRUE"), ".\n", "This is useful when you don't want to use an expression that is stored in a\n", 
#&gt;                   "variable; see examples")), "\n"), "\n", list(
#&gt;                 "\n", "the executed results of ", list("expr"), 
#&gt;                 " evaluated with side effects.\n"), "\n", list(
#&gt;                 "\n", "Evaluate expressions\n"), "\n", list("\n", 
#&gt;                 list("eval_dirty"), " uses ", list("base::eval()"), 
#&gt;                 " function to evaluate\n", "expressions. Compare to ", 
#&gt;                 list("rlang::eval_tidy"), ", which won't affect original\n", 
#&gt;                 "environment, ", list("eval_dirty"), " causes changes to the environment. Therefore\n", 
#&gt;                 "if ", list("expr"), " contains assignment, environment will be changed in this case.\n"), 
#&gt;             "\n", list("\n", "\n", "env = new.env(); env$a = 1\n", 
#&gt;                 "rlang::eval_tidy(quote({a &lt;- 111}), env = env)\n", 
#&gt;                 "print(env$a)  # Will be 1. This is because eval_tidy has no side effect\n", 
#&gt;                 "\n", "eval_dirty(quote({a &lt;- 111}), env)\n", 
#&gt;                 "print(env$a)  # 111, a is changed\n", "\n", 
#&gt;                 "# Unquoted case\n", "eval_dirty({a &lt;- 222}, env, quoted = FALSE)\n", 
#&gt;                 "print(env$a)\n", "\n"), "\n"), fastmap2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fastmap2.R", "\n", 
#&gt;             list("fastmap2"), "\n", list("fastmap2"), "\n", list(
#&gt;                 "[[.fastmap2"), "\n", list("$.fastmap2"), "\n", 
#&gt;             list("[[&lt;-.fastmap2"), "\n", list("$&lt;-.fastmap2"), 
#&gt;             "\n", list("[.fastmap2"), "\n", list("[&lt;-.fastmap2"), 
#&gt;             "\n", list("names.fastmap2"), "\n", list("print.fastmap2"), 
#&gt;             "\n", list("length.fastmap2"), "\n", list("as.list.fastmap2"), 
#&gt;             "\n", list("A Wrapper for ", list("fastmap::fastmap")), 
#&gt;             "\n", list("\n", "fastmap2(missing_default = NULL)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...)\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...) &lt;- value\n", 
#&gt;                 "\n", list(list("names"), list("fastmap2")), 
#&gt;                 "(x)\n", "\n", list(list("print"), list("fastmap2")), 
#&gt;                 "(x, ...)\n", "\n", list(list("length"), list(
#&gt;                   "fastmap2")), "(x)\n", "\n", list(list("as.list"), 
#&gt;                   list("fastmap2")), "(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("missing_default"), list("passed to ", 
#&gt;                   list("fastmap::fastmap"))), "\n", "\n", list(
#&gt;                   list("x"), list("a ", list("'fastmap2'"), " object")), 
#&gt;                 "\n", "\n", list(list("name"), list("name, or key of the value")), 
#&gt;                 "\n", "\n", list(list("value"), list("any R object")), 
#&gt;                 "\n", "\n", list(list("i, j"), list("vector of names")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to other methods")), 
#&gt;                 "\n"), "\n", list("\n", "A list of ", list("'fastmap2'"), 
#&gt;                 " instance\n"), "\n", list("\n", list(list("fastmap")), 
#&gt;                 "\n", "provides a key-value store where the keys are strings and the\n", 
#&gt;                 "values are any R objects. It differs from normal environment that\n", 
#&gt;                 list(list("fastmap")), " avoids memory leak. ", 
#&gt;                 list("fastmap2"), "\n", "is a wrapper for ", 
#&gt;                 list("fastmap"), ", which provides several generic\n", 
#&gt;                 "functions such that it has similar behaviors to lists or\n", 
#&gt;                 "environments\n"), "\n", list("\n", "\n", "## --------------------------- Basic Usage --------------------------\n", 
#&gt;                 "map &lt;- fastmap2()\n", "map$a = 1\n", "map$b = 2\n", 
#&gt;                 "print(map)\n", "\n", "map[c('a', 'b')]\n", "# Alternative way\n", 
#&gt;                 "map['a', 'b']\n", "\n", "map[c('c', 'd')] &lt;- 3:4\n", 
#&gt;                 "# or\n", "map['e', 'f'] &lt;- 5:6\n", "\n", "# The order is not guaranteed, unless sort=TRUE\n", 
#&gt;                 "as.list(map)\n", "as.list(map, sort=TRUE)\n", 
#&gt;                 "\n", "names(map)\n", "length(map)\n", "\n", 
#&gt;                 "## ----------------------- NULL value handles -----------------------\n", 
#&gt;                 "map$b &lt;- NULL\n", "names(map)   # 'b' still exists!\n", 
#&gt;                 "as.list(map) # 'b' is NULL, but still there\n", 
#&gt;                 "\n", "# to remove 'b', you have to use `@remove` method\n", 
#&gt;                 "map$`@remove`('b')\n", "\n", "## ---------------- Native fastmap::fastmap methods -----------------\n", 
#&gt;                 "\n", "# whether map has 'a'\n", "map$`@has`('a')\n", 
#&gt;                 "\n", "# Remove a name from list\n", "map$`@remove`('a')\n", 
#&gt;                 "\n", "# remove all from list\n", "map$`@reset`()\n", 
#&gt;                 "print(map)\n", "\n"), "\n"), forelse.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("forelse"), "\n", list("forelse"), "\n", list(
#&gt;                 "Python-style ", list("\"for-else\""), " function"), 
#&gt;             "\n", list("\n", "forelse(x, FUN, ALT_FUN = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("iterative R objects such as list, vector, etc.")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("function that applies to each ", 
#&gt;                   list("x"))), "\n", "\n", list(list("ALT_FUN"), 
#&gt;                   list("function that takes no argument or other types of R\n", 
#&gt;                     "object")), "\n"), "\n", list("\n", "If any ", 
#&gt;                 list("FUN"), " returns anything other than ", 
#&gt;                 list("NULL"), ",\n", "then the function returns the first none ", 
#&gt;                 list("NULL"), " object. If\n", "all ", list("x"), 
#&gt;                 " fed to ", list("FUN"), " return ", list("NULL"), 
#&gt;                 ", then this\n", "function returns ", list("ALT_FUN"), 
#&gt;                 " (if ", list("ALT_FUN"), " is not a function)\n", 
#&gt;                 "or the result of ", list("ALT_FUN()"), ".\n"), 
#&gt;             "\n", list("\n", "Provide Python-style ", list("\"for-else\""), 
#&gt;                 " that works as\n", "follows: for each element, execute \"for\" block, if there is break\n", 
#&gt;                 "while executing \"for\" block, then just stop and ignore the \"else\"\n", 
#&gt;                 "statement, otherwise run \"else\" block.\n"), 
#&gt;             "\n", list("\n", "\n", "# --------------------------- Basic Usage ------------------------------\n", 
#&gt;                 "\n", "# 1. ALT_FUN get executed because FUN returns NULL for all items in x\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x &gt; 10) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  function(){\n", "    cat('ALT_FUN is executed!\\n')\n", 
#&gt;                 "    'wow'\n", "  }\n", ")\n", "\n", "# 2. FUN returns non-NULL object\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  'wow'\n", ")\n", "\n", "# --------------------------- Performance ------------------------------\n", 
#&gt;                 "FUN &lt;- function(x){\n", "  Sys.sleep(0.01)\n", 
#&gt;                 "  if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "}\n", "\n", "microbenchmark::microbenchmark({\n", 
#&gt;                 "  forelse(1:10, FUN, 'wow')\n", "}, {\n", "  y &lt;- unlist(lapply(1:10, FUN))\n", 
#&gt;                 "  if(length(y)){\n", "    y &lt;- y[[1]]\n", "  }else{\n", 
#&gt;                 "    y &lt;- 'wow'\n", "  }\n", "}, {\n", "  y &lt;- NULL\n", 
#&gt;                 "  for(x in 1:10){ y &lt;- FUN(x) }\n", "  if(is.null(y)){ y &lt;- 'wow' }\n", 
#&gt;                 "}, times = 3)\n", "\n", "\n"), "\n"), getInputBinding.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("getInputBinding"), "\n", list("getInputBinding"), 
#&gt;             "\n", list("Obtain registered input bindings"), "\n", 
#&gt;             list("\n", "getInputBinding(fname, pkg = NULL, envir = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("input function name, character or quoted expression\n", 
#&gt;                 "such as ", list("'shiny::textInput'"), " or ", 
#&gt;                 list("numericInput"), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("(optional), name of package")), 
#&gt;                 "\n", "\n", list(list("envir"), list("environment to evaluate ", 
#&gt;                   list("fname"), " if ", list("pkg"), " is not provided")), 
#&gt;                 "\n"), "\n", list("\n", "a list containing: 1. `JavaScript` input binding name; 2. `R` updating function name\n"), 
#&gt;             "\n", list("\n", "Obtain registered input bindings\n"), 
#&gt;             "\n", list("\n", "\n", "library(dipsaus)\n", "\n", 
#&gt;                 "# Most recommended usage\n", "getInputBinding('compoundInput2', pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Other usages\n", "getInputBinding('shiny::textInput')\n", 
#&gt;                 "\n", "\n", "getInputBinding(shiny::textInput)\n", 
#&gt;                 "\n", "getInputBinding(compoundInput2, pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Bad usage, raise errors in some cases\n", 
#&gt;                 list("\n", "## You need to library(shiny), or set envir=asNamespace('shiny'), or pkg='shiny'\n", 
#&gt;                   "getInputBinding('textInput')\n", "getInputBinding(textInput) # also fails\n", 
#&gt;                   "\n", "## Always fails\n", "getInputBinding('dipsaus::compoundInput2', pkg = 'dipsaus')\n"), 
#&gt;                 "\n", "\n"), "\n"), get_cpu.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_cpu"), "\n", list("get_cpu"), "\n", 
#&gt;             list("Get CPU Chip-set Information"), "\n", list(
#&gt;                 "\n", "get_cpu()\n"), "\n", list("\n", "a list of vendor ID and CPU model name\n"), 
#&gt;             "\n", list("\n", "Get CPU Chip-set Information\n"), 
#&gt;             "\n"), get_dots.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("get_dots"), "\n", list("get_dots"), "\n", 
#&gt;             list("Get element from dots ", list("'...'")), "\n", 
#&gt;             list("\n", "get_dots(..name, ..default = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("..name"), list("character name of the argument")), 
#&gt;                 "\n", "\n", list(list("..default"), list("R object to return if argument not found")), 
#&gt;                 "\n", "\n", list(list("..."), list("dots that contains argument")), 
#&gt;                 "\n"), "\n", list("\n", "Get specific key values from ", 
#&gt;                 list("'...'"), " without\n", "evaluating the rest of arguments.\n"), 
#&gt;             "\n", list("\n", "One could use ", list("list(...)[[name]]"), 
#&gt;                 " to extract any keys\n", "from the dots. However, such way reduces code readability. If\n", 
#&gt;                 "some arguments have not evaluated, ", list("list(...)"), 
#&gt;                 " will\n", list(list("force")), " evaluating them. Normally it's fine if\n", 
#&gt;                 "these expressions take little time to run, but if the\n", 
#&gt;                 "expression require time to run, ", list(list(
#&gt;                   "get_dots")), " avoids\n", "unnecessary evaluations.\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# ------------------------ Basic Usage ---------------------------\n", 
#&gt;                 "plot2 &lt;- function(...){\n", "  title = get_dots('main', 'There is no title', ...)\n", 
#&gt;                 "  plot(...)\n", "  title\n", "}\n", "\n", "plot2(1:10)\n", 
#&gt;                 "plot2(1:10, main = 'Scatter Plot of 1:10')\n", 
#&gt;                 "\n", "# ------------------------ Comparisons ----------------------------\n", 
#&gt;                 "f1 &lt;- function(...){ get_dots('x', ...) }\n", 
#&gt;                 "f2 &lt;- function(...){ list(...)[['x']] }\n", 
#&gt;                 "delayedAssign('y', { cat('y is evaluated!') })\n", 
#&gt;                 "\n", "# y will not evaluate\n", "f1(x = 1, y = y)\n", 
#&gt;                 "\n", "# y gets evaluated\n", "f2(x = 1, y = y)\n", 
#&gt;                 "\n", "# -------------------- Decorator example --------------------------\n", 
#&gt;                 "ret_range &lt;- function(which_range = 'y'){\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      f(...)\n", 
#&gt;                 "      y_range &lt;- range(get_dots(which_range, 0, ...))\n", 
#&gt;                 "      y_range\n", "    }\n", "  }\n", "}\n", 
#&gt;                 "plot_ret_yrange &lt;- plot %D% ret_range('y')\n", 
#&gt;                 "plot_ret_yrange(x = 1:10, y = rnorm(10))\n", 
#&gt;                 "\n", "\n"), "\n"), get_ram.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_ram"), "\n", list("get_ram"), "\n", 
#&gt;             list("Get Memory Size"), "\n", list("\n", "get_ram()\n"), 
#&gt;             "\n", list("\n", "numeric in Bytes how big your system RAM is\n"), 
#&gt;             "\n", list("\n", "Get Memory Size\n"), "\n"), `grapes-equals-greater-than-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%=&gt;%"), "\n", list("%=&gt;%"), "\n", list("A JavaScript style of creating functions"), 
#&gt;             "\n", list("\n", "args %=&gt;% expr\n"), "\n", list(
#&gt;                 "\n", list(list("args"), list("function arguments: see ", 
#&gt;                   list(list("formals")))), "\n", "\n", list(list(
#&gt;                   "expr"), list("R expression that forms the body of functions: see ", 
#&gt;                   list(list("body")))), "\n"), "\n", list("\n", 
#&gt;                 "A function that takes ", list("args"), " as parameters and ", 
#&gt;                 list("expr"), " as\n", "the function body\n"), 
#&gt;             "\n", list("\n", "A JavaScript style of creating functions\n"), 
#&gt;             "\n", list("\n", "# Formal arguments\n", "c(a) %=&gt;% {\n", 
#&gt;                 "  print(a)\n", "}\n", "\n", "# Informal arguments\n", 
#&gt;                 "list(a=) %=&gt;% {\n", "  print(a)\n", "}\n", "\n", 
#&gt;                 "# Multiple inputs\n", "c(a, b = 2, ...) %=&gt;% {\n", 
#&gt;                 "  print(c(a, b, ...))\n", "}\n", "\n", "# ----- JavaScript style of forEach -----\n", 
#&gt;                 "# ### Equivalent JavaScript Code:\n", "# LETTERS.forEach((el, ii) =&gt; {\n", 
#&gt;                 "#   console.log('The index of letter ' + el + ' in \"x\" is: ' + ii);\n", 
#&gt;                 "# });\n", "\n", "iapply(LETTERS, c(el, ii) %=&gt;% {\n", 
#&gt;                 "  cat2('The index of letter ', el, ' in ', sQuote('x'), ' is: ', ii)\n", 
#&gt;                 "}) -&gt; results\n"), "\n"), `grapes-help-set-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%?&lt;-%"), "\n", list("%?&lt;-%"), "\n", list("Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens."), 
#&gt;             "\n", list("\n", "lhs %?&lt;-% value\n"), "\n", list(
#&gt;                 "\n", list(list("lhs"), list("an object to check or assign")), 
#&gt;                 "\n", "\n", list(list("value"), list("value to be assigned if lhs is NULL")), 
#&gt;                 "\n"), "\n", list("\n", "Assign value on the right-hand side to the left-hand side if\n", 
#&gt;                 list("lhs"), " does not exist or is ", list("NULL"), 
#&gt;                 "\n"), "\n", list("\n", "Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens.\n"), 
#&gt;             "\n", list("\n", "# Prepare, remove aaa if exists\n", 
#&gt;                 "if(exists('aaa', envir = globalenv(), inherits = FALSE)){\n", 
#&gt;                 "  rm(aaa, envir = globalenv())\n", "}\n", "\n", 
#&gt;                 "# Assign\n", "aaa %?&lt;-% 1; print(aaa)\n", "\n", 
#&gt;                 "# However, if assigned, nothing happens\n", 
#&gt;                 "aaa = 1;\n", "aaa %?&lt;-% 2;\n", "print(aaa)\n", 
#&gt;                 "\n", "# in a list\n", "a = list()\n", "a$e %?&lt;-% 1; print(a$e)\n", 
#&gt;                 "a$e %?&lt;-% 2; print(a$e)\n", "\n"), "\n"), `grapes-plus-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%+-%"), "\n", list("%+-%"), "\n", list("Plus-minus operator"), 
#&gt;             "\n", list("\n", "a %+-% b\n"), "\n", list("\n", 
#&gt;                 list(list("a, b"), list("numeric vectors, matrices or arrays")), 
#&gt;                 "\n"), "\n", list("\n", list("a +/- b"), ", the dimension depends on ", 
#&gt;                 list("a+b"), ". If ", list("a+b"), " is\n", "a scalar, returns a vector of two; in the case of vector, returns a matrix;\n", 
#&gt;                 "all other cases will return an array with the last dimension equal to 2.\n"), 
#&gt;             "\n", list("\n", "Plus-minus operator\n"), "\n", 
#&gt;             list("\n", "\n", "# scalar\n", "1 %+-% 2   # -1, 3\n", 
#&gt;                 "\n", "# vector input\n", "c(1,2,3) %+-% 2   # matrix\n", 
#&gt;                 "\n", "# matrix input\n", "matrix(1:9, 3) %+-% 2   # 3x3x2 array\n", 
#&gt;                 "\n"), "\n"), handler_dipsaus_progress.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("handler_dipsaus_progress"), "\n", list(
#&gt;                 "handler_dipsaus_progress"), "\n", list("Progress-bar Handler"), 
#&gt;             "\n", list("\n", "handler_dipsaus_progress(\n", "  title = getOption(\"dipsaus.progressr.title\", \"Progress\"),\n", 
#&gt;                 "  intrusiveness = getOption(\"progressr.intrusiveness.gui\", 1),\n", 
#&gt;                 "  target = if (is.null(shiny::getDefaultReactiveDomain())) \"terminal\" else \"gui\",\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "title"), list("default title of ", list(list(
#&gt;                 "progress2")))), "\n", "\n", list(list("intrusiveness"), 
#&gt;                 list("A non-negative scalar on how intrusive\n", 
#&gt;                   "(disruptive) the reporter to the user")), 
#&gt;                 "\n", "\n", list(list("target"), list("where progression updates are rendered")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("make_progression_handler")))), "\n"), 
#&gt;             "\n", list("\n", "Handler for ", list(list("progress2")), 
#&gt;                 " to support\n", list("progressr::handlers"), 
#&gt;                 ". See examples for detailed use case\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(progressr)\n", "library(shiny)\n", 
#&gt;                 "library(future)\n", "\n", "## ------------------------------ Setup! -------------------------------\n", 
#&gt;                 "handlers(handler_dipsaus_progress())\n", "\n", 
#&gt;                 "# ------------------------------ A simple usage ------------------------\n", 
#&gt;                 "xs &lt;- 1:5\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- lapply(xs, function(x) {\n", "    p(sprintf(\"x=%g\", x))\n", 
#&gt;                 "    Sys.sleep(0.1)\n", "    sqrt(x)\n", "  })\n", 
#&gt;                 "})\n", "\n", "# ------------------------ A future.apply case -------------------------\n", 
#&gt;                 "plan(sequential)\n", "# test it yourself with plan(multisession)\n", 
#&gt;                 "\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- future.apply::future_lapply(xs, function(x) {\n", 
#&gt;                 "    p(sprintf(\"x=%g\", x))\n", "    Sys.sleep(0.1)\n", 
#&gt;                 "    sqrt(x)\n", "  })\n", "})\n", "\n", "# ------------------------ A shiny case --------------------------------\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButton('ok', 'Run Demo')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  handlers(handler_dipsaus_progress())\n", "  make_forked_clusters()\n", 
#&gt;                 "\n", "  observeEvent(input$ok, {\n", "    with_progress({\n", 
#&gt;                 "      p &lt;- progressor(along = 1:100)\n", "      y &lt;- future.apply::future_lapply(1:100, function(x) {\n", 
#&gt;                 "        p(sprintf(\"Input %d|Result %d\", x, x+1))\n", 
#&gt;                 "        Sys.sleep(1)\n", "        x+1\n", "      })\n", 
#&gt;                 "    })\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n", 
#&gt;                 "\n"), "\n"), iapply.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/apply.R", 
#&gt;             "\n", list("iapply"), "\n", list("iapply"), "\n", 
#&gt;             list("Apply each elements with index as second input"), 
#&gt;             "\n", list("\n", "iapply(X, FUN, ..., .method = c(\"sapply\", \"lapply\", \"vapply\"))\n"), 
#&gt;             "\n", list("\n", list(list("X"), list("a vector (atomic or list)")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("the function to be applied to each element of ", 
#&gt;                   list("X"), ": see `Details`.")), "\n", "\n", 
#&gt;                 list(list("..."), list("passed to apply methods")), 
#&gt;                 "\n", "\n", list(list(".method"), list("method to use, default is ", 
#&gt;                   list(list("sapply")))), "\n"), "\n", list("\n", 
#&gt;                 "a list or matrix depends on ", list(".method"), 
#&gt;                 ". See ", list(list("lapply")), "\n"), "\n", 
#&gt;             list("\n", "Apply function with an index variable as the second input.\n"), 
#&gt;             "\n", list("\n", list("FUN"), " will be further passed to the apply methods. Unlike\n", 
#&gt;                 list(list("lapply")), ", ", list("FUN"), " is expected to have at least two arguments.\n", 
#&gt;                 "The first argument is each element of ", list(
#&gt;                   "X"), ", the second argument is the\n", "index number of the element.\n"), 
#&gt;             "\n"), lapply_async2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels-future.R", 
#&gt;             "\n", list("lapply_async2"), "\n", list("lapply_async2"), 
#&gt;             "\n", list("Apply, but in parallel"), "\n", list(
#&gt;                 "\n", "lapply_async2(\n", "  x,\n", "  FUN,\n", 
#&gt;                 "  FUN.args = list(),\n", "  callback = NULL,\n", 
#&gt;                 "  plan = TRUE,\n", "  future.chunk.size = NULL,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("vector, list")), "\n", "\n", list(
#&gt;                 list("FUN"), list("function to apply on each element of ", 
#&gt;                   list("x"))), "\n", "\n", list(list("FUN.args"), 
#&gt;                 list("more arguments to feed into ", list("FUN"))), 
#&gt;                 "\n", "\n", list(list("callback"), list("function to run after each iteration")), 
#&gt;                 "\n", "\n", list(list("plan"), list("logical, or character or ", 
#&gt;                   list("future"), " plan; see Details.")), "\n", 
#&gt;                 "\n", list(list("future.chunk.size"), list("see also\n", 
#&gt;                   list(list("future_eapply")), ". If you want the callbacks\n", 
#&gt;                   "to be called immediately after each loop, then set it to ", 
#&gt;                   list("1"), ",\n", "which is not optimal but the only way right now.")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("plan")))), "\n"), "\n", list("\n", 
#&gt;                 "same as\n", list("with(FUN.args, lapply(x, function(el){eval(body(FUN))}))"), 
#&gt;                 "\n"), "\n", list("\n", "Apply, but in parallel\n"), 
#&gt;             "\n", list("\n", "When ", list("plan"), " is logical, ", 
#&gt;                 list("FALSE"), " means use current plan.\n", 
#&gt;                 "If ", list("plan=TRUE"), ", then it equals to ", 
#&gt;                 list("plan='multicore'"), ". For\n", "characters, ", 
#&gt;                 list("plan"), " can be ", list("'multicore'"), 
#&gt;                 ", ", list("'callr'"), ",\n", list("'sequential'"), 
#&gt;                 ", ", list("'multisession'"), ", ", list("'multiprocess'"), 
#&gt;                 ",\n", "etc. Alternatively, you could pass future ", 
#&gt;                 list(list("plan")), "\n", "objects.\n"), "\n", 
#&gt;             list("\n", "\n", "library(future)\n", "plan(sequential)\n", 
#&gt;                 "\n", "# Use sequential plan\n", "# 1. Change `plan` to 'multicore', 'multisession', or TRUE to enable\n", 
#&gt;                 "# multi-core, but still with progress information\n", 
#&gt;                 "# 2. Change plan=FALSE will use current future plan\n", 
#&gt;                 "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = function(e){\n", 
#&gt;                 "  sprintf('Input=%d', e)\n", "}, plan = 'sequential')\n", 
#&gt;                 "\n", "# Disable callback message, then the function reduce to\n", 
#&gt;                 "# normal `future.apply::future_lapply`\n", "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = NULL, plan = FALSE)\n", 
#&gt;                 "\n", "\n"), "\n"), lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lock.R", 
#&gt;             "\n", list("lock"), "\n", list("lock"), "\n", list(
#&gt;                 "dipsaus_lock"), "\n", list("dipsaus_unlock"), 
#&gt;             "\n", list("Create or Unlock a Lock"), "\n", list(
#&gt;                 "\n", "dipsaus_lock(name, exclusive = TRUE, timeout = 10)\n", 
#&gt;                 "\n", "dipsaus_unlock(name, exclusive = TRUE, timeout = 10)\n"), 
#&gt;             "\n", list("\n", list(list("name"), list("character, the locker's name, must be only letters and digits")), 
#&gt;                 "\n", "\n", list(list("exclusive"), list("logical whether the locker is exclusive. True for write\n", 
#&gt;                   "access, False for read access. Default is true.")), 
#&gt;                 "\n", "\n", list(list("timeout"), list("numeric, seconds to wait for the locker to lock or unlock")), 
#&gt;                 "\n"), "\n", list("\n", "Logical, whether the operation succeed.\n"), 
#&gt;             "\n", list("\n", "A wrapper for ", list(list("lock")), 
#&gt;                 ", but user can\n", "interrupt the lock procedure anytime, and don't have to worry about\n", 
#&gt;                 "whether the lock exists or not.\n"), "\n", list(
#&gt;                 "\n", "# unlock to prepare for the example\n", 
#&gt;                 "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "# Create a locker, return TRUE\n", "lock_success = dipsaus_lock('testlocker')\n", 
#&gt;                 "if(lock_success){\n", "  cat2('testlocker has been locked')\n", 
#&gt;                 "}\n", "\n", "# test whether locker has been locked\n", 
#&gt;                 "lock_success = dipsaus_lock('testlocker', timeout = 0.01)\n", 
#&gt;                 "if(!lock_success){\n", "  cat2('attempt to lock testlocker failed')\n", 
#&gt;                 "}\n", "\n", "# unlock\n", "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "\n"), "\n"), make_async_evaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("make_async_evaluator"), "\n", list("make_async_evaluator"), 
#&gt;             "\n", list("Create Asynchronous Evaluator to Queue Tasks"), 
#&gt;             "\n", list("\n", "make_async_evaluator(\n", "  name,\n", 
#&gt;                 "  path = tempfile(),\n", "  n_nodes = 1,\n", 
#&gt;                 "  n_subnodes = future::availableCores() - 1,\n", 
#&gt;                 "  verbose = FALSE,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("name"), list("unique name for the evaluator")), 
#&gt;                 "\n", "\n", list(list("path"), list("blank directory for evaluator to store data")), 
#&gt;                 "\n", "\n", list(list("n_nodes"), list("number of control nodes, default is 1")), 
#&gt;                 "\n", "\n", list(list("n_subnodes"), list("number of sub-sessions for each control node, default is\n", 
#&gt;                   "the number of CPU cores minus 1")), "\n", 
#&gt;                 "\n", list(list("verbose"), list("for internal debug use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to the constructor of ", 
#&gt;                   list(list("MasterEvaluator")))), "\n"), "\n", 
#&gt;             list("\n", "Asynchronous evaluator aims at queuing R evaluations from sub-processes\n", 
#&gt;                 "without blocking the main session. It's based on ", 
#&gt;                 list("'parallel'"), " and\n", list("'future'"), 
#&gt;                 " packages.\n"), "\n", list("\n", list("'parallel'"), 
#&gt;                 " blocks the main session when evaluating expressions.\n", 
#&gt;                 list("'future'"), " blocks the main session when the number of running futures\n", 
#&gt;                 "exceed the maximum number of workers. (For example if 4 workers are planned,\n", 
#&gt;                 "then running 5 future instances at the same time will freeze the session).\n", 
#&gt;                 "\n", "Asynchronous evaluator is designed to queue any number of R expressions\n", 
#&gt;                 "without blocking the main session. The incoming expressions are stored in\n", 
#&gt;                 list(list("AbstractQueue")), " instances, and main session monitors\n", 
#&gt;                 "the queue and is charge of notifying child sessions to evaluate these\n", 
#&gt;                 "expressions whenever available.\n", "\n", "Important: Asynchronous evaluator is not designed for super high-performance\n", 
#&gt;                 "computing. The internal scheduler schedules ", 
#&gt;                 list("n_nodes"), " evaluations for\n", "every 1 second. Therefore if each of the process can be finished within\n", 
#&gt;                 list("1 / n_nodes"), " seconds, then use `future` instead.\n"), 
#&gt;             "\n", list(list("Value"), list("\n", "\n", "\n", 
#&gt;                 "A list of functions to control the evaluator:\n", 
#&gt;                 "\n", list("\n", "\n", list(list(list("run(expr, success = NULL, failure = NULL, priority = 0,\n", 
#&gt;                   "persist = FALSE, quoted = FALSE, ..., .list = NULL)")), 
#&gt;                   list("\n", "Queue and run an R expression.\n", 
#&gt;                     "\n", list("\n", "\n", list(list(list("expr")), 
#&gt;                       list("\n", " can be anything except for\n", 
#&gt;                         list("q()"), ", which terminates the session. ", 
#&gt;                         list("'rlang'"), "\n", list(list("nse-force")), 
#&gt;                         " is also supported. For example, you\n", 
#&gt;                         "can use ", list("`!!`"), " to quasi-quote the expression and unquote the values.\n")), 
#&gt;                       "\n", "\n", list(list(list("..., .list")), 
#&gt;                         list("\n", "provides additional data for ", 
#&gt;                           list("expr"), ". For example,\n", list(
#&gt;                             "expr"), " uses a large data object ", 
#&gt;                           list("dat"), " in the main session, which\n", 
#&gt;                           "might not be available to the child sessions. Also because the object\n", 
#&gt;                           "is large, quasi-quotation could be slow or fail. By passing ", 
#&gt;                           list("dat=..."), "\n", "or ", list(
#&gt;                             ".list=list(dat=...)"), ", it's able to temporary store the data on\n", 
#&gt;                           "hard-drive and persist for evaluators. The back-end is using\n", 
#&gt;                           list(list("qs_map")), ", which is super fast for data that are no\n", 
#&gt;                           "more than ", list("2GB"), ".\n")), 
#&gt;                       "\n", "\n", list(list(list("success"), 
#&gt;                         " and ", list("failure")), list("\n", 
#&gt;                         "functions to handle the results once\n", 
#&gt;                         "the evaluator returns the value. Since it's almost impossible to know\n", 
#&gt;                         "when the evaluator returns values, it's recommended that these functions\n", 
#&gt;                         "to be simple.\n")), "\n", "\n", list(
#&gt;                         list(list("priority")), list("\n", "puts the priority of the expression. It can only be `0` or\n", 
#&gt;                           "`1`. Evaluators will run expressions with priority equal to 1 first.\n")), 
#&gt;                       "\n", "\n", list(list(list("persist")), 
#&gt;                         list("\n", "indicates whether to run the expression and persist\n", 
#&gt;                           "intermediate variables.\n")), "\n"), 
#&gt;                     "\n")), "\n", "\n", list(list(list("terminate()")), 
#&gt;                   list("\n", "Shut down and release all the resource.\n")), 
#&gt;                   "\n", "\n", list(list(list("scale_down(n_nodes, n_subnodes = 1)"), 
#&gt;                     ",\n", "      ", list("scale_up(n_nodes, n_subnodes = 1,\n", 
#&gt;                       "      create_if_missing = FALSE, path = tempfile())")), 
#&gt;                     list("\n", "Scale down or up the evaluator.\n", 
#&gt;                       list("\n", list(list(list("n_nodes"), " and ", 
#&gt;                         list("n_subnodes")), list(" see 'usage' ")), 
#&gt;                         "\n", list(list(list("create_if_missing")), 
#&gt;                           list("\n", "If the evaluator was previously terminated or shutdown, setting this to be\n", 
#&gt;                             "true ignores the `invalid` flags and re-initialize the evaluator\n")), 
#&gt;                         "\n", list(list(list("path")), list("\n", 
#&gt;                           "If ", list("create_if_missing"), " is true, then ", 
#&gt;                           list("path"), " will be passed to\n", 
#&gt;                           "the constructor of ", list(list("MasterEvaluator")), 
#&gt;                           ". See 'usage'.\n")), "\n"), "\n")), 
#&gt;                   "\n", "\n", "\n", list(list(list("workers(...)")), 
#&gt;                     list("\n", "Returns number of workers available in the evaluator. ", 
#&gt;                       list("`...`"), " is for\n", "debug use\n")), 
#&gt;                   "\n", "\n", list(list(list("progress()")), 
#&gt;                     list("\n", "Returns a vector of 4 integers. They are:\n", 
#&gt;                       list("\n", list(), list(" The total number evaluations. "), 
#&gt;                         "\n", list(), list(" Number of running evaluations. "), 
#&gt;                         "\n", list(), list(" Number of awaiting evaluations. "), 
#&gt;                         "\n", list(), list(" Number of finished evaluations. "), 
#&gt;                         "\n"), "\n")), "\n", "\n"), "\n")), "\n", 
#&gt;             "\n"), make_forked_clusters.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels.R", 
#&gt;             "\n", list("make_forked_clusters"), "\n", list("make_forked_clusters"), 
#&gt;             "\n", list("Create forked clusters"), "\n", list(
#&gt;                 "\n", "make_forked_clusters(\n", "  workers = future::availableCores(constraints = \"multicore\"),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "workers"), list("positive integer, number of cores to use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passing to ", 
#&gt;                   list("future::plan"))), "\n"), "\n", list("\n", 
#&gt;                 "number of cores\n"), "\n", list("\n", "Create forked clusters\n"), 
#&gt;             "\n", list("\n", "This is a wrapper for ", list("future::plan(future::multicore, ...)"), 
#&gt;                 ".\n", "However, since version 1.14.0, forked clusters are disabled in `RStudio` by\n", 
#&gt;                 "default, and you usually need to enable it manually. This function provides\n", 
#&gt;                 "a simple way of enable it and plan the future at the same time.\n"), 
#&gt;             "\n"), map.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-s3.R", 
#&gt;             "\n", list("map"), "\n", list("map"), "\n", list(
#&gt;                 "session_map"), "\n", list("rds_map"), "\n", 
#&gt;             list("text_map"), "\n", list("qs_map"), "\n", list(
#&gt;                 "redis_map"), "\n", list("Create R object map."), 
#&gt;             "\n", list("\n", "session_map(map = fastmap::fastmap())\n", 
#&gt;                 "\n", "rds_map(path = tempfile())\n", "\n", "text_map(path = tempfile())\n", 
#&gt;                 "\n", "qs_map(path = tempfile())\n", "\n", "redis_map(name = rand_string())\n"), 
#&gt;             "\n", list("\n", list(list("map"), list("a ", list(
#&gt;                 "fastmap::fastmap()"), " list")), "\n", "\n", 
#&gt;                 list(list("path"), list("directory path where map data should be stored")), 
#&gt;                 "\n", "\n", list(list("name"), list("character, map name. If map names are the same, the data\n", 
#&gt;                   "will be shared.")), "\n"), "\n", list("\n", 
#&gt;                 "An ", list("R6"), " instance that inherits ", 
#&gt;                 list(list("AbstractMap")), "\n"), "\n", list(
#&gt;                 "\n", "Provides five types of map that fit in different use cases.\n"), 
#&gt;             "\n", list("\n", "There are five types of map implemented. They all inherit class\n", 
#&gt;                 list(list("AbstractMap")), ". There are several differences in\n", 
#&gt;                 "use case scenarios and they backend implementations.\n", 
#&gt;                 "\n", list("\n", list(list(list(list("session_map"))), 
#&gt;                   list("\n", "A session map takes a ", list(list(
#&gt;                     "fastmap")), " object. All objects are\n", 
#&gt;                     "stored in current R session. This means you cannot access the map from other\n", 
#&gt;                     "process nor parent process. The goal of this map is to share the data across\n", 
#&gt;                     "different environments and to store global variables, as long as they share\n", 
#&gt;                     "the same map object. If you are looking for maps that can be shared\n", 
#&gt;                     "by different processes, check the rest map types. The closest map type is\n", 
#&gt;                     list("redis_map"), ", which is also memory-based.\n")), 
#&gt;                   "\n", list(list(list(list("rds_map"))), list(
#&gt;                     "\n", "An 'RDS' map uses file system to store values. The values are stored\n", 
#&gt;                     "separately in '.rds' files. Compared to session maps, 'RDS' map can be\n", 
#&gt;                     "shared across different R process. It's recommended to store\n", 
#&gt;                     "large files in ", list("rds_map"), ". If the value is not large in RAM,\n", 
#&gt;                     list("text_map"), " and ", list("redis_map"), 
#&gt;                     " are recommended.\n")), "\n", list(list(
#&gt;                     list(list("qs_map"))), list("\n", "A 'qs' map uses package 'qs' as backend. This map is very similar to\n", 
#&gt;                     list("rds_map"), ", but is especially designed for large values. For example,\n", 
#&gt;                     "pushing 1GB data to ", list("qs_map"), " will be 100 times faster than using\n", 
#&gt;                     list("rds_map"), ", and ", list("text_map"), 
#&gt;                     " will almost fail. However, compared\n", 
#&gt;                     "to ", list("rds_map"), " the stored data cannot be normally read by R as they\n", 
#&gt;                     "are compressed binary files. And ", list(
#&gt;                       "qs_map"), " is heavier than\n", list("text_map"), 
#&gt;                     ".\n")), "\n", list(list(list(list("text_map"))), 
#&gt;                     list("\n", "A 'text' map uses file system to store values. Similar to ", 
#&gt;                       list("rds_map"), ",\n", "it can be stored across multiple processes as long as the maps share the\n", 
#&gt;                       "same file directory. However, unlike ", 
#&gt;                       list("rds_map"), ", ", list("text_map"), 
#&gt;                       "\n", "the ", list("text_map"), " can only store basic data values, namely atom data types.\n", 
#&gt;                       "The supported types are: numeric, character, vector, list, matrix\n", 
#&gt;                       "It's highly recommended to convert factors to characters. Do NOT use if the\n", 
#&gt;                       "values are functions or environments. Please check\n", 
#&gt;                       list(list("write_yaml")), " for details. The recommended use case scenario\n", 
#&gt;                       "is when the speed is not the major concern, and you want to preserve data\n", 
#&gt;                       "with backward compatibility. Otherwise it's highly recommended to use\n", 
#&gt;                       list("redis_map"), ", ", list("qs_map"), 
#&gt;                       ", and ", list("rds_map"), ".\n")), "\n", 
#&gt;                   list(list(list(list("redis_map"))), list("\n", 
#&gt;                     "A 'Redis' map uses free open source software `Redis` and R package\n", 
#&gt;                     "'RcppRedis' as backend. Compared to session map, 'Redis' map can be\n", 
#&gt;                     "shared across sessions. Compared to 'text' and 'rds' maps, 'Redis' map\n", 
#&gt;                     "stores data in memory, meaning a potential of significant speed ups. To use\n", 
#&gt;                     list("redis_map"), ", you need to install `Redis` on your computer.\n", 
#&gt;                     list("\n", "  ", list(), " On Mac: use `", 
#&gt;                       list("brew install redis"), "` to install and\n", 
#&gt;                       "    `", list("brew services start redis"), 
#&gt;                       "` to start the service\n", "  ", list(), 
#&gt;                       " On Linux: use `", list("sudo apt-get install redis-server"), 
#&gt;                       "` to install\n", "    and `", list("sudo systemctl enable redis-server.service"), 
#&gt;                       "` to start the\n", "    service\n", "  ", 
#&gt;                       list(), " On Windows: Download from\n", 
#&gt;                       "    ", list("https://github.com/dmajkic/redis/downloads"), 
#&gt;                       " and double click\n", "    'redis-server.exe'\n"), 
#&gt;                     "\n")), "\n"), "\n"), "\n", list("\n", "# ----------------------Basic Usage ----------------------\n", 
#&gt;                 "\n", "# Define a path to your map.\n", "path = tempfile()\n", 
#&gt;                 "map &lt;- qs_map(path)\n", "\n", "# Reset\n", "map$reset()\n", 
#&gt;                 "\n", "# Check if the map is corrupted.\n", "map$validate()\n", 
#&gt;                 "\n", "# You have not set any key-value pairs yet.\n", 
#&gt;                 "# Let's say two parallel processes (A and B) are sharing this map.\n", 
#&gt;                 "# Process A set values\n", "map$keys()\n", "\n", 
#&gt;                 "# Start push\n", "# set a normal message\n", 
#&gt;                 "map$set(key = 'a', value = 1)\n", "\n", "# set a large object\n", 
#&gt;                 "map$set(key = 'b', value = rnorm(100000))\n", 
#&gt;                 "\n", "# set an object with hash of another object\n", 
#&gt;                 "map$set(key = 'c', value = 2, signature = list(\n", 
#&gt;                 "  parameter1 = 123,\n", "  parameter2 = 124\n", 
#&gt;                 "))\n", "\n", "# Check what's in the map from process B\n", 
#&gt;                 "mapB &lt;- qs_map(path)\n", "mapB$keys()\n", "mapB$keys(include_signatures = TRUE)\n", 
#&gt;                 "\n", "# Number of key-values pairs in the map.\n", 
#&gt;                 "mapB$size()\n", "\n", "# Check if key exists\n", 
#&gt;                 "mapB$has(c('1','a', 'c'))\n", "\n", "# Check if key exists and signature also matches\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 123,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Signature changed, then return FALSE. This is especially useful when\n", 
#&gt;                 "# value is really large and reading the value takes tons of time\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 1244444,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Destroy the map's files altogether.\n", 
#&gt;                 "mapB$destroy()\n", "\n", list("\n", "  # Once destroyed, validate will raise error\n", 
#&gt;                   "  mapB$validate()\n"), "\n", "\n", "\n"), 
#&gt;             "\n"), match_calls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("match_calls"), "\n", list("match_calls"), 
#&gt;             "\n", list("Recursively match calls and modify arguments"), 
#&gt;             "\n", list("\n", "match_calls(\n", "  call,\n", "  recursive = TRUE,\n", 
#&gt;                 "  replace_args = list(),\n", "  quoted = FALSE,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("an ", list(
#&gt;                 "R"), " expression")), "\n", "\n", list(list(
#&gt;                 "recursive"), list("logical, recursively match calls, default is true")), 
#&gt;                 "\n", "\n", list(list("replace_args"), list("named list of functions, see examples")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("logical, is ", 
#&gt;                   list("call"), " quoted")), "\n", "\n", list(
#&gt;                   list("envir"), list("which environment should call be evaluated")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters passing to ", 
#&gt;                   list("match.call"))), "\n"), "\n", list("\n", 
#&gt;                 "A nested call with all arguments matched\n"), 
#&gt;             "\n", list("\n", "Recursively match calls and modify arguments\n"), 
#&gt;             "\n", list("\n", "library(dipsaus); library(shiny)\n", 
#&gt;                 "\n", "# In shiny modules, we might want to add ns() to inputIds\n", 
#&gt;                 "# In this example, textInput(id) will become textInput(ns(id))\n", 
#&gt;                 "match_calls(lapply(1:20, function(i){\n", "  textInput(paste('id_', i), paste('Label ', i))\n", 
#&gt;                 "}), replace_args = list(\n", "  inputId = function(arg, call){ as.call(list(quote(ns), arg)) }\n", 
#&gt;                 "))\n", "\n"), "\n"), mem_limit2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("mem_limit2"), "\n", list("mem_limit2"), 
#&gt;             "\n", list("Get max RAM size\n", "This is an experimental function that is designed for non-windows systems"), 
#&gt;             "\n", list("\n", "mem_limit2()\n"), "\n", list("\n", 
#&gt;                 "a list of total free memory.\n"), "\n", list(
#&gt;                 "\n", "Get max RAM size\n", "This is an experimental function that is designed for non-windows systems\n"), 
#&gt;             "\n"), no_op.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("no_op"), "\n", list("no_op"), "\n", list(
#&gt;                 "Pipe-friendly no-operation function"), "\n", 
#&gt;             list("\n", "no_op(.x, .expr, ..., .check_fun = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("any R object")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression that produces side effects")), 
#&gt;                 "\n", "\n", list(list("..., .check_fun"), list(
#&gt;                   "see `details`")), "\n"), "\n", list("\n", 
#&gt;                 "The value of ", list(".x"), "\n"), "\n", list(
#&gt;                 "\n", "returns the first input with side effects\n"), 
#&gt;             "\n", list("\n", list("no_op"), " is a pipe-friendly function that takes any values in,\n", 
#&gt;                 "evaluate expressions but still returns input. This is very useful when\n", 
#&gt;                 "you have the same input across multiple functions and you want to use pipes.\n", 
#&gt;                 "\n", list(".expr"), " is evaluated with a special object ", 
#&gt;                 list("'.'"), ", you can use\n", list("'.'"), 
#&gt;                 " to represent ", list(".x"), " in ", list(".expr"), 
#&gt;                 ". For example, if\n", list(".x=1:100"), ", then ", 
#&gt;                 list("plot(x=seq(0,1,length.out = 100), y=.)"), 
#&gt;                 " is\n", "equivalent to ", list("plot(x=seq(0,1,length.out = 100), y=1:100)"), 
#&gt;                 ".\n", "\n", list(".check_fun"), " checks whether ", 
#&gt;                 list(".expr"), " returns a function, if yes,\n", 
#&gt;                 "then the function is called with argument ", 
#&gt;                 list(".x"), " and ", list("..."), "\n"), "\n", 
#&gt;             list("\n", "\n", "library(magrittr)\n", "\n", "## 1. Basic usage\n", 
#&gt;                 "\n", "# Will print('a') and return 'a'\n", "no_op('a', print)\n", 
#&gt;                 "\n", "# Will do nothing and return 'a' because .check_fun is false\n", 
#&gt;                 "no_op('a', print, .check_fun = FALSE)\n", "\n", 
#&gt;                 "# Will print('a') and return 'a'\n", "no_op('a', print(.), .check_fun = FALSE)\n", 
#&gt;                 "\n", "## 2. Toy example\n", "library(graphics)\n", 
#&gt;                 "\n", "par(mfrow = c(2,2))\n", "x &lt;- rnorm(100)\n", 
#&gt;                 "\n", "# hist and plot share the same input `rnorm(100)`\n", 
#&gt;                 "\n", "x %&gt;%\n", "  # .expr is a function, all ... are passed as other arguments\n", 
#&gt;                 "  no_op( hist, nclass = 10 ) %&gt;%\n", "  no_op( plot, x = seq(0,1,length.out = 100) ) %&gt;%\n", 
#&gt;                 "\n", "  # Repeat the previous two plots, but with different syntax\n", 
#&gt;                 "  no_op({ hist(., nclass = 10) }) %&gt;%\n", "  no_op({ plot(x = seq(0,1,length.out = 100), y = .) }) %&gt;%\n", 
#&gt;                 "\n", "  # The return statement is ignored\n", 
#&gt;                 "\n", "  no_op({ return(x + 1)}) -&gt;\n", "  y\n", 
#&gt;                 "\n", "# x is returned at the end\n", "\n", "identical(x, y)   # TRUE\n", 
#&gt;                 "\n"), "\n"), package_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("package_installed"), "\n", list("package_installed"), 
#&gt;             "\n", list("Check if a package is installed"), "\n", 
#&gt;             list("\n", "package_installed(pkgs, all = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("pkgs"), list("vector of package names")), 
#&gt;                 "\n", "\n", list(list("all"), list("only returns TRUE if all packages are installed. Default is FALSE.")), 
#&gt;                 "\n"), "\n", list("\n", "logical, if packages are installed or not. If ", 
#&gt;                 list("all=TRUE"), ", return\n", "a logical value of whether all packages a re installed.\n"), 
#&gt;             "\n", list("\n", "Check if a package is installed\n"), 
#&gt;             "\n", list("\n", "\n", "# Check if package base and dipsaus are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'))\n", 
#&gt;                 "\n", "# Check if all required packages are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'), all = TRUE)\n", 
#&gt;                 "\n"), "\n"), parse_svec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("parse_svec"), "\n", list("parse_svec"), 
#&gt;             "\n", list("Parse Text Into Numeric Vectors\n", "\n", 
#&gt;                 "(stable)"), "\n", list("\n", "parse_svec(text, sep = \",\", connect = \"-:|\", sort = FALSE, unique = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("text"), list("string with chunks, e.g. ", 
#&gt;                 list("\"1-10, 14, 16-20, 18-30\""), " has 4 chunks")), 
#&gt;                 "\n", "\n", list(list("sep"), list("default is \",\", character used to separate chunks")), 
#&gt;                 "\n", "\n", list(list("connect"), list("characters defining connection links for example \"1:10\" is the same as \"1-10\"")), 
#&gt;                 "\n", "\n", list(list("sort"), list("sort the result")), 
#&gt;                 "\n", "\n", list(list("unique"), list("extract unique elements")), 
#&gt;                 "\n"), "\n", list("\n", "a numeric vector. For example, \"1-3\" returns ", 
#&gt;                 list("c(1, 2, 3)"), "\n"), "\n", list("\n", "Parse Text Into Numeric Vectors\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "parse_svec('1-10, 13:15,14-20')\n"), 
#&gt;             "\n", list("\n", list(list("deparse_svec")), "\n"), 
#&gt;             "\n"), prepare_install.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("prepare_install"), "\n", list("prepare_install"), 
#&gt;             "\n", list("Install Packages at Next Startup"), "\n", 
#&gt;             list("\n", "prepare_install(\n", "  packages,\n", 
#&gt;                 "  update_all = FALSE,\n", "  restart = FALSE,\n", 
#&gt;                 "  repos = getOption(\"repos\")\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("packages"), list("characters, vector of package names")), 
#&gt;                 "\n", "\n", list(list("update_all"), list("whether to update all installed packages before\n", 
#&gt;                   "installation; default is false")), "\n", "\n", 
#&gt;                 list(list("restart"), list("whether to restart session automatically")), 
#&gt;                 "\n", "\n", list(list("repos"), list("repositories to search for packages")), 
#&gt;                 "\n"), "\n", list("\n", "None\n"), "\n", list(
#&gt;                 "\n", "Register temporary code that will install packages at\n", 
#&gt;                 "next session. The code will be automatically removed once executed.\n"), 
#&gt;             "\n", list("\n", "Installing packages in R session could require restarts if\n", 
#&gt;                 "a package to be updated has been loaded. Normally restarting R\n", 
#&gt;                 "fixes the problem. However, under some circumstances, such as with a\n", 
#&gt;                 "startup code in profile, restarting R might still fail the\n", 
#&gt;                 "installation. ", list("prepare_install"), " inserts the installation\n", 
#&gt;                 "code prior to the startup code so that next time the code will get\n", 
#&gt;                 "executed before any other packages are loaded.\n", 
#&gt;                 "Once the temporary code get executed, no matter succeeded or not,\n", 
#&gt;                 "it will be removed from startup profile.\n"), 
#&gt;             "\n"), progress2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("progress2"), "\n", list("progress2"), 
#&gt;             "\n", list("'Shiny' progress bar, but can run without reactive context"), 
#&gt;             "\n", list("\n", "progress2(\n", "  title,\n", "  max = 1,\n", 
#&gt;                 "  ...,\n", "  quiet = FALSE,\n", "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  shiny_auto_close = FALSE,\n", "  log = NULL\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("title"), 
#&gt;                 list("character, task description")), "\n", "\n", 
#&gt;                 list(list("max"), list("maximum number of items in the queue")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("shiny::Progress$new(...)"))), "\n", "\n", 
#&gt;                 list(list("quiet"), list("suppress console output, ignored in shiny context.")), 
#&gt;                 "\n", "\n", list(list("session"), list("'shiny' session, default is current reactive domain")), 
#&gt;                 "\n", "\n", list(list("shiny_auto_close"), list(
#&gt;                   "logical, automatically close 'shiny' progress bar\n", 
#&gt;                   "once current observer is over. Default is ", 
#&gt;                   list("FALSE"), ". If setting to\n", list("TRUE"), 
#&gt;                   ", then it's equivalent to\n", list("p &lt;- progress2(...); on.exit({p$close()}, add = TRUE)"), 
#&gt;                   ".")), "\n", "\n", list(list("log"), list("function when running locally, default is ", 
#&gt;                   list("NULL"), ",\n", "which redirects to ", 
#&gt;                   list(list("cat2")))), "\n"), "\n", list("\n", 
#&gt;                 "A list of functions:\n", list("\n", list(list(
#&gt;                   list("inc(detail, message = NULL, amount = 1, ...)")), 
#&gt;                   list("\n", "Increase progress bar by ", list(
#&gt;                     "amount"), " (default is 1).\n")), "\n", 
#&gt;                   list(list(list("close()")), list("\n", "Close the progress\n")), 
#&gt;                   "\n", list(list(list("reset(detail = '', message = '', value = 0)")), 
#&gt;                     list("\n", "Reset the progress to ", list(
#&gt;                       "value"), " (default is 0), and reset information\n")), 
#&gt;                   "\n", list(list(list("get_value()")), list(
#&gt;                     "\n", "Get current progress value\n")), "\n", 
#&gt;                   list(list(list("is_closed()")), list("\n", 
#&gt;                     "Returns logical value if the progress is closed or not.\n")), 
#&gt;                   "\n"), "\n"), "\n", list("\n", "'Shiny' progress bar, but can run without reactive context\n"), 
#&gt;             "\n", list("\n", "\n", "progress &lt;- progress2('Task A', max = 2)\n", 
#&gt;                 "progress$inc('Detail 1')\n", "progress$inc('Detail 2')\n", 
#&gt;                 "progress$close()\n", "\n", "# Check if progress is closed\n", 
#&gt;                 "progress$is_closed()\n", "\n", "# ------------------------------ Shiny Example ------------------------------\n", 
#&gt;                 "library(shiny)\n", "library(dipsaus)\n", "\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  actionButtonStyled('do', 'Click Here', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    updateActionButtonStyled(session, 'do', disabled = TRUE)\n", 
#&gt;                 "    progress &lt;- progress2('Task A', max = 10, shiny_auto_close = TRUE)\n", 
#&gt;                 "    lapply(1:10, function(ii){\n", "      progress$inc(sprintf('Detail %d', ii))\n", 
#&gt;                 "      Sys.sleep(0.2)\n", "    })\n", "    updateActionButtonStyled(session, 'do', disabled = FALSE)\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         registerInputBinding.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("registerInputBinding"), "\n", list("registerInputBinding"), 
#&gt;             "\n", list("Register customized input to enable support by compound input"), 
#&gt;             "\n", list("\n", "registerInputBinding(fname, pkg, shiny_binding, update_function = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("character, function name, such as ", 
#&gt;                 list("\"textInput\""))), "\n", "\n", list(list(
#&gt;                 "pkg"), list("character, package name, like ", 
#&gt;                 list("\"shiny\""))), "\n", "\n", list(list("shiny_binding"), 
#&gt;                 list("character, 'JavaScript' binding name.See examples")), 
#&gt;                 "\n", "\n", list(list("update_function"), list(
#&gt;                   "character, update function such as ", list(
#&gt;                     "\"shiny::textInput\""))), "\n"), "\n", list(
#&gt;                 "\n", "a list of binding functions, one is `JavaScript` object key in\n", 
#&gt;                 list("Shiny.inputBindings"), ", the other is `shiny` update function in R end.\n"), 
#&gt;             "\n", list("\n", "Register customized input to enable support by compound input\n"), 
#&gt;             "\n", list("\n", "\n", "# register shiny textInput\n", 
#&gt;                 "registerInputBinding('textInput', 'shiny',\n", 
#&gt;                 "                     'shiny.textInput', 'shiny::updateTextInput')\n", 
#&gt;                 "\n", "# Register shiny actionLink\n", "# In \"Shiny.inputbindings\", the binding name is \"shiny.actionButtonInput\",\n", 
#&gt;                 "# Shiny update function is \"shiny::updateActionButton\"\n", 
#&gt;                 "registerInputBinding('actionLink', 'shiny',\n", 
#&gt;                 "                     'shiny.actionButtonInput', 'shiny::updateActionButton')\n", 
#&gt;                 "\n"), "\n"), screenshot.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("screenshot"), "\n", list("screenshot"), 
#&gt;             "\n", list("Take a screenshot in shiny apps"), "\n", 
#&gt;             list("\n", "screenshot(inputId, session = shiny::getDefaultReactiveDomain())\n"), 
#&gt;             "\n", list("\n", list(list("inputId"), list("the input id where the screenshot should be")), 
#&gt;                 "\n", "\n", list(list("session"), list("shiny session")), 
#&gt;                 "\n"), "\n", list("\n", "None. However, the screenshot results can be accessed from\n", 
#&gt;                 "shiny input\n"), "\n", list("\n", "Take a screenshot of the whole page and save encoded\n", 
#&gt;                 list("DataURI"), " that can be accessed via ", 
#&gt;                 list("input[[inputId]]"), ".\n"), "\n", list(
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  tagList(\n", "    shiny::singleton(shiny::tags$head(\n", 
#&gt;                 "      shiny::tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"dipsaus/dipsaus.css\"),\n", 
#&gt;                 "      shiny::tags$script(src=\"dipsaus/dipsaus-dipterix-lib.js\")\n", 
#&gt;                 "    ))\n", "  ),\n", "  actionButtonStyled('do', 'Take Screenshot'),\n", 
#&gt;                 "  compoundInput2('group', label = 'Group', components = list(\n", 
#&gt;                 "    textInput('txt', 'Enter something here')\n", 
#&gt;                 "  ))\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    screenshot('screeshot_result')\n", 
#&gt;                 "  })\n", "  observeEvent(input$screeshot_result, {\n", 
#&gt;                 "    showModal(modalDialog(\n", "      tags$img(src = input$screeshot_result, width = '100%')\n", 
#&gt;                 "    ))\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         set_shiny_input.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("set_shiny_input"), "\n", list("set_shiny_input"), 
#&gt;             "\n", list("Set Shiny Input"), "\n", list("\n", "set_shiny_input(\n", 
#&gt;                 "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  inputId,\n", "  value,\n", "  priority = c(\"event\", \"deferred\", \"immediate\"),\n", 
#&gt;                 "  method = c(\"proxy\", \"serialize\", \"value\", \"expression\"),\n", 
#&gt;                 "  quoted = TRUE\n", ")\n"), "\n", list("\n", 
#&gt;                 list(list("session"), list("shiny session, see shiny ", 
#&gt;                   list(list("domains")))), "\n", "\n", list(list(
#&gt;                   "inputId"), list("character, input ID")), "\n", 
#&gt;                 "\n", list(list("value"), list("the value to assign")), 
#&gt;                 "\n", "\n", list(list("priority"), list("characters, options are \"event\", \"deferred\", and \"immediate\".\n", 
#&gt;                   "\"event\" and \"immediate\" are similar, they always fire changes. \"deferred\"\n", 
#&gt;                   "fire signals to other reactive/observers only when the input value has been\n", 
#&gt;                   "changed")), "\n", "\n", list(list("method"), 
#&gt;                   list("characters, options are \"proxy\", \"serialize\", \"value\",\n", 
#&gt;                     "\"expression\". \"proxy\" is recommended, other methods are experimental.")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("is value quoted? Only used when method is \"expression\"")), 
#&gt;                 "\n"), "\n", list("\n", "Shiny `input' object is read-only reactive list. When try to\n", 
#&gt;                 "assign values to input, errors usually occur. This method provides several\n", 
#&gt;                 "work-around to set values to input. Please use along with\n", 
#&gt;                 list(list("use_shiny_dipsaus")), ".\n"), "\n", 
#&gt;             list("\n", "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  # Register widgets\n", 
#&gt;                 "  use_shiny_dipsaus(),\n", "  actionButton('run', 'Set Input'),\n", 
#&gt;                 "  verbatimTextOutput('input_value')\n", ")\n", 
#&gt;                 "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  start = Sys.time()\n", "\n", "  output$input_value &lt;- renderPrint({\n", 
#&gt;                 "\n", "    now &lt;- input$key\n", "    now %?&lt;-% start\n", 
#&gt;                 "    cat('This app has been opened for ',\n", 
#&gt;                 "        difftime(now, start, units = 'sec'), ' seconds')\n", 
#&gt;                 "  })\n", "\n", "  observeEvent(input$run, {\n", 
#&gt;                 "    # setting input$key to Sys.time()\n", "    set_shiny_input(session, 'key', Sys.time())\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n"), 
#&gt;             "\n"), shift_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("shift_array"), "\n", list("shift_array"), 
#&gt;             "\n", list("Shift Array by Index"), "\n", list("\n", 
#&gt;                 "shift_array(x, shift_idx, shift_by, shift_amount)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("array, must have at least matrix")), 
#&gt;                 "\n", "\n", list(list("shift_idx"), list("which index is to be shifted")), 
#&gt;                 "\n", "\n", list(list("shift_by"), list("which dimension decides ", 
#&gt;                   list("shift_amount"))), "\n", "\n", list(list(
#&gt;                   "shift_amount"), list("shift amount along ", 
#&gt;                   list("shift_idx"))), "\n"), "\n", list("\n", 
#&gt;                 "Re-arrange arrays in parallel\n"), "\n", list(
#&gt;                 "\n", "A simple use-case for this function is to think of a matrix where each row\n", 
#&gt;                 "is a signal and columns stand for time. The objective is to align (time-lock)\n", 
#&gt;                 "each signal according to certain events. For each signal, we want to shift\n", 
#&gt;                 "the time points by certain amount.\n", "\n", 
#&gt;                 "In this case, the shift amount is defined by ", 
#&gt;                 list("shift_amount"), ", whose\n", "length equals to number of signals. ", 
#&gt;                 list("shift_idx=2"), " as we want to shift\n", 
#&gt;                 "time points (column, the second dimension) for each signal. ", 
#&gt;                 list("shift_by=1"), "\n", "because the shift amount is depend on the signal number.\n"), 
#&gt;             "\n", list("\n", "x &lt;- matrix(1:10, nrow = 2, byrow = TRUE)\n", 
#&gt;                 "z &lt;- shift_array(x, 2, 1, c(1,2))\n", "\n", 
#&gt;                 "y &lt;- NA * x\n", "y[1,1:4] = x[1,2:5]\n", "y[2,1:3] = x[2,3:5]\n", 
#&gt;                 "\n", "# Check if z ang y are the same\n", "z - y\n", 
#&gt;                 "\n", "# array case\n", "# x is Trial x Frequency x Time\n", 
#&gt;                 "x &lt;- array(1:27, c(3,3,3))\n", "\n", "# Shift time for each trial, amount is 1, -1, 0\n", 
#&gt;                 "shift_amount &lt;- c(1,-1,0)\n", "z &lt;- shift_array(x, 3, 1, shift_amount)\n", 
#&gt;                 "par(mfrow = c(3, 2))\n", "for( ii in 1:3 ){\n", 
#&gt;                 "  image(t(x[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Trial', ii))\n", "  image(t(z[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Shifted amount:', shift_amount[ii]))\n", 
#&gt;                 "}\n", "\n"), "\n"), sync_shiny_inputs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-syncInputs.R", 
#&gt;             "\n", list("sync_shiny_inputs"), "\n", list("sync_shiny_inputs"), 
#&gt;             "\n", list("Synchronize Shiny Inputs"), "\n", list(
#&gt;                 "\n", "sync_shiny_inputs(\n", "  input,\n", "  session,\n", 
#&gt;                 "  inputIds,\n", "  uniform = rep(\"I\", length(inputIds)),\n", 
#&gt;                 "  updates,\n", "  snap = 250\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("input, session"), list("shiny reactive objects")), 
#&gt;                 "\n", "\n", list(list("inputIds"), list("input ids to be synchronized")), 
#&gt;                 "\n", "\n", list(list("uniform"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", converting inputs\n", 
#&gt;                   "to a uniform values")), "\n", "\n", list(list(
#&gt;                   "updates"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", updating input values")), 
#&gt;                 "\n", "\n", list(list("snap"), list("numeric, milliseconds to defer the changes")), 
#&gt;                 "\n"), "\n", list("\n", "none.\n"), "\n", list(
#&gt;                 "\n", "Synchronize Shiny Inputs\n"), "\n", list(
#&gt;                 "\n", "\n", "library(shiny)\n", "\n", "ui &lt;- fluidPage(\n", 
#&gt;                 "  textInput('a', 'a', value = 'a'),\n", "  sliderInput('b', 'b', value = 1, min = 0, max = 1000)\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  sync_shiny_inputs(input, session, inputIds = c('a', 'b'), uniform = list(\n", 
#&gt;                 "    function(a){as.numeric(a)},\n", "    'I'\n", 
#&gt;                 "  ), updates = list(\n", "    function(a){updateTextInput(session, 'a', value = a)},\n", 
#&gt;                 "    function(b){updateSliderInput(session, 'b', value = b)}\n", 
#&gt;                 "  ))\n", "\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         time_delta.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("time_delta"), "\n", list("time_delta"), 
#&gt;             "\n", list("Calculate time difference and return a number"), 
#&gt;             "\n", list("\n", "time_delta(t1, t2, units = \"secs\")\n"), 
#&gt;             "\n", list("\n", list(list("t1"), list("time start")), 
#&gt;                 "\n", "\n", list(list("t2"), list("time end")), 
#&gt;                 "\n", "\n", list(list("units"), list("character, choices are ", 
#&gt;                   list("'secs'"), ", ", list("'mins'"), ", ", 
#&gt;                   list("'hours'"), ", and ", list("'days'"))), 
#&gt;                 "\n"), "\n", list("\n", "numeric difference of time in units specified\n"), 
#&gt;             "\n", list("\n", "Calculate time difference and return a number\n"), 
#&gt;             "\n", list("\n", "a = Sys.time()\n", "Sys.sleep(0.3)\n", 
#&gt;                 "b = Sys.time()\n", "\n", "time_delta(a, b) # In seconds, around 0.3\n", 
#&gt;                 "time_delta(a, b, 'mins') # in minutes, around 0.005\n", 
#&gt;                 "\n"), "\n"), to_datauri.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_datauri"), "\n", list("to_datauri"), 
#&gt;             "\n", list("Convert file to 'base64' format"), "\n", 
#&gt;             list("\n", "to_datauri(file, mime = \"\")\n"), "\n", 
#&gt;             list("\n", list(list("file"), list("file path")), 
#&gt;                 "\n", "\n", list(list("mime"), list("'mime' type, default is blank")), 
#&gt;                 "\n"), "\n", list("\n", "a 'base64' data string looks like ", 
#&gt;                 list("'data:;base64,AEF6986...'"), "\n"), "\n", 
#&gt;             list("\n", "Convert file to 'base64' format\n"), 
#&gt;             "\n"), to_ram_size.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_ram_size"), "\n", list("to_ram_size"), 
#&gt;             "\n", list("Convert bytes to KB, MB, GB,..."), "\n", 
#&gt;             list("\n", "to_ram_size(s, kb_to_b = 1000)\n"), "\n", 
#&gt;             list("\n", list(list("s"), list("size")), "\n", "\n", 
#&gt;                 list(list("kb_to_b"), list("how many bytes counts one KB, 1000 by default")), 
#&gt;                 "\n"), "\n", list("\n", "numeric equaling to ", 
#&gt;                 list("s"), " but formatted\n"), "\n", list("\n", 
#&gt;                 "Convert bytes to KB, MB, GB,...\n"), "\n"), 
#&gt;         updateActionButtonStyled.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("updateActionButtonStyled"), "\n", list(
#&gt;                 "updateActionButtonStyled"), "\n", list("Update styled action button"), 
#&gt;             "\n", list("\n", "updateActionButtonStyled(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  label = NULL,\n", "  icon = NULL,\n", 
#&gt;                 "  type = NULL,\n", "  disabled = NULL,\n", "  ...\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("session, inputId, label, icon"), 
#&gt;                 list("passed to ", list("shiny::updateActionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type to update")), 
#&gt;                 "\n", "\n", list(list("disabled"), list("whether to disable the button")), 
#&gt;                 "\n", "\n", list(list("..."), list("ignored")), 
#&gt;                 "\n"), "\n", list("\n", "none\n"), "\n", list(
#&gt;                 "\n", "Update styled action button\n"), "\n", 
#&gt;             list("\n", list(list("actionButtonStyled")), " for how to define the button.\n"), 
#&gt;             "\n"), updateCompoundInput2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("updateCompoundInput2"), "\n", list("updateCompoundInput2"), 
#&gt;             "\n", list("Update compound inputs"), "\n", list(
#&gt;                 "\n", "updateCompoundInput2(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  value = NULL,\n", "  ncomp = NULL,\n", 
#&gt;                 "  initialization = NULL,\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("session"), list("shiny session or session proxy")), 
#&gt;                 "\n", "\n", list(list("inputId"), list("character see ", 
#&gt;                   list("compoundInput2"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, see ", 
#&gt;                     list("compoundInput2"), " or examples")), 
#&gt;                 "\n", "\n", list(list("ncomp"), list("integer, non-negative number of groups to update, ", 
#&gt;                   list("NULL"), " to\n", "remain unchanged")), 
#&gt;                 "\n", "\n", list(list("initialization, ..."), 
#&gt;                   list("named list of other updates")), "\n"), 
#&gt;             "\n", list("\n", "none\n"), "\n", list("\n", "Update compound inputs\n"), 
#&gt;             "\n", list("\n", "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "\n", "## UI side\n", "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    '',                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "## server side:\n", "updateCompoundInput2(session, 'inputid',\n", 
#&gt;                 "                     # Change the first 3 groups\n", 
#&gt;                 "                     value = lapply(1:3, function(ii){\n", 
#&gt;                 "                       list(sli = runif(1))\n", 
#&gt;                 "                     }),\n", "                     # Change text label for all groups\n", 
#&gt;                 "                     initialization = list(\n", 
#&gt;                 "                       text = list(label = as.character(Sys.time()))\n", 
#&gt;                 "                     ))\n"), "\n", "\n"), "\n", 
#&gt;             list("\n", list(list("compoundInput2")), " for how to define components.\n"), 
#&gt;             "\n"), update_fastmap2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fastmap2.R", 
#&gt;             "\n", list("update_fastmap2"), "\n", list("update_fastmap2"), 
#&gt;             "\n", list("Migrate a ", list("fastmap2"), " object to a new one"), 
#&gt;             "\n", list("\n", "update_fastmap2(from, to, override = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("from, to"), list(list(
#&gt;                 "fastmap2"), " object")), "\n", "\n", list(list(
#&gt;                 "override"), list("whether to override keys in ", 
#&gt;                 list("to"), " if they exist")), "\n"), "\n", 
#&gt;             list("\n", "Map ", list("to"), "\n"), "\n", list(
#&gt;                 "\n", "Migrate a ", list("fastmap2"), " object to a new one\n"), 
#&gt;             "\n", list("\n", list(list("fastmap2")), "\n"), "\n"), 
#&gt;         use_shiny_dipsaus.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("use_shiny_dipsaus"), "\n", list("use_shiny_dipsaus"), 
#&gt;             "\n", list("Set up shiny plugins"), "\n", list("\n", 
#&gt;                 "use_shiny_dipsaus()\n"), "\n", list("\n", "This function must be called from a Shiny app's UI in order for\n", 
#&gt;                 "some widgets to work.\n"), "\n")), source = list(
#&gt;         AbstractMap.Rd = "R/map-abstract.R", AbstractQueue.Rd = "R/queue-abstract.R", 
#&gt;         MasterEvaluator.Rd = "R/parallels-workers.R", PersistContainer.Rd = "R/persist.R", 
#&gt;         actionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         ask_or_default.Rd = "R/strings.R", ask_yesno.Rd = "R/strings.R", 
#&gt;         async.Rd = "R/parallels.R", async_expr.Rd = "R/parallels.R", 
#&gt;         async_flapply.Rd = "R/parallels.R", base64_to_image.Rd = "R/screenshot.R", 
#&gt;         baseline_array.Rd = "R/cpp-baseline_array.R", cat2.Rd = "R/strings.R", 
#&gt;         check_installed_packages.Rd = "R/utils-package.R", col2hexStr.Rd = "R/strings.R", 
#&gt;         collapse.Rd = "R/cpp-collapse.R", compoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         decorate_function.Rd = "R/language.R", deparse_svec.Rd = "R/strings.R", 
#&gt;         dev_create.Rd = "R/graphics.R", do_aggregate.Rd = "R/apply.R", 
#&gt;         drop_nulls.Rd = "R/utils.R", eval_dirty.Rd = "R/language.R", 
#&gt;         fastmap2.Rd = "R/fastmap2.R", forelse.Rd = "R/apply.R", 
#&gt;         getInputBinding.Rd = "R/shiny-inputbindings.R", get_cpu.Rd = "R/systems.R", 
#&gt;         get_dots.Rd = "R/language.R", get_ram.Rd = "R/systems.R", 
#&gt;         `grapes-equals-greater-than-grapes.Rd` = "R/language.R", 
#&gt;         `grapes-help-set-grapes.Rd` = "R/language.R", `grapes-plus-grapes.Rd` = "R/language.R", 
#&gt;         handler_dipsaus_progress.Rd = "R/shiny-progress.R", iapply.Rd = "R/apply.R", 
#&gt;         lapply_async2.Rd = "R/parallels-future.R", lock.Rd = "R/lock.R", 
#&gt;         make_async_evaluator.Rd = "R/parallels-workers.R", make_forked_clusters.Rd = "R/parallels.R", 
#&gt;         map.Rd = "R/map-s3.R", match_calls.Rd = "R/language.R", 
#&gt;         mem_limit2.Rd = "R/strings.R", no_op.Rd = "R/language.R", 
#&gt;         package_installed.Rd = "R/utils-package.R", parse_svec.Rd = "R/strings.R", 
#&gt;         prepare_install.Rd = "R/utils-package.R", progress2.Rd = "R/shiny-progress.R", 
#&gt;         registerInputBinding.Rd = "R/shiny-inputbindings.R", 
#&gt;         screenshot.Rd = "R/screenshot.R", set_shiny_input.Rd = "R/shiny-setInputs.R", 
#&gt;         shift_array.Rd = "R/cpp-collapse.R", sync_shiny_inputs.Rd = "R/shiny-syncInputs.R", 
#&gt;         time_delta.Rd = "R/utils.R", to_datauri.Rd = "R/strings.R", 
#&gt;         to_ram_size.Rd = "R/strings.R", updateActionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         updateCompoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         update_fastmap2.Rd = "R/fastmap2.R", use_shiny_dipsaus.Rd = "R/shiny-setInputs.R"), 
#&gt;         keywords = list(character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0)), concepts = list(
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0)), internal = c(FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE)), tutorials = list(name = character(0), file_out = character(0), 
#&gt;         title = character(0), pagetitle = character(0), url = character(0)), 
#&gt;     vignettes = list(name = c("async_evaluator", "r_expr_addons", 
#&gt;     "shiny_customized_widgets", "utility_functions"), file_in = c("vignettes/async_evaluator.Rmd", 
#&gt;     "vignettes/r_expr_addons.Rmd", "vignettes/shiny_customized_widgets.Rmd", 
#&gt;     "vignettes/utility_functions.Rmd"), file_out = c("articles/async_evaluator.html", 
#&gt;     "articles/r_expr_addons.html", "articles/shiny_customized_widgets.html", 
#&gt;     "articles/utility_functions.html"), title = c("Asynchronous Evaluator", 
#&gt;     "R Expression Add-ons", "Shiny Customized Widgets", "Utility Functions"
#&gt;     ), description = c(NA_character_, NA_character_, NA_character_, 
#&gt;     NA_character_)), topic_index = c(`[.fastmap2` = "fastmap2", 
#&gt;     `[[.fastmap2` = "fastmap2", `[[&lt;-.fastmap2` = "fastmap2", 
#&gt;     `[&lt;-.fastmap2` = "fastmap2", `%?&lt;-%` = "grapes-help-set-grapes", 
#&gt;     `%+-%` = "grapes-plus-grapes", `%=&gt;%` = "grapes-equals-greater-than-grapes", 
#&gt;     `%D%` = "decorate_function", `$.fastmap2` = "fastmap2", `$&lt;-.fastmap2` = "fastmap2", 
#&gt;     AbstractMap = "AbstractMap", AbstractQueue = "AbstractQueue", 
#&gt;     actionButtonStyled = "actionButtonStyled", as.list.fastmap2 = "fastmap2", 
#&gt;     ask_or_default = "ask_or_default", ask_yesno = "ask_yesno", 
#&gt;     async = "async", async_expr = "async_expr", async_flapply = "async_flapply", 
#&gt;     base64_to_image = "base64_to_image", baseline_array = "baseline_array", 
#&gt;     cat2 = "cat2", check_installed_packages = "check_installed_packages", 
#&gt;     col2hexStr = "col2hexStr", collapse = "collapse", compoundInput2 = "compoundInput2", 
#&gt;     decorate_function = "decorate_function", deparse_svec = "deparse_svec", 
#&gt;     dev_create = "dev_create", dipsaus_lock = "lock", dipsaus_unlock = "lock", 
#&gt;     do_aggregate = "do_aggregate", drop_nulls = "drop_nulls", 
#&gt;     eval_dirty = "eval_dirty", fastmap2 = "fastmap2", forelse = "forelse", 
#&gt;     get_cpu = "get_cpu", get_dots = "get_dots", get_ram = "get_ram", 
#&gt;     getInputBinding = "getInputBinding", handler_dipsaus_progress = "handler_dipsaus_progress", 
#&gt;     iapply = "iapply", lapply_async2 = "lapply_async2", length.fastmap2 = "fastmap2", 
#&gt;     lock = "lock", make_async_evaluator = "make_async_evaluator", 
#&gt;     make_forked_clusters = "make_forked_clusters", map = "map", 
#&gt;     MasterEvaluator = "MasterEvaluator", match_calls = "match_calls", 
#&gt;     mem_limit2 = "mem_limit2", names.fastmap2 = "fastmap2", no_op = "no_op", 
#&gt;     package_installed = "package_installed", parse_svec = "parse_svec", 
#&gt;     PersistContainer = "PersistContainer", prepare_install = "prepare_install", 
#&gt;     print.fastmap2 = "fastmap2", progress2 = "progress2", qs_map = "map", 
#&gt;     rds_map = "map", redis_map = "map", registerInputBinding = "registerInputBinding", 
#&gt;     screenshot = "screenshot", session_map = "map", set_shiny_input = "set_shiny_input", 
#&gt;     shift_array = "shift_array", sync_shiny_inputs = "sync_shiny_inputs", 
#&gt;     text_map = "map", time_delta = "time_delta", to_datauri = "to_datauri", 
#&gt;     to_ram_size = "to_ram_size", update_fastmap2 = "update_fastmap2", 
#&gt;     updateActionButtonStyled = "updateActionButtonStyled", updateCompoundInput2 = "updateCompoundInput2", 
#&gt;     use_shiny_dipsaus = "use_shiny_dipsaus"), article_index = c(async_evaluator = "async_evaluator.html", 
#&gt;     r_expr_addons = "r_expr_addons.html", shiny_customized_widgets = "shiny_customized_widgets.html", 
#&gt;     utility_functions = "utility_functions.html")), examples = TRUE, 
#&gt;     run_dont_run = FALSE, seed = 1014, lazy = FALSE, override = list(), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE), 
#&gt;     envir = &lt;environment&gt;)
#&gt; 
#&gt; [[12]]
#&gt; (function (..., crayon_enabled, crayon_colors, pkgdown_internet) 
#&gt; {
#&gt;     options(crayon.enabled = crayon_enabled, crayon.colors = crayon_colors, 
#&gt;         pkgdown.internet = pkgdown_internet)
#&gt;     pkgdown::build_site(...)
#&gt; })(pkg = list(package = "dipsaus", version = "0.0.6", src_path = "/Users/beauchamplab/Dropbox/projects/dipsaus", 
#&gt;     dst_path = "/Users/beauchamplab/Dropbox/projects/dipsaus/docs", 
#&gt;     desc = &lt;environment&gt;, meta = list(), figures = list(dev = "grDevices::png", 
#&gt;         dpi = 96L, dev.args = list(), fig.ext = "png", fig.width = 7.29166666666667, 
#&gt;         fig.height = NULL, fig.retina = 2L, fig.asp = 0.618046971569839), 
#&gt;     repo = list(url = list(home = "https://github.com/dipterix/dipsaus/", 
#&gt;         source = "https://github.com/dipterix/dipsaus/blob/master/", 
#&gt;         issue = "https://github.com/dipterix/dipsaus/issues/", 
#&gt;         user = "https://github.com/")), development = list(destination = "dev", 
#&gt;         mode = "release", version_label = "default", version_tooltip = "Released version", 
#&gt;         in_dev = FALSE), topics = list(name = c(AbstractMap.Rd = "AbstractMap", 
#&gt;     AbstractQueue.Rd = "AbstractQueue", MasterEvaluator.Rd = "MasterEvaluator", 
#&gt;     PersistContainer.Rd = "PersistContainer", actionButtonStyled.Rd = "actionButtonStyled", 
#&gt;     ask_or_default.Rd = "ask_or_default", ask_yesno.Rd = "ask_yesno", 
#&gt;     async.Rd = "async", async_expr.Rd = "async_expr", async_flapply.Rd = "async_flapply", 
#&gt;     base64_to_image.Rd = "base64_to_image", baseline_array.Rd = "baseline_array", 
#&gt;     cat2.Rd = "cat2", check_installed_packages.Rd = "check_installed_packages", 
#&gt;     col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", compoundInput2.Rd = "compoundInput2", 
#&gt;     decorate_function.Rd = "decorate_function", deparse_svec.Rd = "deparse_svec", 
#&gt;     dev_create.Rd = "dev_create", do_aggregate.Rd = "do_aggregate", 
#&gt;     drop_nulls.Rd = "drop_nulls", eval_dirty.Rd = "eval_dirty", 
#&gt;     fastmap2.Rd = "fastmap2", forelse.Rd = "forelse", getInputBinding.Rd = "getInputBinding", 
#&gt;     get_cpu.Rd = "get_cpu", get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", 
#&gt;     `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", `grapes-help-set-grapes.Rd` = "%?&lt;-%", 
#&gt;     `grapes-plus-grapes.Rd` = "%+-%", handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;     iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;     lock.Rd = "lock", make_async_evaluator.Rd = "make_async_evaluator", 
#&gt;     make_forked_clusters.Rd = "make_forked_clusters", map.Rd = "map", 
#&gt;     match_calls.Rd = "match_calls", mem_limit2.Rd = "mem_limit2", 
#&gt;     no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;     parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;     progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;     screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;     shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;     time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;     to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;     updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;     use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), file_in = c("AbstractMap.Rd", 
#&gt;     "AbstractQueue.Rd", "MasterEvaluator.Rd", "PersistContainer.Rd", 
#&gt;     "actionButtonStyled.Rd", "ask_or_default.Rd", "ask_yesno.Rd", 
#&gt;     "async.Rd", "async_expr.Rd", "async_flapply.Rd", "base64_to_image.Rd", 
#&gt;     "baseline_array.Rd", "cat2.Rd", "check_installed_packages.Rd", 
#&gt;     "col2hexStr.Rd", "collapse.Rd", "compoundInput2.Rd", "decorate_function.Rd", 
#&gt;     "deparse_svec.Rd", "dev_create.Rd", "do_aggregate.Rd", "drop_nulls.Rd", 
#&gt;     "eval_dirty.Rd", "fastmap2.Rd", "forelse.Rd", "getInputBinding.Rd", 
#&gt;     "get_cpu.Rd", "get_dots.Rd", "get_ram.Rd", "grapes-equals-greater-than-grapes.Rd", 
#&gt;     "grapes-help-set-grapes.Rd", "grapes-plus-grapes.Rd", "handler_dipsaus_progress.Rd", 
#&gt;     "iapply.Rd", "lapply_async2.Rd", "lock.Rd", "make_async_evaluator.Rd", 
#&gt;     "make_forked_clusters.Rd", "map.Rd", "match_calls.Rd", "mem_limit2.Rd", 
#&gt;     "no_op.Rd", "package_installed.Rd", "parse_svec.Rd", "prepare_install.Rd", 
#&gt;     "progress2.Rd", "registerInputBinding.Rd", "screenshot.Rd", 
#&gt;     "set_shiny_input.Rd", "shift_array.Rd", "sync_shiny_inputs.Rd", 
#&gt;     "time_delta.Rd", "to_datauri.Rd", "to_ram_size.Rd", "updateActionButtonStyled.Rd", 
#&gt;     "updateCompoundInput2.Rd", "update_fastmap2.Rd", "use_shiny_dipsaus.Rd"
#&gt;     ), file_out = c("AbstractMap.html", "AbstractQueue.html", 
#&gt;     "MasterEvaluator.html", "PersistContainer.html", "actionButtonStyled.html", 
#&gt;     "ask_or_default.html", "ask_yesno.html", "async.html", "async_expr.html", 
#&gt;     "async_flapply.html", "base64_to_image.html", "baseline_array.html", 
#&gt;     "cat2.html", "check_installed_packages.html", "col2hexStr.html", 
#&gt;     "collapse.html", "compoundInput2.html", "decorate_function.html", 
#&gt;     "deparse_svec.html", "dev_create.html", "do_aggregate.html", 
#&gt;     "drop_nulls.html", "eval_dirty.html", "fastmap2.html", "forelse.html", 
#&gt;     "getInputBinding.html", "get_cpu.html", "get_dots.html", 
#&gt;     "get_ram.html", "grapes-equals-greater-than-grapes.html", 
#&gt;     "grapes-help-set-grapes.html", "grapes-plus-grapes.html", 
#&gt;     "handler_dipsaus_progress.html", "iapply.html", "lapply_async2.html", 
#&gt;     "lock.html", "make_async_evaluator.html", "make_forked_clusters.html", 
#&gt;     "map.html", "match_calls.html", "mem_limit2.html", "no_op.html", 
#&gt;     "package_installed.html", "parse_svec.html", "prepare_install.html", 
#&gt;     "progress2.html", "registerInputBinding.html", "screenshot.html", 
#&gt;     "set_shiny_input.html", "shift_array.html", "sync_shiny_inputs.html", 
#&gt;     "time_delta.html", "to_datauri.html", "to_ram_size.html", 
#&gt;     "updateActionButtonStyled.html", "updateCompoundInput2.html", 
#&gt;     "update_fastmap2.html", "use_shiny_dipsaus.html"), alias = list(
#&gt;         AbstractMap.Rd = "AbstractMap", AbstractQueue.Rd = "AbstractQueue", 
#&gt;         MasterEvaluator.Rd = "MasterEvaluator", PersistContainer.Rd = "PersistContainer", 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled", ask_or_default.Rd = "ask_or_default", 
#&gt;         ask_yesno.Rd = "ask_yesno", async.Rd = "async", async_expr.Rd = "async_expr", 
#&gt;         async_flapply.Rd = "async_flapply", base64_to_image.Rd = "base64_to_image", 
#&gt;         baseline_array.Rd = "baseline_array", cat2.Rd = "cat2", 
#&gt;         check_installed_packages.Rd = "check_installed_packages", 
#&gt;         col2hexStr.Rd = "col2hexStr", collapse.Rd = "collapse", 
#&gt;         compoundInput2.Rd = "compoundInput2", decorate_function.Rd = c("decorate_function", 
#&gt;         "%D%"), deparse_svec.Rd = "deparse_svec", dev_create.Rd = "dev_create", 
#&gt;         do_aggregate.Rd = "do_aggregate", drop_nulls.Rd = "drop_nulls", 
#&gt;         eval_dirty.Rd = "eval_dirty", fastmap2.Rd = c("fastmap2", 
#&gt;         "[[.fastmap2", "$.fastmap2", "[[&lt;-.fastmap2", "$&lt;-.fastmap2", 
#&gt;         "[.fastmap2", "[&lt;-.fastmap2", "names.fastmap2", "print.fastmap2", 
#&gt;         "length.fastmap2", "as.list.fastmap2"), forelse.Rd = "forelse", 
#&gt;         getInputBinding.Rd = "getInputBinding", get_cpu.Rd = "get_cpu", 
#&gt;         get_dots.Rd = "get_dots", get_ram.Rd = "get_ram", `grapes-equals-greater-than-grapes.Rd` = "%=&gt;%", 
#&gt;         `grapes-help-set-grapes.Rd` = "%?&lt;-%", `grapes-plus-grapes.Rd` = "%+-%", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress", 
#&gt;         iapply.Rd = "iapply", lapply_async2.Rd = "lapply_async2", 
#&gt;         lock.Rd = c("lock", "dipsaus_lock", "dipsaus_unlock"), 
#&gt;         make_async_evaluator.Rd = "make_async_evaluator", make_forked_clusters.Rd = "make_forked_clusters", 
#&gt;         map.Rd = c("map", "session_map", "rds_map", "text_map", 
#&gt;         "qs_map", "redis_map"), match_calls.Rd = "match_calls", 
#&gt;         mem_limit2.Rd = "mem_limit2", no_op.Rd = "no_op", package_installed.Rd = "package_installed", 
#&gt;         parse_svec.Rd = "parse_svec", prepare_install.Rd = "prepare_install", 
#&gt;         progress2.Rd = "progress2", registerInputBinding.Rd = "registerInputBinding", 
#&gt;         screenshot.Rd = "screenshot", set_shiny_input.Rd = "set_shiny_input", 
#&gt;         shift_array.Rd = "shift_array", sync_shiny_inputs.Rd = "sync_shiny_inputs", 
#&gt;         time_delta.Rd = "time_delta", to_datauri.Rd = "to_datauri", 
#&gt;         to_ram_size.Rd = "to_ram_size", updateActionButtonStyled.Rd = "updateActionButtonStyled", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2", update_fastmap2.Rd = "update_fastmap2", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus"), funs = list(
#&gt;         AbstractMap.Rd = character(0), AbstractQueue.Rd = character(0), 
#&gt;         MasterEvaluator.Rd = character(0), PersistContainer.Rd = character(0), 
#&gt;         actionButtonStyled.Rd = "actionButtonStyled()", ask_or_default.Rd = "ask_or_default()", 
#&gt;         ask_yesno.Rd = "ask_yesno()", async.Rd = "async()", async_expr.Rd = "async_expr()", 
#&gt;         async_flapply.Rd = "async_flapply()", base64_to_image.Rd = "base64_to_image()", 
#&gt;         baseline_array.Rd = "baseline_array()", cat2.Rd = "cat2()", 
#&gt;         check_installed_packages.Rd = "check_installed_packages()", 
#&gt;         col2hexStr.Rd = "col2hexStr()", collapse.Rd = "collapse()", 
#&gt;         compoundInput2.Rd = "compoundInput2()", decorate_function.Rd = c("decorate_function()", 
#&gt;         "`%D%`"), deparse_svec.Rd = "deparse_svec()", dev_create.Rd = "dev_create()", 
#&gt;         do_aggregate.Rd = "do_aggregate()", drop_nulls.Rd = "drop_nulls()", 
#&gt;         eval_dirty.Rd = "eval_dirty()", fastmap2.Rd = c("fastmap2()", 
#&gt;         "`[[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`$&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "`[`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "`[&amp;lt;-`(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "names(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "print(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", 
#&gt;         "length(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)", "as.list(&lt;i&gt;&amp;lt;fastmap2&amp;gt;&lt;/i&gt;)"
#&gt;         ), forelse.Rd = "forelse()", getInputBinding.Rd = "getInputBinding()", 
#&gt;         get_cpu.Rd = "get_cpu()", get_dots.Rd = "get_dots()", 
#&gt;         get_ram.Rd = "get_ram()", `grapes-equals-greater-than-grapes.Rd` = "`%=&amp;gt;%`", 
#&gt;         `grapes-help-set-grapes.Rd` = "`%?&amp;lt;-%`", `grapes-plus-grapes.Rd` = "`%+-%`", 
#&gt;         handler_dipsaus_progress.Rd = "handler_dipsaus_progress()", 
#&gt;         iapply.Rd = "iapply()", lapply_async2.Rd = "lapply_async2()", 
#&gt;         lock.Rd = c("dipsaus_lock()", "dipsaus_unlock()"), make_async_evaluator.Rd = "make_async_evaluator()", 
#&gt;         make_forked_clusters.Rd = "make_forked_clusters()", map.Rd = c("session_map()", 
#&gt;         "rds_map()", "text_map()", "qs_map()", "redis_map()"), 
#&gt;         match_calls.Rd = "match_calls()", mem_limit2.Rd = "mem_limit2()", 
#&gt;         no_op.Rd = "no_op()", package_installed.Rd = "package_installed()", 
#&gt;         parse_svec.Rd = "parse_svec()", prepare_install.Rd = "prepare_install()", 
#&gt;         progress2.Rd = "progress2()", registerInputBinding.Rd = "registerInputBinding()", 
#&gt;         screenshot.Rd = "screenshot()", set_shiny_input.Rd = "set_shiny_input()", 
#&gt;         shift_array.Rd = "shift_array()", sync_shiny_inputs.Rd = "sync_shiny_inputs()", 
#&gt;         time_delta.Rd = "time_delta()", to_datauri.Rd = "to_datauri()", 
#&gt;         to_ram_size.Rd = "to_ram_size()", updateActionButtonStyled.Rd = "updateActionButtonStyled()", 
#&gt;         updateCompoundInput2.Rd = "updateCompoundInput2()", update_fastmap2.Rd = "update_fastmap2()", 
#&gt;         use_shiny_dipsaus.Rd = "use_shiny_dipsaus()"), title = c(AbstractMap.Rd = "Abstract Map to store key-value pairs", 
#&gt;     AbstractQueue.Rd = "Defines abstract queue class", MasterEvaluator.Rd = "Generator Class for Asynchronous Evaluation", 
#&gt;     PersistContainer.Rd = "Wrapper to cache key-value pairs and persist across sessions", 
#&gt;     actionButtonStyled.Rd = "Action Button but with customized styles", 
#&gt;     ask_or_default.Rd = "Read a Line from the Terminal, but with Default Values", 
#&gt;     ask_yesno.Rd = "Ask and Return True or False from the Terminal", 
#&gt;     async.Rd = "Evaluate expression in &lt;code&gt;async_expr&lt;/code&gt;", 
#&gt;     async_expr.Rd = "Apply R expressions in a parallel way", 
#&gt;     async_flapply.Rd = "Wrapper for &lt;code&gt;future.apply::future_lapply&lt;/code&gt;", 
#&gt;     base64_to_image.Rd = "Save \"Base64\" Data to Images", baseline_array.Rd = "Calculate Contrasts of Arrays in Different Methods", 
#&gt;     cat2.Rd = "Color Output", check_installed_packages.Rd = "Check If Packages Are Installed, Returns Missing Packages", 
#&gt;     col2hexStr.Rd = "Convert color to Hex string", collapse.Rd = "Collapse Sensors And Calculate Summations/Mean\n\n(stable)", 
#&gt;     compoundInput2.Rd = "Compound input that combines and extends shiny inputs", 
#&gt;     decorate_function.Rd = "Python-style decorator", deparse_svec.Rd = "Convert Integer Vectors To String\n\n(stable)", 
#&gt;     dev_create.Rd = "Create a group of named graphic devices", 
#&gt;     do_aggregate.Rd = "Make aggregate pipe-friendly", drop_nulls.Rd = "Drop &lt;code&gt;NULL&lt;/code&gt; values from list or vectors", 
#&gt;     eval_dirty.Rd = "Evaluate expressions", fastmap2.Rd = "A Wrapper for &lt;code&gt;fastmap::fastmap&lt;/code&gt;", 
#&gt;     forelse.Rd = "Python-style &lt;code&gt;\"for-else\"&lt;/code&gt; function", 
#&gt;     getInputBinding.Rd = "Obtain registered input bindings", 
#&gt;     get_cpu.Rd = "Get CPU Chip-set Information", get_dots.Rd = "Get element from dots &lt;code&gt;'...'&lt;/code&gt;", 
#&gt;     get_ram.Rd = "Get Memory Size", `grapes-equals-greater-than-grapes.Rd` = "A JavaScript style of creating functions", 
#&gt;     `grapes-help-set-grapes.Rd` = "Assign if not exists, or NULL\nProvides a way to assign default values to variables. If the statement\n`&lt;code&gt;lhs&lt;/code&gt;` is invalid or &lt;code&gt;NULL&lt;/code&gt;, this function will try to assign\n&lt;code&gt;value&lt;/code&gt;, otherwise nothing happens.", 
#&gt;     `grapes-plus-grapes.Rd` = "Plus-minus operator", handler_dipsaus_progress.Rd = "Progress-bar Handler", 
#&gt;     iapply.Rd = "Apply each elements with index as second input", 
#&gt;     lapply_async2.Rd = "Apply, but in parallel", lock.Rd = "Create or Unlock a Lock", 
#&gt;     make_async_evaluator.Rd = "Create Asynchronous Evaluator to Queue Tasks", 
#&gt;     make_forked_clusters.Rd = "Create forked clusters", map.Rd = "Create R object map.", 
#&gt;     match_calls.Rd = "Recursively match calls and modify arguments", 
#&gt;     mem_limit2.Rd = "Get max RAM size\nThis is an experimental function that is designed for non-windows systems", 
#&gt;     no_op.Rd = "Pipe-friendly no-operation function", package_installed.Rd = "Check if a package is installed", 
#&gt;     parse_svec.Rd = "Parse Text Into Numeric Vectors\n\n(stable)", 
#&gt;     prepare_install.Rd = "Install Packages at Next Startup", 
#&gt;     progress2.Rd = "'Shiny' progress bar, but can run without reactive context", 
#&gt;     registerInputBinding.Rd = "Register customized input to enable support by compound input", 
#&gt;     screenshot.Rd = "Take a screenshot in shiny apps", set_shiny_input.Rd = "Set Shiny Input", 
#&gt;     shift_array.Rd = "Shift Array by Index", sync_shiny_inputs.Rd = "Synchronize Shiny Inputs", 
#&gt;     time_delta.Rd = "Calculate time difference and return a number", 
#&gt;     to_datauri.Rd = "Convert file to 'base64' format", to_ram_size.Rd = "Convert bytes to KB, MB, GB,...", 
#&gt;     updateActionButtonStyled.Rd = "Update styled action button", 
#&gt;     updateCompoundInput2.Rd = "Update compound inputs", update_fastmap2.Rd = "Migrate a &lt;code&gt;fastmap2&lt;/code&gt; object to a new one", 
#&gt;     use_shiny_dipsaus.Rd = "Set up shiny plugins"), rd = list(
#&gt;         AbstractMap.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-abstract.R", 
#&gt;             "\n", list("AbstractMap"), "\n", list("AbstractMap"), 
#&gt;             "\n", list("Abstract Map to store key-value pairs"), 
#&gt;             "\n", list("\n", "Abstract Map to store key-value pairs\n"), 
#&gt;             "\n"), AbstractQueue.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/queue-abstract.R", 
#&gt;             "\n", list("AbstractQueue"), "\n", list("AbstractQueue"), 
#&gt;             "\n", list("Defines abstract queue class"), "\n", 
#&gt;             list("\n", "This class is inspired by ", list("https://cran.r-project.org/package=txtq"), 
#&gt;                 ".\n", "The difference is ", list("AbstractQueue"), 
#&gt;                 " introduce an abstract class that can\n", "be extended and can queue not only text messages, but also arbitrary R\n", 
#&gt;                 "objects, including expressions and environments. All the queue types in this\n", 
#&gt;                 "package inherit this class.\n"), "\n", list(
#&gt;                 list("Abstract Public Methods"), list("\n", "\n", 
#&gt;                   "\n", "Methods start with ", list("@..."), 
#&gt;                   " are not thread-safe. Most of them are not\n", 
#&gt;                   "used directly by users. However, you might want to override them if you\n", 
#&gt;                   "inherit this abstract class. Methods marked as \"(override)\" are not\n", 
#&gt;                   "implemented, meaning you are supposed to implement the details. Methods\n", 
#&gt;                   "marked as \"(optional)\" usually have default alternatives.\n", 
#&gt;                   "\n", list("\n", list(list(list("initialize(...)"), 
#&gt;                     " (override)"), list("\n", "The constructor. Usually three things to do during the process:\n", 
#&gt;                     "1. set ", list("get_locker"), " ", list(
#&gt;                       "free_locker"), " if you don't want to use the\n", 
#&gt;                     "default lockers. 2. set lock file (if using default lockers). 3. call\n", 
#&gt;                     list("self$connect(...)"), "\n")), "\n", 
#&gt;                     list(list(list("get_locker()"), ", ", list(
#&gt;                       "free_locker()"), " (optional)"), list(
#&gt;                       "\n", "Default is ", list("NULL"), " for each methods, and queue uses an internal\n", 
#&gt;                       list("private$default_get_locker"), " and ", 
#&gt;                       list("private$default_free_locker"), ".\n", 
#&gt;                       "These two methods are for customized locker, please\n", 
#&gt;                       "implement these two methods as functions during ", 
#&gt;                       list("self$initialization"), "\n", list(
#&gt;                         "get_locker"), " obtains and lock access (exclusive), and ", 
#&gt;                       list("free_locker"), "\n", "frees the locker. Once implemented, ", 
#&gt;                       list("private$exclusive"), " will take care\n", 
#&gt;                       "the rest. Type: function; parameters: none; return: none\n")), 
#&gt;                     "\n", list(list(list("@get_head()"), ", ", 
#&gt;                       list("@set_head(v)"), " (override)"), list(
#&gt;                       "\n", "Get head so that we know where we are in the queue ", 
#&gt;                       list("self$@get_head()"), "\n", "should return a integer indicating where we are at the queue\n", 
#&gt;                       list("self$@set_head(v)"), " stores that integer. Parameter ", 
#&gt;                       list("v"), " is always\n", "non-negative, this is guaranteed. Users are not supposed to call these\n", 
#&gt;                       "methods directly, use ", list("self$head"), 
#&gt;                       " and ", list("self$head&lt;-"), " instead.\n", 
#&gt;                       "However, if you inherit this class, you are supposed to override the methods.\n")), 
#&gt;                     "\n", list(list(list("@get_total()"), ", ", 
#&gt;                       list("@set_total(v)"), " (override)"), 
#&gt;                       list("\n", "Similar to ", list("@get_head"), 
#&gt;                         " and ", list("@set_head"), ", defines the total items\n", 
#&gt;                         "ever stored in the queue. total-head equals current items in the queue.\n")), 
#&gt;                     "\n", list(list(list("@inc_total(n=1)"), 
#&gt;                       " (optional)"), list("\n", "Increase total, usually this doesn't need to be override, unless you are\n", 
#&gt;                       "using files to store total and want to decrease number of file connections\n")), 
#&gt;                     "\n", list(list(list("@append_header(msg, ...)"), 
#&gt;                       " (override)"), list("\n", list("msg"), 
#&gt;                       " will be vector of strings, separated by \"|\", containing encoded\n", 
#&gt;                       "headers: `time`, `key`, `hash`, and `message`. to decode what's inside, you\n", 
#&gt;                       "can use ", list("self$print_items(stringr::str_split_fixed(msg, '\\|', 4))"), 
#&gt;                       ".\n", list("Make sure"), " to return a number, indicating number of items stored.\n", 
#&gt;                       "Unless handled elsewhere, usually ", list(
#&gt;                         "return(length(msg))"), ".\n")), "\n", 
#&gt;                     list(list(list("@store_value(value, key)"), 
#&gt;                       " (override)"), list("\n", "Defines how to store value. `key` is unique identifier generated from\n", 
#&gt;                       "time, queue ID, and value. Usually I use it as file name or key ID in\n", 
#&gt;                       "database. value is an arbitrary R object to store. you need to store value\n", 
#&gt;                       "somewhere and return a string that will be passed as `hash` in\n", 
#&gt;                       list("self$restore_value"), ".\n")), "\n", 
#&gt;                     list(list(list("restore_value(hash, key, preserve = FALSE)"), 
#&gt;                       " (override)"), list("\n", "Method to restore value from given combination of `hash` and `key`.\n", 
#&gt;                       "`hash` is the string returned by ", list(
#&gt;                         "@store_value"), ", and `key` is the same\n", 
#&gt;                       "as key in ", list("@store_value"), ". preserve is a indicator of whether to\n", 
#&gt;                       "preserve the value for future use. If set to ", 
#&gt;                       list("FALSE"), ", then you are\n", "supposed to free up the resource related to the value. (such as free memory\n", 
#&gt;                       "or disk space)\n")), "\n", list(list(list(
#&gt;                       "@log(n = -1, all = FALSE) (override)")), 
#&gt;                       list("\n", "get ", list("n"), " items from what you saved to during ", 
#&gt;                         list("@append_header"), ".\n", list("n"), 
#&gt;                         " less equal than 0 means listing all possible items.\n", 
#&gt;                         "If ", list("all=TRUE"), ", return all items (number of rows should equals to\n", 
#&gt;                         list("self$total"), "), including popped items. If ", 
#&gt;                         list("all=FALSE"), ", only\n", "return items in the queue (number of rows is ", 
#&gt;                         list("self$count"), "). The\n", "returned value should be a ", 
#&gt;                         list("n x 4"), " matrix. Usually I use\n", 
#&gt;                         list("stringr::str_split_fixed(..., '\\|', 4)"), 
#&gt;                         ". Please see all other\n", "types implemented for example.\n")), 
#&gt;                     "\n", list(list(list("@reset(...)"), " (override)"), 
#&gt;                       list("\n", "Reset queue, remove all items and reset head, total to be 0.\n")), 
#&gt;                     "\n", list(list(list("@clean()"), " (override)"), 
#&gt;                       list("\n", "Clean the queue, remove all the popped items.\n")), 
#&gt;                     "\n", list(list(list("@validate()"), " (override)"), 
#&gt;                       list("\n", "Validate the queue. Stop if the queue is broken.\n")), 
#&gt;                     "\n", list(list(list("@connect(con, ...)"), 
#&gt;                       " (override)"), list("\n", "Set up connection. Usually should be called at the end of\n", 
#&gt;                       list("self$initialization"), " to connect to a database, a folder, or an\n", 
#&gt;                       "existing queue you should do checks whether the connection is new or it's\n", 
#&gt;                       "an existing queue.\n")), "\n", list(list(
#&gt;                       list("connect(con, ...)"), " (optional)"), 
#&gt;                       list("\n", "Thread-safe version. sometimes you need to override this function instead\n", 
#&gt;                         "of ", list("@connect"), ", because ", 
#&gt;                         list("private$exclusive"), " requires ", 
#&gt;                         list("lockfile"), "\n", "to exist and to be locked. If you don't have lockers ready, or need to set\n", 
#&gt;                         "lockers during the connection, override this one.\n")), 
#&gt;                     "\n", list(list(list("destroy()"), " (optional)"), 
#&gt;                       list("\n", "Destroy a queue, free up space and call\n", 
#&gt;                         list("delayedAssign('.lockfile', {stop(...)}, assign.env=private)"), 
#&gt;                         " to raise\n", "error if a destroyed queue is called again later.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Methods"), 
#&gt;                 list("\n", "\n", "\n", "Usually don't need to override unless you know what you are doing.\n", 
#&gt;                   "\n", list("\n", list(list(list("push(value, message='',...)")), 
#&gt;                     list("\n", "Function to push an arbitrary R object to queue. ", 
#&gt;                       list("message"), " is a string\n", "giving notes to the pushed item. Usually message is stored with header,\n", 
#&gt;                       "separated from values. The goal is to describe the value. ", 
#&gt;                       list("..."), " is\n", "passed to ", list(
#&gt;                         "@append_header"), "\n")), "\n", list(
#&gt;                     list(list("pop(n = 1, preserve = FALSE)")), 
#&gt;                     list("\n", "Pop ", list("n"), " items from the queue. ", 
#&gt;                       list("preserve"), " indicates whether not to\n", 
#&gt;                       "free up the resources, though not always guaranteed.\n")), 
#&gt;                     "\n", list(list(list("print_item(item)"), 
#&gt;                       ", ", list("print_items(items)")), list(
#&gt;                       "\n", "To decode matrix returned by ", 
#&gt;                       list("log()"), ", returning named list or data frame\n", 
#&gt;                       "with four heads: `time`, `key`, `hash`, and `message`.\n")), 
#&gt;                     "\n", list(list(list("list(n=-1)")), list(
#&gt;                       "\n", "List items in the queue, decoded. If ", 
#&gt;                       list("n"), " is less equal than 0, then\n", 
#&gt;                       "list all results. The result is equivalent to\n", 
#&gt;                       list("self$print_items(self$log(n))"), 
#&gt;                       "\n")), "\n", list(list(list("log(n=-1,all=FALSE)")), 
#&gt;                       list("\n", "List items in the queue, encoded. This is used with ", 
#&gt;                         list("self$print_items"), ".\n", "When ", 
#&gt;                         list("all=TRUE"), ", result will list the  records ever pushed to the queue\n", 
#&gt;                         "since the last time queue is cleaned. When ", 
#&gt;                         list("all=FALSE"), ", results will be\n", 
#&gt;                         "items in the queue. ", list("n"), " is the number of items.\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n", list(list("Public Active Bindings"), 
#&gt;                 list("\n", "\n", "\n", list("\n", list(list(list(
#&gt;                   "id")), list("\n", "Read-only property. Returns unique ID of current queue.\n")), 
#&gt;                   "\n", list(list(list("lockfile")), list("\n", 
#&gt;                     "The lock file.\n")), "\n", list(list(list(
#&gt;                     "head")), list("\n", "Integer, total number of items popped, i.e. inactive items.\n")), 
#&gt;                   "\n", list(list(list("total")), list("\n", 
#&gt;                     "Total number of items ever pushed to the queue since last cleaned, integer.\n")), 
#&gt;                   "\n", list(list(list("count")), list("\n", 
#&gt;                     "Integer, read-only, equals to total - head, number of active items in the\n", 
#&gt;                     "queue\n")), "\n"), "\n")), "\n", "\n", list(
#&gt;                 list("Private Methods or properties"), list("\n", 
#&gt;                   "\n", "\n", list("\n", list(list(list(".id")), 
#&gt;                     list("\n", "Don't use directly. Used to store queue ID.\n")), 
#&gt;                     "\n", list(list(list(".lockfile")), list(
#&gt;                       "\n", "Location of lock file.\n")), "\n", 
#&gt;                     list(list(list("lock")), list("\n", "Preserve the file lock.\n")), 
#&gt;                     "\n", list(list(list("exclusive(expr,...)")), 
#&gt;                       list("\n", "Function to make sure the methods are thread-safe\n")), 
#&gt;                     "\n", list(list(list("default_get_locker()")), 
#&gt;                       list("\n", "Default method to lock a queue\n")), 
#&gt;                     "\n", list(list(list("default_free_locker")), 
#&gt;                       list("\n", "Default method to free a queue\n")), 
#&gt;                     "\n"), "\n")), "\n", "\n"), MasterEvaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("MasterEvaluator"), "\n", list("MasterEvaluator"), 
#&gt;             "\n", list("Generator Class for Asynchronous Evaluation"), 
#&gt;             "\n", list("\n", "Generator Class for Asynchronous Evaluation\n"), 
#&gt;             "\n"), PersistContainer.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/persist.R", 
#&gt;             "\n", list("PersistContainer"), "\n", list("PersistContainer"), 
#&gt;             "\n", list("Wrapper to cache key-value pairs and persist across sessions"), 
#&gt;             "\n", list("\n", "This class is designed to persist arbitrary R objects locally\n", 
#&gt;                 "and share across different sessions. The container consists two-level caches.\n", 
#&gt;                 "The first one is session-based, meaning it's only valid under current R\n", 
#&gt;                 "session and will be cleared once the session is shut down. The second is\n", 
#&gt;                 "the persist-level map, which will persist to hard drive and shared across\n", 
#&gt;                 "sessions. See ", list("cache"), " method in 'details'.\n"), 
#&gt;             "\n", list(list("Public Methods"), list("\n", "\n", 
#&gt;                 "\n", list("\n", list(list(list("initialize(..., backend = text_map)")), 
#&gt;                   list("\n", "The constructor. backend must inherit ", 
#&gt;                     list("AbstractMap"), ", ", list("..."), " will\n", 
#&gt;                     "be passed to ", list("backend$new(...)"), 
#&gt;                     ". To check available back-ends and their\n", 
#&gt;                     "use cases, see ", list(list("map")), ".\n")), 
#&gt;                   "\n", list(list(list("reset(all = FALSE)")), 
#&gt;                     list("\n", "Reset container. If all is set to be true, then reset session-based and\n", 
#&gt;                       "hard-drive-based, otherwise only reset session-based container.\n")), 
#&gt;                   "\n", list(list(list("destroy(all = FALSE)")), 
#&gt;                     list("\n", "destroy the container. Only use it when you want to finalize the container in\n", 
#&gt;                       list(list("reg.finalizer")), ".\n")), "\n", 
#&gt;                   list(list(list("has(key, signature = NULL)")), 
#&gt;                     list("\n", "returns a list of true/false (logical) vectors indicating whether keys exist\n", 
#&gt;                       "in the container, if signature is used when caching the key-value pairs, then\n", 
#&gt;                       "it also checks whether signature matches. This is very important as even if\n", 
#&gt;                       "the keys match but signature is wrong, the results will be false.\n")), 
#&gt;                   "\n", list(list(list("remove(keys, all = TRUE)")), 
#&gt;                     list("\n", "Remove keys in the container. Default is to remove the keys in both levels.\n", 
#&gt;                       "If ", list("all=FALSE"), ", then only remove the key in current session\n")), 
#&gt;                   "\n", list(list(list("cache(key, value, signature = NULL, replace = FALSE, persist = FALSE)")), 
#&gt;                     list("\n", list("key"), " and ", list("signature"), 
#&gt;                       " together form the unique identifier for the\n", 
#&gt;                       "value. By default ", list("signature"), 
#&gt;                       " is none, but it's very useful when value\n", 
#&gt;                       "if large, or ", list("key"), " is not a string. ", 
#&gt;                       list("replace"), " indicates whether\n", 
#&gt;                       "to force replace the key-value pairs even if the entry exists. If\n", 
#&gt;                       list("persist"), " is true, then the value is stored in hard-disks, otherwise\n", 
#&gt;                       "the value will be deleted once the session is closed.\n")), 
#&gt;                   "\n"), "\n")), "\n", "\n", list("\n", "\n", 
#&gt;                 "container = PersistContainer$new(tempfile())\n", 
#&gt;                 "\n", "# Reset the container so that values are cleared\n", 
#&gt;                 "container$reset(all = TRUE)\n", "\n", "# Store `1` to 'a' with signature 111 to a non-persist map\n", 
#&gt;                 "# returns 1\n", "container$cache(key = 'a', value = 1, signature = 111, persist = FALSE)\n", 
#&gt;                 "\n", "# Replace 'a' with 3\n", "# returns 3\n", 
#&gt;                 "container$cache(key = 'a', value = 3, signature = 111,\n", 
#&gt;                 "                persist = TRUE, replace = TRUE)\n", 
#&gt;                 "\n", "# check if 'a' exists with signature 111\n", 
#&gt;                 "container$has('a', signature = 111)    # TRUE\n", 
#&gt;                 "# When you only have 'a' but no signature\n", 
#&gt;                 "container$has('a')                     # TRUE\n", 
#&gt;                 "# check if 'a' exists with wrong signature 222\n", 
#&gt;                 "container$has('a', signature = 222)    # FALSE\n", 
#&gt;                 "\n", "\n", "# Store 'a' with 2 with same signature\n", 
#&gt;                 "# will fail and ignore the value (value will not be evaluated if signatured)\n", 
#&gt;                 "# Return 2 (Important! use cached values)\n", 
#&gt;                 "container$cache(key = 'a', value = {\n", "  print(123)\n", 
#&gt;                 "  return(2)\n", "}, signature = 111, replace = FALSE)\n", 
#&gt;                 "\n", "# When no signature is present\n", "# If the key exists (no signature provided), return stored value\n", 
#&gt;                 "# returns 3\n", "container$cache(key = 'a', value = 4)\n", 
#&gt;                 "\n", "# replace is TRUE (no signature provided), signature will be some default value\n", 
#&gt;                 "container$cache(key = 'a', value = 2, replace = TRUE)\n", 
#&gt;                 "\n", "# destroy the container to free disk space\n", 
#&gt;                 "container$destroy()\n"), "\n", list("\n", list(
#&gt;                 list("map")), "\n"), "\n"), actionButtonStyled.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("actionButtonStyled"), "\n", list("actionButtonStyled"), 
#&gt;             "\n", list("Action Button but with customized styles"), 
#&gt;             "\n", list("\n", "actionButtonStyled(\n", "  inputId,\n", 
#&gt;                 "  label,\n", "  icon = NULL,\n", "  width = NULL,\n", 
#&gt;                 "  type = \"primary\",\n", "  btn_type = \"button\",\n", 
#&gt;                 "  class = \"\",\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("inputId, label, icon, width, ..."), 
#&gt;                 list("passed to ", list("shiny::actionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type, choices are `default`, `primary`, `info`, `success`,\n", 
#&gt;                   "`warning`, and `danger`")), "\n", "\n", list(
#&gt;                   list("btn_type"), list("HTML tag type, either ", 
#&gt;                     list("\"button\""), " or ", list("\"a\""))), 
#&gt;                 "\n", "\n", list(list("class"), list("additional classes to be added to the button")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Action Button but with customized styles\n"), 
#&gt;             "\n", list("\n", "\n", "# demo('example-actionButtonStyled', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButtonStyled('btn', label = 'Click me', type = 'default'),\n", 
#&gt;                 "  actionButtonStyled('btn2', label = 'Click me2', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  btn_types = c('default', 'primary', 'info', 'success', 'warning', 'danger')\n", 
#&gt;                 "  observeEvent(input$btn, {\n", "    btype = btn_types[((input$btn-1) %% (length(btn_types)-1)) + 1]\n", 
#&gt;                 "    updateActionButtonStyled(session, 'btn2', type = btype)\n", 
#&gt;                 "  })\n", "  observeEvent(input$btn2, {\n", "    updateActionButtonStyled(session, 'btn',\n", 
#&gt;                 "                             disabled = c(FALSE,TRUE)[(input$btn2 %% 2) + 1])\n", 
#&gt;                 "  })\n", "}\n", "\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser=TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateActionButtonStyled")), 
#&gt;                 " for how to update the button.\n"), "\n"), ask_or_default.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("ask_or_default"), "\n", list("ask_or_default"), 
#&gt;             "\n", list("Read a Line from the Terminal, but with Default Values"), 
#&gt;             "\n", list("\n", "ask_or_default(..., default = \"\", end = \"\", level = \"INFO\")\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("default"), list("default value to return in case of blank input")), 
#&gt;                 "\n"), "\n", list("\n", "A character from the user's input, or the default value. See details.\n"), 
#&gt;             "\n", list("\n", "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask a question, providing defaults. Users\n", 
#&gt;                 "need to enter the answer. If the answer is blank (no space), then returns the\n", 
#&gt;                 "default, otherwise returns the user input.\n", 
#&gt;                 "\n", "This can only be used in an ", list(list(
#&gt;                   "interactive")), " session.\n"), "\n", list(
#&gt;                 "\n", "if(interactive()){\n", "ask_or_default('What is the best programming language?',\n", 
#&gt;                 "               default = 'PHP')\n", "}\n"), 
#&gt;             "\n", list("\n", list(list("cat2")), ", ", list(list(
#&gt;                 "readline")), ",\n", list(list("ask_yesno")), 
#&gt;                 "\n"), "\n"), ask_yesno.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("ask_yesno"), "\n", list("ask_yesno"), 
#&gt;             "\n", list("Ask and Return True or False from the Terminal"), 
#&gt;             "\n", list("\n", "ask_yesno(..., end = \"\", level = \"INFO\", error_if_canceled = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("..., end, level"), list(
#&gt;                 "passed to ", list(list("cat2")))), "\n", "\n", 
#&gt;                 list(list("error_if_canceled"), list("raise error if canceled.")), 
#&gt;                 "\n"), "\n", list("\n", "logical or ", list("NULL"), 
#&gt;                 " or raise an error. If \"yes\" is entered,\n", 
#&gt;                 "returns ", list("TRUE"), "; if \"no\" is entered, returns ", 
#&gt;                 list("FALSE"), "; if \"c\" is\n", "entered, ", 
#&gt;                 list("error_if_canceled=TRUE"), " will result in an error, otherwise\n", 
#&gt;                 "return ", list("NULL"), "\n"), "\n", list("\n", 
#&gt;                 "Ask a question and read from the terminal in interactive scenario\n"), 
#&gt;             "\n", list("\n", "The prompt string will ask for an yes or no question. Users need to\n", 
#&gt;                 "enter \"y\", \"yes\" for yes, \"n\", \"no\" or no, and \"c\" for cancel\n", 
#&gt;                 "(case-insensitive).\n", "\n", "This can only be used in an ", 
#&gt;                 list(list("interactive")), " session.\n"), "\n", 
#&gt;             list("\n", "if(interactive()){\n", "ask_yesno('Do you know how hard it is to submit an R package and ',\n", 
#&gt;                 "          'pass the CRAN checks?')\n", "ask_yesno('Can I pass the CRAN check this time?')\n", 
#&gt;                 "}\n"), "\n", list("\n", list(list("cat2")), 
#&gt;                 ", ", list(list("readline")), ",\n", list(list(
#&gt;                   "ask_or_default")), "\n"), "\n"), async.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async"), "\n", list("async"), "\n", list("Evaluate expression in ", 
#&gt;                 list("async_expr")), "\n", list("\n", "async(expr)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression")), 
#&gt;                 "\n"), "\n", list("\n", "Evaluate expression in ", 
#&gt;                 list("async_expr"), "\n"), "\n", list("\n", list(
#&gt;                 list("async_expr")), "\n"), "\n"), async_expr.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_expr"), "\n", list("async_expr"), "\n", 
#&gt;             list("Apply R expressions in a parallel way"), "\n", 
#&gt;             list("\n", "async_expr(\n", "  .X,\n", "  .expr,\n", 
#&gt;                 "  .varname = \"x\",\n", "  envir = parent.frame(),\n", 
#&gt;                 "  .pre_run = NULL,\n", "  .ncore = future::availableCores(),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 ".X"), list("a vector or a list to apply evaluation on")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression, unquoted")), 
#&gt;                 "\n", "\n", list(list(".varname"), list("variable name representing element of each ", 
#&gt;                   list(".X"))), "\n", "\n", list(list("envir"), 
#&gt;                   list("environment to evaluate expressions")), 
#&gt;                 "\n", "\n", list(list(".pre_run"), list("expressions to be evaluated before looping.")), 
#&gt;                 "\n", "\n", list(list(".ncore"), list("number of CPU cores")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("future::future"))), "\n"), "\n", list(
#&gt;                 "\n", "a list whose length equals to ", list(
#&gt;                   ".X"), ". The value of each item\n", "returned depends on whether ", 
#&gt;                 list("async"), " is called. See details for workflow.\n"), 
#&gt;             "\n", list("\n", "Apply R expressions in a parallel way\n"), 
#&gt;             "\n", list("\n", list("async_expr"), " uses ", list(
#&gt;                 "lapply"), " and ", list("future::future"), " internally.\n", 
#&gt;                 "Within each loop, an item in ", list("\".X\""), 
#&gt;                 " will be assigned to variable ", list("\"x\""), 
#&gt;                 "\n", "(defined by ", list("\".varname\""), ") and enter the evaluation. During the evaluation,\n", 
#&gt;                 "function ", list("async"), " is provided. Expressions within ", 
#&gt;                 list("async"), " will be\n", "evaluated in another session, otherwise will be evaluated in current session.\n", 
#&gt;                 "Below is the workflow:\n", list("\n", "  ", 
#&gt;                   list(), " Run ", list(".pre_run"), "\n", "  ", 
#&gt;                   list(), " For ", list("i"), " in ", list("seq_along(.X)"), 
#&gt;                   ":\n", "  ", list("\n", "    ", list(), " 1. Assign ", 
#&gt;                     list("x"), " with ", list(".X[[i]]"), ", variable name ", 
#&gt;                     list("x"), " is\n", "    defined by ", list(
#&gt;                       ".varname"), "\n", "    ", list(), " 2. Evaluate ", 
#&gt;                     list("expr"), " in current session.\n", "    ", 
#&gt;                     list("\n", "      ", list(), " a. If ", list(
#&gt;                       "async"), " is not called, return evaluated ", 
#&gt;                       list("expr"), "\n", "      ", list(), " b. If ", 
#&gt;                       list("async(aync_expr)"), " is called, evaluate ", 
#&gt;                       list("aync_expr"), "\n", "      in another session, and return the evaluation results if ", 
#&gt;                       list("aync_expr"), "\n", "    "), "\n", 
#&gt;                     "  "), "\n"), "\n"), "\n"), async_flapply.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels.R", "\n", 
#&gt;             list("async_flapply"), "\n", list("async_flapply"), 
#&gt;             "\n", list("Wrapper for ", list("future.apply::future_lapply")), 
#&gt;             "\n", list("\n", "async_flapply(X, FUN, ...)\n"), 
#&gt;             "\n", list("\n", list(list("X, FUN, ..."), list("passing to ", 
#&gt;                 list("future.apply::future_lapply"))), "\n"), 
#&gt;             "\n", list("\n", "Wrapper for ", list("future.apply::future_lapply"), 
#&gt;                 "\n"), "\n", list("\n", list(list("future_lapply")), 
#&gt;                 "\n"), "\n"), base64_to_image.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("base64_to_image"), "\n", list("base64_to_image"), 
#&gt;             "\n", list("Save \"Base64\" Data to Images"), "\n", 
#&gt;             list("\n", "base64_to_image(data, path)\n"), "\n", 
#&gt;             list("\n", list(list("data"), list("characters, encoded \"Base64\" data for images")), 
#&gt;                 "\n", "\n", list(list("path"), list("file path to save to")), 
#&gt;                 "\n"), "\n", list("\n", "Absolute path of the saved file\n"), 
#&gt;             "\n", list("\n", "Save \"Base64\" Data to Images\n"), 
#&gt;             "\n"), baseline_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-baseline_array.R", 
#&gt;             "\n", list("baseline_array"), "\n", list("baseline_array"), 
#&gt;             "\n", list("Calculate Contrasts of Arrays in Different Methods"), 
#&gt;             "\n", list("\n", "baseline_array(\n", "  x,\n", "  along_dim,\n", 
#&gt;                 "  baseline_indexpoints,\n", "  unit_dims = seq_along(dim(x))[-along_dim],\n", 
#&gt;                 "  method = c(\"percentage\", \"sqrt_percentage\", \"decibel\", \"zscore\", \"sqrt_zscore\")\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("x"), list(
#&gt;                 "array (tensor) to calculate contrast")), "\n", 
#&gt;                 "\n", list(list("along_dim"), list("integer range from 1 to the maximum dimension of ", 
#&gt;                   list("x"), ".\n", "baseline along this dimension, this is usually the time dimension.")), 
#&gt;                 "\n", "\n", list(list("baseline_indexpoints"), 
#&gt;                   list("integer vector, which index points are counted\n", 
#&gt;                     "into baseline window? Each index ranges from 1 to ", 
#&gt;                     list("dim(x)[[along_dim]]"), ".\n", "See Details.")), 
#&gt;                 "\n", "\n", list(list("unit_dims"), list("integer vector, baseline unit: see Details.")), 
#&gt;                 "\n", "\n", list(list("method"), list("character, baseline method options are:\n", 
#&gt;                   list("\"percentage\""), ", ", list("\"sqrt_percentage\""), 
#&gt;                   ", ", list("\"decibel\""), ",\n", list("\"zscore\""), 
#&gt;                   ", and ", list("\"sqrt_zscore\""))), "\n"), 
#&gt;             "\n", list("\n", "Contrast array with the same dimension as ", 
#&gt;                 list("x"), ".\n"), "\n", list("\n", "Provides five methods to baseline an array and calculate\n", 
#&gt;                 "contrast.\n"), "\n", list("\n", "Consider a scenario where we want to baseline a bunch of signals recorded\n", 
#&gt;                 "from different locations. For each location, we record ", 
#&gt;                 list("n"), " sessions.\n", "For each session, the signal is further decomposed into frequency-time\n", 
#&gt;                 "domain. In this case, we have the input ", list(
#&gt;                   "x"), " in the following form:\n", list(list(
#&gt;                   "session x frequency x time x location")), 
#&gt;                 "\n", "Now we want to calibrate signals for each session, frequency and location\n", 
#&gt;                 "using the first 100 time points as baseline points, then the code will be\n", 
#&gt;                 list(list("baseline_array(x, along_dim=3, 1:100, unit_dims=c(1,2,4))")), 
#&gt;                 "\n", list("along_dim=3"), " is dimension of time, in this case, it's the\n", 
#&gt;                 "third dimension of ", list("x"), ". ", list(
#&gt;                   "baseline_indexpoints=1:100"), ", meaning\n", 
#&gt;                 "the first 100 time points are used to calculate baseline.\n", 
#&gt;                 list("unit_dims"), " defines the unit signal. Its value ", 
#&gt;                 list("c(1,2,4)"), "\n", "means the unit signal is per session (first dimension), per frequency\n", 
#&gt;                 "(second) and per location (fourth).\n", "\n", 
#&gt;                 "In some other cases, we might want to calculate baseline across frequencies\n", 
#&gt;                 "then the unit signal is ", list(list("frequency x time")), 
#&gt;                 ", i.e. signals that share the\n", "same session and location also share the same baseline. In this case,\n", 
#&gt;                 "we assign ", list("unit_dims=c(1,4)"), ".\n", 
#&gt;                 "\n", "There are five baseline methods. They fit for different types of data.\n", 
#&gt;                 "Denote ", list(list("z")), " is an unit signal, ", 
#&gt;                 list(list("z_0")), " is its baseline slice. Then\n", 
#&gt;                 "these baseline methods are:\n", "\n", list("\n", 
#&gt;                   list(list(list("\"percentage\"")), list("\n", 
#&gt;                     list(list("\n", "  \\frac{z - \\bar{z_{0}}}{\\bar{z_{0}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (z / mean(z_0) - 1) x 100%\n")), 
#&gt;                     "\n")), "\n", list(list(list("\"sqrt_percentage\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z} - \\bar{\\sqrt{z_{0}}}}{\\bar{\\sqrt{z_{0}}}} \\times 100\\%\n"), 
#&gt;                       list("\n", "  (sqrt(z) / mean(sqrt(z_0)) - 1) x 100%\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"decibel\"")), 
#&gt;                     list("\n", list(list("\n", "  10 \\times ( \\log_{10}(z) - \\bar{\\log_{10}(z_{0})} )\n"), 
#&gt;                       list("\n", "  10 * ( log10 (z) - mean( log10(z_0) ) )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{z-\\bar{z_{0}}}{sd(z_{0})}\n"), 
#&gt;                       list("\n", "  (z - mean( z_0 )) / sd( z_0 )\n")), 
#&gt;                       "\n")), "\n", list(list(list("\"sqrt_zscore\"")), 
#&gt;                     list("\n", list(list("\n", "  \\frac{\\sqrt{z}-\\bar{\\sqrt{z_{0}}}}{sd(\\sqrt{z_{0}})}\n"), 
#&gt;                       list("\n", "  (sqrt(z) - mean( sqrt(z_0) )) / sd( sqrt(z_0) )\n")), 
#&gt;                       "\n")), "\n", "\n", "\n"), "\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(dipsaus)\n", "set.seed(1)\n", 
#&gt;                 "\n", "# Generate sample data\n", "dims = c(10,20,30,2)\n", 
#&gt;                 "x = array(rnorm(prod(dims))^2, dims)\n", "\n", 
#&gt;                 "# Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "baseline_window = sample(30, 10)\n", "\n", "# ----- baseline percentage change ------\n", 
#&gt;                 "\n", "# Using base functions\n", "re1 &lt;- aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "  m &lt;- mean(y[baseline_window])\n", "  (y/m - 1) * 100\n", 
#&gt;                 "}), c(2,3,1,4))\n", "\n", "# Using dipsaus\n", 
#&gt;                 "re2 &lt;- baseline_array(x, 3, baseline_window, c(1,2,4),\n", 
#&gt;                 "                      method = 'percentage')\n", 
#&gt;                 "\n", "# Check different, should be very tiny (double precisions)\n", 
#&gt;                 "range(re2 - re1)\n", "\n", "# Check speed for large dataset\n", 
#&gt;                 "if(interactive()){\n", "  dims = c(200,20,300,2)\n", 
#&gt;                 "  x = array(rnorm(prod(dims))^2, dims)\n", "  # Set baseline window to be arbitrary 10 timepoints\n", 
#&gt;                 "  baseline_window = seq_len(100)\n", "  f1 &lt;- function(){\n", 
#&gt;                 "    aperm(apply(x, c(1,2,4), function(y){\n", 
#&gt;                 "      m &lt;- mean(y[baseline_window])\n", "      (y/m - 1) * 100\n", 
#&gt;                 "    }), c(2,3,1,4))\n", "  }\n", "  f2 &lt;- function(){\n", 
#&gt;                 "    # equivalent as bl = x[,,baseline_window, ]\n", 
#&gt;                 "    #\n", "    baseline_array(x, along_dim = 3,\n", 
#&gt;                 "                   baseline_indexpoints = baseline_window,\n", 
#&gt;                 "                   unit_dims = c(1,2,4), method = 'sqrt_percentage')\n", 
#&gt;                 "  }\n", "  microbenchmark::microbenchmark(f1(), f2(), times = 3L)\n", 
#&gt;                 "}\n", "\n", "\n", "\n"), "\n"), cat2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("cat2"), "\n", list("cat2"), "\n", list("Color Output"), 
#&gt;             "\n", list("\n", "cat2(\n", "  ...,\n", "  level = \"DEBUG\",\n", 
#&gt;                 "  print_level = FALSE,\n", "  file = \"\",\n", 
#&gt;                 "  sep = \" \",\n", "  fill = FALSE,\n", "  labels = NULL,\n", 
#&gt;                 "  append = FALSE,\n", "  end = \"\\n\",\n", 
#&gt;                 "  pal = list(DEBUG = \"grey60\", INFO = \"#1d9f34\", WARNING = \"#ec942c\", ERROR =\n", 
#&gt;                 "    \"#f02c2c\", FATAL = \"#763053\", DEFAULT = \"grey60\"),\n", 
#&gt;                 "  use_cli = TRUE,\n", "  bullet = \"auto\"\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("..."), list(
#&gt;                 "to be printed")), "\n", "\n", list(list("level"), 
#&gt;                 list("'DEBUG', 'INFO', 'WARNING', 'ERROR', or 'FATAL' (total 5 levels)")), 
#&gt;                 "\n", "\n", list(list("print_level"), list("if true, prepend levels before messages")), 
#&gt;                 "\n", "\n", list(list("file, sep, fill, labels, append"), 
#&gt;                   list("pass to ", list("base::cat"))), "\n", 
#&gt;                 "\n", list(list("end"), list("character to append to the string")), 
#&gt;                 "\n", "\n", list(list("pal"), list("a named list defining colors see details")), 
#&gt;                 "\n", "\n", list(list("use_cli"), list("logical, whether to use package 'cli'")), 
#&gt;                 "\n", "\n", list(list("bullet"), list("character, if use 'cli', which symbol to show. see\n", 
#&gt;                   list(list("symbol")))), "\n"), "\n", list("\n", 
#&gt;                 "none.\n"), "\n", list("\n", "Color Output\n"), 
#&gt;             "\n", list("\n", "There are five levels of colors by default: 'DEBUG', 'INFO', 'WARNING', 'ERROR',\n", 
#&gt;                 "or FATAL. Default colors are: 'DEBUG' (", list(
#&gt;                   "grey60"), "), 'INFO' (", list("#1d9f34"), 
#&gt;                 "), 'WARNING'\n", "(", list("#ec942c"), "), 'ERROR' (", 
#&gt;                 list("#f02c2c"), "), 'FATAL' (", list("#763053"), 
#&gt;                 ") and\n", "'DEFAULT' (", list("#000000"), ", black). If level is not in preset five levels,\n", 
#&gt;                 "the color will be \"default\"-black color.\n"), 
#&gt;             "\n"), check_installed_packages.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("check_installed_packages"), "\n", list(
#&gt;                 "check_installed_packages"), "\n", list("Check If Packages Are Installed, Returns Missing Packages"), 
#&gt;             "\n", list("\n", "check_installed_packages(\n", "  pkgs,\n", 
#&gt;                 "  libs = base::.libPaths(),\n", "  auto_install = FALSE,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "pkgs"), list("vector of packages to install")), 
#&gt;                 "\n", "\n", list(list("libs"), list("paths of libraries")), 
#&gt;                 "\n", "\n", list(list("auto_install"), list("automatically install packages if missing")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters for ", 
#&gt;                   list("install.packages"))), "\n"), "\n", list(
#&gt;                 "\n", "package names that are not installed\n"), 
#&gt;             "\n", list("\n", "Check If Packages Are Installed, Returns Missing Packages\n"), 
#&gt;             "\n"), col2hexStr.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("col2hexStr"), "\n", list("col2hexStr"), 
#&gt;             "\n", list("Convert color to Hex string"), "\n", 
#&gt;             list("\n", "col2hexStr(col, alpha = NULL, prefix = \"#\", ...)\n"), 
#&gt;             "\n", list("\n", list(list("col"), list("character or integer indicating color")), 
#&gt;                 "\n", "\n", list(list("alpha"), list(list("NULL"), 
#&gt;                   " or numeric, transparency. See ", list("grDevices::rgb"))), 
#&gt;                 "\n", "\n", list(list("prefix"), list("character, default is ", 
#&gt;                   list("\"#\""))), "\n", "\n", list(list("..."), 
#&gt;                   list("passing to  ", list(list("adjustcolor")))), 
#&gt;                 "\n"), "\n", list("\n", "characters containing the hex value of each color. See details\n"), 
#&gt;             "\n", list("\n", "Convert color to Hex string\n"), 
#&gt;             "\n", list("\n", list("col2hexStr"), " converts colors such as 1, 2, 3, \"red\", \"blue\", ... into\n", 
#&gt;                 "hex strings that can be easily recognized by `HTML`, `CSS` and `JavaScript`.\n", 
#&gt;                 "Internally this function uses ", list(list("adjustcolor")), 
#&gt;                 " with two differences:\n", list("\n", list(), 
#&gt;                   " the returned hex string does not contain alpha value if ", 
#&gt;                   list("alpha"), " is ", list("NULL"), ";\n", 
#&gt;                   list(), " the leading prefix \"#\" can be customized\n"), 
#&gt;                 "\n"), "\n", list("\n", "\n", "col2hexStr(1, prefix = '0x')      # \"0x000000\"\n", 
#&gt;                 "col2hexStr('blue')                # \"#0000FF\"\n", 
#&gt;                 "\n", "# Change default palette, see \"grDevices::colors()\"\n", 
#&gt;                 "grDevices::palette(c('orange3', 'skyblue1'))\n", 
#&gt;                 "col2hexStr(1)                     # Instead of #000000, #CD8500\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("adjustcolor")), 
#&gt;                 "\n"), "\n"), collapse.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("collapse"), "\n", list("collapse"), "\n", 
#&gt;             list("Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "collapse(x, keep, average = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("A numeric multi-mode tensor (array), without ", 
#&gt;                 list("NA"))), "\n", "\n", list(list("keep"), 
#&gt;                 list("Which dimension to keep")), "\n", "\n", 
#&gt;                 list(list("average"), list("collapse to sum or mean")), 
#&gt;                 "\n"), "\n", list("\n", "a collapsed array with values to be mean or summation along\n", 
#&gt;                 "collapsing dimensions\n"), "\n", list("\n", 
#&gt;                 "Collapse Sensors And Calculate Summations/Mean\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "# Example 1\n", 
#&gt;                 "x = matrix(1:16, 4)\n", "\n", "# Keep the first dimension and calculate sums along the rest\n", 
#&gt;                 "collapse(x, keep = 1)\n", "rowSums(x)  # Should yield the same result\n", 
#&gt;                 "\n", "# Example 2\n", "x = array(1:120, dim = c(2,3,4,5))\n", 
#&gt;                 "result = collapse(x, keep = c(3,2))\n", "compare = apply(x, c(3,2), sum)\n", 
#&gt;                 "sum(abs(result - compare)) # The same, yield 0 or very small number (1e-10)\n", 
#&gt;                 "\n", "# Example 3 (performance)\n", "RcppParallel::setThreadOptions(numThreads = -1) # auto multicores\n", 
#&gt;                 "# Small data, no big difference, even slower\n", 
#&gt;                 "x = array(rnorm(240), dim = c(4,5,6,2))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L, check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  }\n", ")\n", "\n", "# large data big difference\n", 
#&gt;                 "x = array(rnorm(prod(300,200,105)), c(300,200,105,1))\n", 
#&gt;                 "microbenchmark::microbenchmark(\n", "  result = collapse(x, keep = c(3,2)),\n", 
#&gt;                 "  compare = apply(x, c(3,2), sum),\n", "  times = 1L , check = function(v){\n", 
#&gt;                 "    max(abs(range(do.call('-', v)))) &lt; 1e-10\n", 
#&gt;                 "  })\n", "\n"), "\n"), compoundInput2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("compoundInput2"), "\n", list("compoundInput2"), 
#&gt;             "\n", list("Compound input that combines and extends shiny inputs"), 
#&gt;             "\n", list("\n", "compoundInput2(\n", "  inputId,\n", 
#&gt;                 "  label = \"Group\",\n", "  components = shiny::tagList(),\n", 
#&gt;                 "  initial_ncomp = 1,\n", "  min_ncomp = 0,\n", 
#&gt;                 "  max_ncomp = 10,\n", "  value = NULL,\n", "  label_color = 1,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "inputId"), list("character, shiny input ID")), 
#&gt;                 "\n", "\n", list(list("label"), list("character, will show on each groups")), 
#&gt;                 "\n", "\n", list(list("components"), list("`HTML` tags that defines and combines HTML components within groups")), 
#&gt;                 "\n", "\n", list(list("initial_ncomp"), list(
#&gt;                   "numeric initial number of groups to show, non-negative")), 
#&gt;                 "\n", "\n", list(list("min_ncomp"), list("minimum number of groups, default is 0, non-negative")), 
#&gt;                 "\n", "\n", list(list("max_ncomp"), list("maximum number of groups, default is 10, greater or equal\n", 
#&gt;                   "than ", list("min_ncomp"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, initial values of each inputs, see examples.")), 
#&gt;                 "\n", "\n", list(list("label_color"), list("integer or characters, length of 1 or ", 
#&gt;                   list("max_ncomp"), ",\n", "assigning colors to each group labels,")), 
#&gt;                 "\n", "\n", list(list("..."), list("will be ignored")), 
#&gt;                 "\n"), "\n", list("\n", "`HTML` tags\n"), "\n", 
#&gt;             list("\n", "Compound input that combines and extends shiny inputs\n"), 
#&gt;             "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    list(),                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "# Source - system.file('demo/example-compountInput2.R', package='dipsaus')\n", 
#&gt;                 "\n", "# demo('example-compountInput2', package='dipsaus')\n", 
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  fluidRow(\n", "    column(\n", 
#&gt;                 "      width = 4,\n", "      compoundInput2(\n", 
#&gt;                 "        'compound', 'Group Label', label_color = 1:10,\n", 
#&gt;                 "        components = div(\n", "          textInput('txt', 'Text'),\n", 
#&gt;                 "          selectInput('sel', 'Select', choices = 1:10, multiple = TRUE),\n", 
#&gt;                 "          sliderInput('sli', 'Slider', max=1, min=0, val=0.5)\n", 
#&gt;                 "        ),\n", "        value = list(\n", "          list(txt = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "          '',                # no settings for second group\n", 
#&gt;                 "          list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "        )\n", "      ),\n", "      hr(),\n", 
#&gt;                 "      actionButton('action', 'Update compound input')\n", 
#&gt;                 "    )\n", "  )\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observe({\n", "    print(input$compound)\n", 
#&gt;                 "  })\n", "  observe({\n", "    # Getting specific input at group 1\n", 
#&gt;                 "    print(input$compound_txt_1)\n", "  })\n", 
#&gt;                 "  observeEvent(input$action, {\n", "    updateCompoundInput2(\n", 
#&gt;                 "      session, 'compound',\n", "      # Update values for each components\n", 
#&gt;                 "      value = lapply(1:5, function(ii){\n", 
#&gt;                 "        list(\n", "          txt = sample(LETTERS, 1),\n", 
#&gt;                 "          sel = sample(1:10, 3),\n", "          sli = runif(1)\n", 
#&gt;                 "        )\n", "      }), ncomp = NULL, txt = list(label = as.character(Sys.time())))\n", 
#&gt;                 "  })\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server, options = list(launch.browser = TRUE))\n", 
#&gt;                 "}\n", "\n"), "\n", list("\n", list(list("updateCompoundInput2")), 
#&gt;                 " for how to update inputs\n"), "\n"), decorate_function.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("decorate_function"), "\n", list("decorate_function"), 
#&gt;             "\n", list("%D%"), "\n", list("Python-style decorator"), 
#&gt;             "\n", list("\n", "decorate_function(orig, decor, ...)\n", 
#&gt;                 "\n", "lhs %D% rhs\n"), "\n", list("\n", list(
#&gt;                 list("orig, lhs"), list("any function")), "\n", 
#&gt;                 "\n", list(list("decor, rhs"), list("decorator function that takes ", 
#&gt;                   list("orig"), " as its first\n", "argument")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("decor"))), "\n"), "\n", list("\n", "Python-style decorator\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# Example 1: basic usage\n", 
#&gt;                 "# Decorator that prints summary of results and return results itself\n", 
#&gt;                 "verbose_summary &lt;- function(...){\n", "  summary_args &lt;- list(...)\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      results &lt;- f(...)\n", 
#&gt;                 "\n", "\n", "      print(do.call(\n", "        summary,\n", 
#&gt;                 "        c(list(results), summary_args)\n", "      ))\n", 
#&gt;                 "      results\n", "\n", "    }\n", "  }\n", 
#&gt;                 "\n", "}\n", "\n", "# runs as.list, but through verbose_summary\n", 
#&gt;                 "as_list2 &lt;- decorate_function(as.list, verbose_summary)\n", 
#&gt;                 "\n", "# run test\n", "res &lt;- as_list2(1:3)  # will verbose summary\n", 
#&gt;                 "identical(res, as.list(1:3))\n", "\n", "# Example 2\n", 
#&gt;                 "x &lt;- 1:20\n", "y &lt;- x + rnorm(20)\n", "\n", 
#&gt;                 "# decorator, add a line with slope 1 with given intercept\n", 
#&gt;                 "abline_xy &lt;- function(b){\n", "  function(f){\n", 
#&gt;                 "    function(...){\n", "      f(...)\n", "      intercept &lt;- get_dots('intercept', 0, ...)\n", 
#&gt;                 "      abline(a = intercept, b = b)\n", "    }\n", 
#&gt;                 "  }\n", "}\n", "\n", "# orig, plot whatever x vs jittered+intercept\n", 
#&gt;                 "plot_xy &lt;- function(x, intercept = rnorm(1)){\n", 
#&gt;                 "  plot(x, jitter(x, amount = 3) + intercept)\n", 
#&gt;                 "}\n", "\n", "# new function that decorate plot_xy with abline_xy, and\n", 
#&gt;                 "# returns the intercept\n", "plot_xy2 &lt;- decorate_function(plot_xy, abline_xy, b = 1)\n", 
#&gt;                 "\n", "# alternatively, you might also want to try\n", 
#&gt;                 "plot_xy2 &lt;- plot_xy %D% abline_xy(b = 1)\n", 
#&gt;                 "\n", "plot_xy2(x = 1:20)\n", "\n"), "\n"), deparse_svec.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/strings.R", "\n", 
#&gt;             list("deparse_svec"), "\n", list("deparse_svec"), 
#&gt;             "\n", list("Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)"), "\n", list("\n", "deparse_svec(\n", 
#&gt;                 "  nums,\n", "  connect = \"-\",\n", "  concatenate = TRUE,\n", 
#&gt;                 "  collapse = \",\",\n", "  max_lag = 1\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("nums"), list("integer vector")), 
#&gt;                 "\n", "\n", list(list("connect"), list("character used to connect consecutive numbers")), 
#&gt;                 "\n", "\n", list(list("concatenate"), list("connect strings if there are multiples")), 
#&gt;                 "\n", "\n", list(list("collapse"), list("if concatenate, character used to connect strings")), 
#&gt;                 "\n", "\n", list(list("max_lag"), list("defines \"consecutive\", min = 1")), 
#&gt;                 "\n"), "\n", list("\n", "strings representing the input vector. For example, ", 
#&gt;                 list("c(1, 2, 3)"), " returns \"1-3\".\n"), "\n", 
#&gt;             list("\n", "Convert Integer Vectors To String\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "deparse_svec(c(1:10, 15:18))\n"), 
#&gt;             "\n", list("\n", list(list("parse_svec")), "\n"), 
#&gt;             "\n"), dev_create.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/graphics.R", 
#&gt;             "\n", list("dev_create"), "\n", list("dev_create"), 
#&gt;             "\n", list("Create a group of named graphic devices"), 
#&gt;             "\n", list("\n", "dev_create(..., env = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("..."), list("named expressions to launch devices")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate expressions")), 
#&gt;                 "\n"), "\n", list("\n", "A list of functions to query, control, and switch between devices\n"), 
#&gt;             "\n", list("\n", "Create a group of named graphic devices\n"), 
#&gt;             "\n", list("\n", list(" ## Unix-specific example\n", 
#&gt;                 "\n", "# Create multiple named devices\n", "devs &lt;- dev_create(line = X11(), points = x11())\n", 
#&gt;                 "\n", "# switch to device named \"points\"\n", 
#&gt;                 "\n", "devs$dev_which('points')\n", "plot(1:10)\n", 
#&gt;                 "\n", "# switch to \"line\" device\n", "devs$dev_switch('line')\n", 
#&gt;                 "plot(1:100, type='l')\n", "\n", "# Create another group with conflict name\n", 
#&gt;                 "dev_another &lt;- dev_create(line = X11())\n", 
#&gt;                 "\n", "# Query device name with 'line'\n", "dev_another$dev_which('line')  # 4\n", 
#&gt;                 "devs$dev_which('line')  # 2, doesn't conflict with the new groups\n", 
#&gt;                 "\n", "dev.list()\n", "# close one or more device\n", 
#&gt;                 "dev_another$dev_off('line')\n", "dev.list()\n", 
#&gt;                 "\n", "# close all devices\n", "devs$dev_off()\n", 
#&gt;                 "dev.list()\n", "\n"), "\n"), "\n"), do_aggregate.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("do_aggregate"), "\n", list("do_aggregate"), 
#&gt;             "\n", list("Make aggregate pipe-friendly"), "\n", 
#&gt;             list("\n", "do_aggregate(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("x"), list("an R object")), "\n", 
#&gt;                 "\n", list(list("..."), list("other parameters passed to ", 
#&gt;                   list(list("aggregate")))), "\n"), "\n", list(
#&gt;                 "\n", "Results from ", list(list("aggregate")), 
#&gt;                 "\n"), "\n", list("\n", "A pipe-friendly wrapper of ", 
#&gt;                 list(list("aggregate")), "\n", "when using formula as input.\n"), 
#&gt;             "\n", list("\n", "\n", "library(magrittr)\n", "data(ToothGrowth)\n", 
#&gt;                 "\n", "ToothGrowth %&gt;%\n", "  do_aggregate(len ~ ., mean)\n", 
#&gt;                 "\n"), "\n", list("\n", list(list("aggregate")), 
#&gt;                 "\n"), "\n"), drop_nulls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("drop_nulls"), "\n", list("drop_nulls"), 
#&gt;             "\n", list("Drop ", list("NULL"), " values from list or vectors"), 
#&gt;             "\n", list("\n", "drop_nulls(x, .invalids = list(\"is.null\"))\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("list to check")), 
#&gt;                 "\n", "\n", list(list(".invalids"), list("a list of functions, or function name. Default is 'is.null'.")), 
#&gt;                 "\n"), "\n", list("\n", "list or vector containing no invalid values\n"), 
#&gt;             "\n", list("\n", "Drop ", list("NULL"), " values from list or vectors\n"), 
#&gt;             "\n", list("\n", "\n", "x &lt;- list(NULL,NULL,1,2)\n", 
#&gt;                 "drop_nulls(x)  # length of 2\n", "\n"), "\n"), 
#&gt;         eval_dirty.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("eval_dirty"), "\n", list("eval_dirty"), 
#&gt;             "\n", list("Evaluate expressions"), "\n", list("\n", 
#&gt;                 "eval_dirty(expr, env = parent.frame(), data = NULL, quoted = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("expr"), list("R expression or 'rlang' quo")), 
#&gt;                 "\n", "\n", list(list("env"), list("environment to evaluate")), 
#&gt;                 "\n", "\n", list(list("data"), list("dataframe or list")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("Is the expression quoted? By default, this is ", 
#&gt;                   list("TRUE"), ".\n", "This is useful when you don't want to use an expression that is stored in a\n", 
#&gt;                   "variable; see examples")), "\n"), "\n", list(
#&gt;                 "\n", "the executed results of ", list("expr"), 
#&gt;                 " evaluated with side effects.\n"), "\n", list(
#&gt;                 "\n", "Evaluate expressions\n"), "\n", list("\n", 
#&gt;                 list("eval_dirty"), " uses ", list("base::eval()"), 
#&gt;                 " function to evaluate\n", "expressions. Compare to ", 
#&gt;                 list("rlang::eval_tidy"), ", which won't affect original\n", 
#&gt;                 "environment, ", list("eval_dirty"), " causes changes to the environment. Therefore\n", 
#&gt;                 "if ", list("expr"), " contains assignment, environment will be changed in this case.\n"), 
#&gt;             "\n", list("\n", "\n", "env = new.env(); env$a = 1\n", 
#&gt;                 "rlang::eval_tidy(quote({a &lt;- 111}), env = env)\n", 
#&gt;                 "print(env$a)  # Will be 1. This is because eval_tidy has no side effect\n", 
#&gt;                 "\n", "eval_dirty(quote({a &lt;- 111}), env)\n", 
#&gt;                 "print(env$a)  # 111, a is changed\n", "\n", 
#&gt;                 "# Unquoted case\n", "eval_dirty({a &lt;- 222}, env, quoted = FALSE)\n", 
#&gt;                 "print(env$a)\n", "\n"), "\n"), fastmap2.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/fastmap2.R", "\n", 
#&gt;             list("fastmap2"), "\n", list("fastmap2"), "\n", list(
#&gt;                 "[[.fastmap2"), "\n", list("$.fastmap2"), "\n", 
#&gt;             list("[[&lt;-.fastmap2"), "\n", list("$&lt;-.fastmap2"), 
#&gt;             "\n", list("[.fastmap2"), "\n", list("[&lt;-.fastmap2"), 
#&gt;             "\n", list("names.fastmap2"), "\n", list("print.fastmap2"), 
#&gt;             "\n", list("length.fastmap2"), "\n", list("as.list.fastmap2"), 
#&gt;             "\n", list("A Wrapper for ", list("fastmap::fastmap")), 
#&gt;             "\n", list("\n", "fastmap2(missing_default = NULL)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name)\n", 
#&gt;                 "\n", list(list("[["), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("$"), list("fastmap2")), "(x, name) &lt;- value\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...)\n", 
#&gt;                 "\n", list(list("["), list("fastmap2")), "(x, i, j = NULL, ...) &lt;- value\n", 
#&gt;                 "\n", list(list("names"), list("fastmap2")), 
#&gt;                 "(x)\n", "\n", list(list("print"), list("fastmap2")), 
#&gt;                 "(x, ...)\n", "\n", list(list("length"), list(
#&gt;                   "fastmap2")), "(x)\n", "\n", list(list("as.list"), 
#&gt;                   list("fastmap2")), "(x, ...)\n"), "\n", list(
#&gt;                 "\n", list(list("missing_default"), list("passed to ", 
#&gt;                   list("fastmap::fastmap"))), "\n", "\n", list(
#&gt;                   list("x"), list("a ", list("'fastmap2'"), " object")), 
#&gt;                 "\n", "\n", list(list("name"), list("name, or key of the value")), 
#&gt;                 "\n", "\n", list(list("value"), list("any R object")), 
#&gt;                 "\n", "\n", list(list("i, j"), list("vector of names")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to other methods")), 
#&gt;                 "\n"), "\n", list("\n", "A list of ", list("'fastmap2'"), 
#&gt;                 " instance\n"), "\n", list("\n", list(list("fastmap")), 
#&gt;                 "\n", "provides a key-value store where the keys are strings and the\n", 
#&gt;                 "values are any R objects. It differs from normal environment that\n", 
#&gt;                 list(list("fastmap")), " avoids memory leak. ", 
#&gt;                 list("fastmap2"), "\n", "is a wrapper for ", 
#&gt;                 list("fastmap"), ", which provides several generic\n", 
#&gt;                 "functions such that it has similar behaviors to lists or\n", 
#&gt;                 "environments\n"), "\n", list("\n", "\n", "## --------------------------- Basic Usage --------------------------\n", 
#&gt;                 "map &lt;- fastmap2()\n", "map$a = 1\n", "map$b = 2\n", 
#&gt;                 "print(map)\n", "\n", "map[c('a', 'b')]\n", "# Alternative way\n", 
#&gt;                 "map['a', 'b']\n", "\n", "map[c('c', 'd')] &lt;- 3:4\n", 
#&gt;                 "# or\n", "map['e', 'f'] &lt;- 5:6\n", "\n", "# The order is not guaranteed, unless sort=TRUE\n", 
#&gt;                 "as.list(map)\n", "as.list(map, sort=TRUE)\n", 
#&gt;                 "\n", "names(map)\n", "length(map)\n", "\n", 
#&gt;                 "## ----------------------- NULL value handles -----------------------\n", 
#&gt;                 "map$b &lt;- NULL\n", "names(map)   # 'b' still exists!\n", 
#&gt;                 "as.list(map) # 'b' is NULL, but still there\n", 
#&gt;                 "\n", "# to remove 'b', you have to use `@remove` method\n", 
#&gt;                 "map$`@remove`('b')\n", "\n", "## ---------------- Native fastmap::fastmap methods -----------------\n", 
#&gt;                 "\n", "# whether map has 'a'\n", "map$`@has`('a')\n", 
#&gt;                 "\n", "# Remove a name from list\n", "map$`@remove`('a')\n", 
#&gt;                 "\n", "# remove all from list\n", "map$`@reset`()\n", 
#&gt;                 "print(map)\n", "\n"), "\n"), forelse.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/apply.R", "\n", 
#&gt;             list("forelse"), "\n", list("forelse"), "\n", list(
#&gt;                 "Python-style ", list("\"for-else\""), " function"), 
#&gt;             "\n", list("\n", "forelse(x, FUN, ALT_FUN = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("iterative R objects such as list, vector, etc.")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("function that applies to each ", 
#&gt;                   list("x"))), "\n", "\n", list(list("ALT_FUN"), 
#&gt;                   list("function that takes no argument or other types of R\n", 
#&gt;                     "object")), "\n"), "\n", list("\n", "If any ", 
#&gt;                 list("FUN"), " returns anything other than ", 
#&gt;                 list("NULL"), ",\n", "then the function returns the first none ", 
#&gt;                 list("NULL"), " object. If\n", "all ", list("x"), 
#&gt;                 " fed to ", list("FUN"), " return ", list("NULL"), 
#&gt;                 ", then this\n", "function returns ", list("ALT_FUN"), 
#&gt;                 " (if ", list("ALT_FUN"), " is not a function)\n", 
#&gt;                 "or the result of ", list("ALT_FUN()"), ".\n"), 
#&gt;             "\n", list("\n", "Provide Python-style ", list("\"for-else\""), 
#&gt;                 " that works as\n", "follows: for each element, execute \"for\" block, if there is break\n", 
#&gt;                 "while executing \"for\" block, then just stop and ignore the \"else\"\n", 
#&gt;                 "statement, otherwise run \"else\" block.\n"), 
#&gt;             "\n", list("\n", "\n", "# --------------------------- Basic Usage ------------------------------\n", 
#&gt;                 "\n", "# 1. ALT_FUN get executed because FUN returns NULL for all items in x\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x &gt; 10) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  function(){\n", "    cat('ALT_FUN is executed!\\n')\n", 
#&gt;                 "    'wow'\n", "  }\n", ")\n", "\n", "# 2. FUN returns non-NULL object\n", 
#&gt;                 "forelse(\n", "  1:10,\n", "  function(x){\n", 
#&gt;                 "    cat('The input is ', x, end = '\\n')\n", 
#&gt;                 "    if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "  },\n", "  'wow'\n", ")\n", "\n", "# --------------------------- Performance ------------------------------\n", 
#&gt;                 "FUN &lt;- function(x){\n", "  Sys.sleep(0.01)\n", 
#&gt;                 "  if( x %% 2 == 0 ) return(x) else return(NULL)\n", 
#&gt;                 "}\n", "\n", "microbenchmark::microbenchmark({\n", 
#&gt;                 "  forelse(1:10, FUN, 'wow')\n", "}, {\n", "  y &lt;- unlist(lapply(1:10, FUN))\n", 
#&gt;                 "  if(length(y)){\n", "    y &lt;- y[[1]]\n", "  }else{\n", 
#&gt;                 "    y &lt;- 'wow'\n", "  }\n", "}, {\n", "  y &lt;- NULL\n", 
#&gt;                 "  for(x in 1:10){ y &lt;- FUN(x) }\n", "  if(is.null(y)){ y &lt;- 'wow' }\n", 
#&gt;                 "}, times = 3)\n", "\n", "\n"), "\n"), getInputBinding.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("getInputBinding"), "\n", list("getInputBinding"), 
#&gt;             "\n", list("Obtain registered input bindings"), "\n", 
#&gt;             list("\n", "getInputBinding(fname, pkg = NULL, envir = parent.frame())\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("input function name, character or quoted expression\n", 
#&gt;                 "such as ", list("'shiny::textInput'"), " or ", 
#&gt;                 list("numericInput"), ".")), "\n", "\n", list(
#&gt;                 list("pkg"), list("(optional), name of package")), 
#&gt;                 "\n", "\n", list(list("envir"), list("environment to evaluate ", 
#&gt;                   list("fname"), " if ", list("pkg"), " is not provided")), 
#&gt;                 "\n"), "\n", list("\n", "a list containing: 1. `JavaScript` input binding name; 2. `R` updating function name\n"), 
#&gt;             "\n", list("\n", "Obtain registered input bindings\n"), 
#&gt;             "\n", list("\n", "\n", "library(dipsaus)\n", "\n", 
#&gt;                 "# Most recommended usage\n", "getInputBinding('compoundInput2', pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Other usages\n", "getInputBinding('shiny::textInput')\n", 
#&gt;                 "\n", "\n", "getInputBinding(shiny::textInput)\n", 
#&gt;                 "\n", "getInputBinding(compoundInput2, pkg = 'dipsaus')\n", 
#&gt;                 "\n", "# Bad usage, raise errors in some cases\n", 
#&gt;                 list("\n", "## You need to library(shiny), or set envir=asNamespace('shiny'), or pkg='shiny'\n", 
#&gt;                   "getInputBinding('textInput')\n", "getInputBinding(textInput) # also fails\n", 
#&gt;                   "\n", "## Always fails\n", "getInputBinding('dipsaus::compoundInput2', pkg = 'dipsaus')\n"), 
#&gt;                 "\n", "\n"), "\n"), get_cpu.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_cpu"), "\n", list("get_cpu"), "\n", 
#&gt;             list("Get CPU Chip-set Information"), "\n", list(
#&gt;                 "\n", "get_cpu()\n"), "\n", list("\n", "a list of vendor ID and CPU model name\n"), 
#&gt;             "\n", list("\n", "Get CPU Chip-set Information\n"), 
#&gt;             "\n"), get_dots.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("get_dots"), "\n", list("get_dots"), "\n", 
#&gt;             list("Get element from dots ", list("'...'")), "\n", 
#&gt;             list("\n", "get_dots(..name, ..default = NULL, ...)\n"), 
#&gt;             "\n", list("\n", list(list("..name"), list("character name of the argument")), 
#&gt;                 "\n", "\n", list(list("..default"), list("R object to return if argument not found")), 
#&gt;                 "\n", "\n", list(list("..."), list("dots that contains argument")), 
#&gt;                 "\n"), "\n", list("\n", "Get specific key values from ", 
#&gt;                 list("'...'"), " without\n", "evaluating the rest of arguments.\n"), 
#&gt;             "\n", list("\n", "One could use ", list("list(...)[[name]]"), 
#&gt;                 " to extract any keys\n", "from the dots. However, such way reduces code readability. If\n", 
#&gt;                 "some arguments have not evaluated, ", list("list(...)"), 
#&gt;                 " will\n", list(list("force")), " evaluating them. Normally it's fine if\n", 
#&gt;                 "these expressions take little time to run, but if the\n", 
#&gt;                 "expression require time to run, ", list(list(
#&gt;                   "get_dots")), " avoids\n", "unnecessary evaluations.\n"), 
#&gt;             "\n", list("\n", "\n", "\n", "# ------------------------ Basic Usage ---------------------------\n", 
#&gt;                 "plot2 &lt;- function(...){\n", "  title = get_dots('main', 'There is no title', ...)\n", 
#&gt;                 "  plot(...)\n", "  title\n", "}\n", "\n", "plot2(1:10)\n", 
#&gt;                 "plot2(1:10, main = 'Scatter Plot of 1:10')\n", 
#&gt;                 "\n", "# ------------------------ Comparisons ----------------------------\n", 
#&gt;                 "f1 &lt;- function(...){ get_dots('x', ...) }\n", 
#&gt;                 "f2 &lt;- function(...){ list(...)[['x']] }\n", 
#&gt;                 "delayedAssign('y', { cat('y is evaluated!') })\n", 
#&gt;                 "\n", "# y will not evaluate\n", "f1(x = 1, y = y)\n", 
#&gt;                 "\n", "# y gets evaluated\n", "f2(x = 1, y = y)\n", 
#&gt;                 "\n", "# -------------------- Decorator example --------------------------\n", 
#&gt;                 "ret_range &lt;- function(which_range = 'y'){\n", 
#&gt;                 "  function(f){\n", "    function(...){\n", "      f(...)\n", 
#&gt;                 "      y_range &lt;- range(get_dots(which_range, 0, ...))\n", 
#&gt;                 "      y_range\n", "    }\n", "  }\n", "}\n", 
#&gt;                 "plot_ret_yrange &lt;- plot %D% ret_range('y')\n", 
#&gt;                 "plot_ret_yrange(x = 1:10, y = rnorm(10))\n", 
#&gt;                 "\n", "\n"), "\n"), get_ram.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/systems.R", 
#&gt;             "\n", list("get_ram"), "\n", list("get_ram"), "\n", 
#&gt;             list("Get Memory Size"), "\n", list("\n", "get_ram()\n"), 
#&gt;             "\n", list("\n", "numeric in Bytes how big your system RAM is\n"), 
#&gt;             "\n", list("\n", "Get Memory Size\n"), "\n"), `grapes-equals-greater-than-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%=&gt;%"), "\n", list("%=&gt;%"), "\n", list("A JavaScript style of creating functions"), 
#&gt;             "\n", list("\n", "args %=&gt;% expr\n"), "\n", list(
#&gt;                 "\n", list(list("args"), list("function arguments: see ", 
#&gt;                   list(list("formals")))), "\n", "\n", list(list(
#&gt;                   "expr"), list("R expression that forms the body of functions: see ", 
#&gt;                   list(list("body")))), "\n"), "\n", list("\n", 
#&gt;                 "A function that takes ", list("args"), " as parameters and ", 
#&gt;                 list("expr"), " as\n", "the function body\n"), 
#&gt;             "\n", list("\n", "A JavaScript style of creating functions\n"), 
#&gt;             "\n", list("\n", "# Formal arguments\n", "c(a) %=&gt;% {\n", 
#&gt;                 "  print(a)\n", "}\n", "\n", "# Informal arguments\n", 
#&gt;                 "list(a=) %=&gt;% {\n", "  print(a)\n", "}\n", "\n", 
#&gt;                 "# Multiple inputs\n", "c(a, b = 2, ...) %=&gt;% {\n", 
#&gt;                 "  print(c(a, b, ...))\n", "}\n", "\n", "# ----- JavaScript style of forEach -----\n", 
#&gt;                 "# ### Equivalent JavaScript Code:\n", "# LETTERS.forEach((el, ii) =&gt; {\n", 
#&gt;                 "#   console.log('The index of letter ' + el + ' in \"x\" is: ' + ii);\n", 
#&gt;                 "# });\n", "\n", "iapply(LETTERS, c(el, ii) %=&gt;% {\n", 
#&gt;                 "  cat2('The index of letter ', el, ' in ', sQuote('x'), ' is: ', ii)\n", 
#&gt;                 "}) -&gt; results\n"), "\n"), `grapes-help-set-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%?&lt;-%"), "\n", list("%?&lt;-%"), "\n", list("Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens."), 
#&gt;             "\n", list("\n", "lhs %?&lt;-% value\n"), "\n", list(
#&gt;                 "\n", list(list("lhs"), list("an object to check or assign")), 
#&gt;                 "\n", "\n", list(list("value"), list("value to be assigned if lhs is NULL")), 
#&gt;                 "\n"), "\n", list("\n", "Assign value on the right-hand side to the left-hand side if\n", 
#&gt;                 list("lhs"), " does not exist or is ", list("NULL"), 
#&gt;                 "\n"), "\n", list("\n", "Assign if not exists, or NULL\n", 
#&gt;                 "Provides a way to assign default values to variables. If the statement\n", 
#&gt;                 "`", list("lhs"), "` is invalid or ", list("NULL"), 
#&gt;                 ", this function will try to assign\n", list(
#&gt;                   "value"), ", otherwise nothing happens.\n"), 
#&gt;             "\n", list("\n", "# Prepare, remove aaa if exists\n", 
#&gt;                 "if(exists('aaa', envir = globalenv(), inherits = FALSE)){\n", 
#&gt;                 "  rm(aaa, envir = globalenv())\n", "}\n", "\n", 
#&gt;                 "# Assign\n", "aaa %?&lt;-% 1; print(aaa)\n", "\n", 
#&gt;                 "# However, if assigned, nothing happens\n", 
#&gt;                 "aaa = 1;\n", "aaa %?&lt;-% 2;\n", "print(aaa)\n", 
#&gt;                 "\n", "# in a list\n", "a = list()\n", "a$e %?&lt;-% 1; print(a$e)\n", 
#&gt;                 "a$e %?&lt;-% 2; print(a$e)\n", "\n"), "\n"), `grapes-plus-grapes.Rd` = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/language.R", "\n", 
#&gt;             list("%+-%"), "\n", list("%+-%"), "\n", list("Plus-minus operator"), 
#&gt;             "\n", list("\n", "a %+-% b\n"), "\n", list("\n", 
#&gt;                 list(list("a, b"), list("numeric vectors, matrices or arrays")), 
#&gt;                 "\n"), "\n", list("\n", list("a +/- b"), ", the dimension depends on ", 
#&gt;                 list("a+b"), ". If ", list("a+b"), " is\n", "a scalar, returns a vector of two; in the case of vector, returns a matrix;\n", 
#&gt;                 "all other cases will return an array with the last dimension equal to 2.\n"), 
#&gt;             "\n", list("\n", "Plus-minus operator\n"), "\n", 
#&gt;             list("\n", "\n", "# scalar\n", "1 %+-% 2   # -1, 3\n", 
#&gt;                 "\n", "# vector input\n", "c(1,2,3) %+-% 2   # matrix\n", 
#&gt;                 "\n", "# matrix input\n", "matrix(1:9, 3) %+-% 2   # 3x3x2 array\n", 
#&gt;                 "\n"), "\n"), handler_dipsaus_progress.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("handler_dipsaus_progress"), "\n", list(
#&gt;                 "handler_dipsaus_progress"), "\n", list("Progress-bar Handler"), 
#&gt;             "\n", list("\n", "handler_dipsaus_progress(\n", "  title = getOption(\"dipsaus.progressr.title\", \"Progress\"),\n", 
#&gt;                 "  intrusiveness = getOption(\"progressr.intrusiveness.gui\", 1),\n", 
#&gt;                 "  target = if (is.null(shiny::getDefaultReactiveDomain())) \"terminal\" else \"gui\",\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "title"), list("default title of ", list(list(
#&gt;                 "progress2")))), "\n", "\n", list(list("intrusiveness"), 
#&gt;                 list("A non-negative scalar on how intrusive\n", 
#&gt;                   "(disruptive) the reporter to the user")), 
#&gt;                 "\n", "\n", list(list("target"), list("where progression updates are rendered")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("make_progression_handler")))), "\n"), 
#&gt;             "\n", list("\n", "Handler for ", list(list("progress2")), 
#&gt;                 " to support\n", list("progressr::handlers"), 
#&gt;                 ". See examples for detailed use case\n"), "\n", 
#&gt;             list("\n", "\n", "\n", "library(progressr)\n", "library(shiny)\n", 
#&gt;                 "library(future)\n", "\n", "## ------------------------------ Setup! -------------------------------\n", 
#&gt;                 "handlers(handler_dipsaus_progress())\n", "\n", 
#&gt;                 "# ------------------------------ A simple usage ------------------------\n", 
#&gt;                 "xs &lt;- 1:5\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- lapply(xs, function(x) {\n", "    p(sprintf(\"x=%g\", x))\n", 
#&gt;                 "    Sys.sleep(0.1)\n", "    sqrt(x)\n", "  })\n", 
#&gt;                 "})\n", "\n", "# ------------------------ A future.apply case -------------------------\n", 
#&gt;                 "plan(sequential)\n", "# test it yourself with plan(multisession)\n", 
#&gt;                 "\n", "handlers(handler_dipsaus_progress())\n", 
#&gt;                 "with_progress({\n", "  p &lt;- progressor(along = xs)\n", 
#&gt;                 "  y &lt;- future.apply::future_lapply(xs, function(x) {\n", 
#&gt;                 "    p(sprintf(\"x=%g\", x))\n", "    Sys.sleep(0.1)\n", 
#&gt;                 "    sqrt(x)\n", "  })\n", "})\n", "\n", "# ------------------------ A shiny case --------------------------------\n", 
#&gt;                 "\n", "ui &lt;- fluidPage(\n", "  actionButton('ok', 'Run Demo')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  handlers(handler_dipsaus_progress())\n", "  make_forked_clusters()\n", 
#&gt;                 "\n", "  observeEvent(input$ok, {\n", "    with_progress({\n", 
#&gt;                 "      p &lt;- progressor(along = 1:100)\n", "      y &lt;- future.apply::future_lapply(1:100, function(x) {\n", 
#&gt;                 "        p(sprintf(\"Input %d|Result %d\", x, x+1))\n", 
#&gt;                 "        Sys.sleep(1)\n", "        x+1\n", "      })\n", 
#&gt;                 "    })\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n", 
#&gt;                 "\n"), "\n"), iapply.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/apply.R", 
#&gt;             "\n", list("iapply"), "\n", list("iapply"), "\n", 
#&gt;             list("Apply each elements with index as second input"), 
#&gt;             "\n", list("\n", "iapply(X, FUN, ..., .method = c(\"sapply\", \"lapply\", \"vapply\"))\n"), 
#&gt;             "\n", list("\n", list(list("X"), list("a vector (atomic or list)")), 
#&gt;                 "\n", "\n", list(list("FUN"), list("the function to be applied to each element of ", 
#&gt;                   list("X"), ": see `Details`.")), "\n", "\n", 
#&gt;                 list(list("..."), list("passed to apply methods")), 
#&gt;                 "\n", "\n", list(list(".method"), list("method to use, default is ", 
#&gt;                   list(list("sapply")))), "\n"), "\n", list("\n", 
#&gt;                 "a list or matrix depends on ", list(".method"), 
#&gt;                 ". See ", list(list("lapply")), "\n"), "\n", 
#&gt;             list("\n", "Apply function with an index variable as the second input.\n"), 
#&gt;             "\n", list("\n", list("FUN"), " will be further passed to the apply methods. Unlike\n", 
#&gt;                 list(list("lapply")), ", ", list("FUN"), " is expected to have at least two arguments.\n", 
#&gt;                 "The first argument is each element of ", list(
#&gt;                   "X"), ", the second argument is the\n", "index number of the element.\n"), 
#&gt;             "\n"), lapply_async2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels-future.R", 
#&gt;             "\n", list("lapply_async2"), "\n", list("lapply_async2"), 
#&gt;             "\n", list("Apply, but in parallel"), "\n", list(
#&gt;                 "\n", "lapply_async2(\n", "  x,\n", "  FUN,\n", 
#&gt;                 "  FUN.args = list(),\n", "  callback = NULL,\n", 
#&gt;                 "  plan = TRUE,\n", "  future.chunk.size = NULL,\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "x"), list("vector, list")), "\n", "\n", list(
#&gt;                 list("FUN"), list("function to apply on each element of ", 
#&gt;                   list("x"))), "\n", "\n", list(list("FUN.args"), 
#&gt;                 list("more arguments to feed into ", list("FUN"))), 
#&gt;                 "\n", "\n", list(list("callback"), list("function to run after each iteration")), 
#&gt;                 "\n", "\n", list(list("plan"), list("logical, or character or ", 
#&gt;                   list("future"), " plan; see Details.")), "\n", 
#&gt;                 "\n", list(list("future.chunk.size"), list("see also\n", 
#&gt;                   list(list("future_eapply")), ". If you want the callbacks\n", 
#&gt;                   "to be called immediately after each loop, then set it to ", 
#&gt;                   list("1"), ",\n", "which is not optimal but the only way right now.")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list(list("plan")))), "\n"), "\n", list("\n", 
#&gt;                 "same as\n", list("with(FUN.args, lapply(x, function(el){eval(body(FUN))}))"), 
#&gt;                 "\n"), "\n", list("\n", "Apply, but in parallel\n"), 
#&gt;             "\n", list("\n", "When ", list("plan"), " is logical, ", 
#&gt;                 list("FALSE"), " means use current plan.\n", 
#&gt;                 "If ", list("plan=TRUE"), ", then it equals to ", 
#&gt;                 list("plan='multicore'"), ". For\n", "characters, ", 
#&gt;                 list("plan"), " can be ", list("'multicore'"), 
#&gt;                 ", ", list("'callr'"), ",\n", list("'sequential'"), 
#&gt;                 ", ", list("'multisession'"), ", ", list("'multiprocess'"), 
#&gt;                 ",\n", "etc. Alternatively, you could pass future ", 
#&gt;                 list(list("plan")), "\n", "objects.\n"), "\n", 
#&gt;             list("\n", "\n", "library(future)\n", "plan(sequential)\n", 
#&gt;                 "\n", "# Use sequential plan\n", "# 1. Change `plan` to 'multicore', 'multisession', or TRUE to enable\n", 
#&gt;                 "# multi-core, but still with progress information\n", 
#&gt;                 "# 2. Change plan=FALSE will use current future plan\n", 
#&gt;                 "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = function(e){\n", 
#&gt;                 "  sprintf('Input=%d', e)\n", "}, plan = 'sequential')\n", 
#&gt;                 "\n", "# Disable callback message, then the function reduce to\n", 
#&gt;                 "# normal `future.apply::future_lapply`\n", "res &lt;- lapply_async2(100:200, function(x){\n", 
#&gt;                 "  return(x+1)\n", "}, callback = NULL, plan = FALSE)\n", 
#&gt;                 "\n", "\n"), "\n"), lock.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/lock.R", 
#&gt;             "\n", list("lock"), "\n", list("lock"), "\n", list(
#&gt;                 "dipsaus_lock"), "\n", list("dipsaus_unlock"), 
#&gt;             "\n", list("Create or Unlock a Lock"), "\n", list(
#&gt;                 "\n", "dipsaus_lock(name, exclusive = TRUE, timeout = 10)\n", 
#&gt;                 "\n", "dipsaus_unlock(name, exclusive = TRUE, timeout = 10)\n"), 
#&gt;             "\n", list("\n", list(list("name"), list("character, the locker's name, must be only letters and digits")), 
#&gt;                 "\n", "\n", list(list("exclusive"), list("logical whether the locker is exclusive. True for write\n", 
#&gt;                   "access, False for read access. Default is true.")), 
#&gt;                 "\n", "\n", list(list("timeout"), list("numeric, seconds to wait for the locker to lock or unlock")), 
#&gt;                 "\n"), "\n", list("\n", "Logical, whether the operation succeed.\n"), 
#&gt;             "\n", list("\n", "A wrapper for ", list(list("lock")), 
#&gt;                 ", but user can\n", "interrupt the lock procedure anytime, and don't have to worry about\n", 
#&gt;                 "whether the lock exists or not.\n"), "\n", list(
#&gt;                 "\n", "# unlock to prepare for the example\n", 
#&gt;                 "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "# Create a locker, return TRUE\n", "lock_success = dipsaus_lock('testlocker')\n", 
#&gt;                 "if(lock_success){\n", "  cat2('testlocker has been locked')\n", 
#&gt;                 "}\n", "\n", "# test whether locker has been locked\n", 
#&gt;                 "lock_success = dipsaus_lock('testlocker', timeout = 0.01)\n", 
#&gt;                 "if(!lock_success){\n", "  cat2('attempt to lock testlocker failed')\n", 
#&gt;                 "}\n", "\n", "# unlock\n", "dipsaus_unlock('testlocker', timeout = 0.01)\n", 
#&gt;                 "\n", "\n"), "\n"), make_async_evaluator.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/parallels-workers.R", 
#&gt;             "\n", list("make_async_evaluator"), "\n", list("make_async_evaluator"), 
#&gt;             "\n", list("Create Asynchronous Evaluator to Queue Tasks"), 
#&gt;             "\n", list("\n", "make_async_evaluator(\n", "  name,\n", 
#&gt;                 "  path = tempfile(),\n", "  n_nodes = 1,\n", 
#&gt;                 "  n_subnodes = future::availableCores() - 1,\n", 
#&gt;                 "  verbose = FALSE,\n", "  ...\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("name"), list("unique name for the evaluator")), 
#&gt;                 "\n", "\n", list(list("path"), list("blank directory for evaluator to store data")), 
#&gt;                 "\n", "\n", list(list("n_nodes"), list("number of control nodes, default is 1")), 
#&gt;                 "\n", "\n", list(list("n_subnodes"), list("number of sub-sessions for each control node, default is\n", 
#&gt;                   "the number of CPU cores minus 1")), "\n", 
#&gt;                 "\n", list(list("verbose"), list("for internal debug use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to the constructor of ", 
#&gt;                   list(list("MasterEvaluator")))), "\n"), "\n", 
#&gt;             list("\n", "Asynchronous evaluator aims at queuing R evaluations from sub-processes\n", 
#&gt;                 "without blocking the main session. It's based on ", 
#&gt;                 list("'parallel'"), " and\n", list("'future'"), 
#&gt;                 " packages.\n"), "\n", list("\n", list("'parallel'"), 
#&gt;                 " blocks the main session when evaluating expressions.\n", 
#&gt;                 list("'future'"), " blocks the main session when the number of running futures\n", 
#&gt;                 "exceed the maximum number of workers. (For example if 4 workers are planned,\n", 
#&gt;                 "then running 5 future instances at the same time will freeze the session).\n", 
#&gt;                 "\n", "Asynchronous evaluator is designed to queue any number of R expressions\n", 
#&gt;                 "without blocking the main session. The incoming expressions are stored in\n", 
#&gt;                 list(list("AbstractQueue")), " instances, and main session monitors\n", 
#&gt;                 "the queue and is charge of notifying child sessions to evaluate these\n", 
#&gt;                 "expressions whenever available.\n", "\n", "Important: Asynchronous evaluator is not designed for super high-performance\n", 
#&gt;                 "computing. The internal scheduler schedules ", 
#&gt;                 list("n_nodes"), " evaluations for\n", "every 1 second. Therefore if each of the process can be finished within\n", 
#&gt;                 list("1 / n_nodes"), " seconds, then use `future` instead.\n"), 
#&gt;             "\n", list(list("Value"), list("\n", "\n", "\n", 
#&gt;                 "A list of functions to control the evaluator:\n", 
#&gt;                 "\n", list("\n", "\n", list(list(list("run(expr, success = NULL, failure = NULL, priority = 0,\n", 
#&gt;                   "persist = FALSE, quoted = FALSE, ..., .list = NULL)")), 
#&gt;                   list("\n", "Queue and run an R expression.\n", 
#&gt;                     "\n", list("\n", "\n", list(list(list("expr")), 
#&gt;                       list("\n", " can be anything except for\n", 
#&gt;                         list("q()"), ", which terminates the session. ", 
#&gt;                         list("'rlang'"), "\n", list(list("nse-force")), 
#&gt;                         " is also supported. For example, you\n", 
#&gt;                         "can use ", list("`!!`"), " to quasi-quote the expression and unquote the values.\n")), 
#&gt;                       "\n", "\n", list(list(list("..., .list")), 
#&gt;                         list("\n", "provides additional data for ", 
#&gt;                           list("expr"), ". For example,\n", list(
#&gt;                             "expr"), " uses a large data object ", 
#&gt;                           list("dat"), " in the main session, which\n", 
#&gt;                           "might not be available to the child sessions. Also because the object\n", 
#&gt;                           "is large, quasi-quotation could be slow or fail. By passing ", 
#&gt;                           list("dat=..."), "\n", "or ", list(
#&gt;                             ".list=list(dat=...)"), ", it's able to temporary store the data on\n", 
#&gt;                           "hard-drive and persist for evaluators. The back-end is using\n", 
#&gt;                           list(list("qs_map")), ", which is super fast for data that are no\n", 
#&gt;                           "more than ", list("2GB"), ".\n")), 
#&gt;                       "\n", "\n", list(list(list("success"), 
#&gt;                         " and ", list("failure")), list("\n", 
#&gt;                         "functions to handle the results once\n", 
#&gt;                         "the evaluator returns the value. Since it's almost impossible to know\n", 
#&gt;                         "when the evaluator returns values, it's recommended that these functions\n", 
#&gt;                         "to be simple.\n")), "\n", "\n", list(
#&gt;                         list(list("priority")), list("\n", "puts the priority of the expression. It can only be `0` or\n", 
#&gt;                           "`1`. Evaluators will run expressions with priority equal to 1 first.\n")), 
#&gt;                       "\n", "\n", list(list(list("persist")), 
#&gt;                         list("\n", "indicates whether to run the expression and persist\n", 
#&gt;                           "intermediate variables.\n")), "\n"), 
#&gt;                     "\n")), "\n", "\n", list(list(list("terminate()")), 
#&gt;                   list("\n", "Shut down and release all the resource.\n")), 
#&gt;                   "\n", "\n", list(list(list("scale_down(n_nodes, n_subnodes = 1)"), 
#&gt;                     ",\n", "      ", list("scale_up(n_nodes, n_subnodes = 1,\n", 
#&gt;                       "      create_if_missing = FALSE, path = tempfile())")), 
#&gt;                     list("\n", "Scale down or up the evaluator.\n", 
#&gt;                       list("\n", list(list(list("n_nodes"), " and ", 
#&gt;                         list("n_subnodes")), list(" see 'usage' ")), 
#&gt;                         "\n", list(list(list("create_if_missing")), 
#&gt;                           list("\n", "If the evaluator was previously terminated or shutdown, setting this to be\n", 
#&gt;                             "true ignores the `invalid` flags and re-initialize the evaluator\n")), 
#&gt;                         "\n", list(list(list("path")), list("\n", 
#&gt;                           "If ", list("create_if_missing"), " is true, then ", 
#&gt;                           list("path"), " will be passed to\n", 
#&gt;                           "the constructor of ", list(list("MasterEvaluator")), 
#&gt;                           ". See 'usage'.\n")), "\n"), "\n")), 
#&gt;                   "\n", "\n", "\n", list(list(list("workers(...)")), 
#&gt;                     list("\n", "Returns number of workers available in the evaluator. ", 
#&gt;                       list("`...`"), " is for\n", "debug use\n")), 
#&gt;                   "\n", "\n", list(list(list("progress()")), 
#&gt;                     list("\n", "Returns a vector of 4 integers. They are:\n", 
#&gt;                       list("\n", list(), list(" The total number evaluations. "), 
#&gt;                         "\n", list(), list(" Number of running evaluations. "), 
#&gt;                         "\n", list(), list(" Number of awaiting evaluations. "), 
#&gt;                         "\n", list(), list(" Number of finished evaluations. "), 
#&gt;                         "\n"), "\n")), "\n", "\n"), "\n")), "\n", 
#&gt;             "\n"), make_forked_clusters.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/parallels.R", 
#&gt;             "\n", list("make_forked_clusters"), "\n", list("make_forked_clusters"), 
#&gt;             "\n", list("Create forked clusters"), "\n", list(
#&gt;                 "\n", "make_forked_clusters(\n", "  workers = future::availableCores(constraints = \"multicore\"),\n", 
#&gt;                 "  ...\n", ")\n"), "\n", list("\n", list(list(
#&gt;                 "workers"), list("positive integer, number of cores to use")), 
#&gt;                 "\n", "\n", list(list("..."), list("passing to ", 
#&gt;                   list("future::plan"))), "\n"), "\n", list("\n", 
#&gt;                 "number of cores\n"), "\n", list("\n", "Create forked clusters\n"), 
#&gt;             "\n", list("\n", "This is a wrapper for ", list("future::plan(future::multicore, ...)"), 
#&gt;                 ".\n", "However, since version 1.14.0, forked clusters are disabled in `RStudio` by\n", 
#&gt;                 "default, and you usually need to enable it manually. This function provides\n", 
#&gt;                 "a simple way of enable it and plan the future at the same time.\n"), 
#&gt;             "\n"), map.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/map-s3.R", 
#&gt;             "\n", list("map"), "\n", list("map"), "\n", list(
#&gt;                 "session_map"), "\n", list("rds_map"), "\n", 
#&gt;             list("text_map"), "\n", list("qs_map"), "\n", list(
#&gt;                 "redis_map"), "\n", list("Create R object map."), 
#&gt;             "\n", list("\n", "session_map(map = fastmap::fastmap())\n", 
#&gt;                 "\n", "rds_map(path = tempfile())\n", "\n", "text_map(path = tempfile())\n", 
#&gt;                 "\n", "qs_map(path = tempfile())\n", "\n", "redis_map(name = rand_string())\n"), 
#&gt;             "\n", list("\n", list(list("map"), list("a ", list(
#&gt;                 "fastmap::fastmap()"), " list")), "\n", "\n", 
#&gt;                 list(list("path"), list("directory path where map data should be stored")), 
#&gt;                 "\n", "\n", list(list("name"), list("character, map name. If map names are the same, the data\n", 
#&gt;                   "will be shared.")), "\n"), "\n", list("\n", 
#&gt;                 "An ", list("R6"), " instance that inherits ", 
#&gt;                 list(list("AbstractMap")), "\n"), "\n", list(
#&gt;                 "\n", "Provides five types of map that fit in different use cases.\n"), 
#&gt;             "\n", list("\n", "There are five types of map implemented. They all inherit class\n", 
#&gt;                 list(list("AbstractMap")), ". There are several differences in\n", 
#&gt;                 "use case scenarios and they backend implementations.\n", 
#&gt;                 "\n", list("\n", list(list(list(list("session_map"))), 
#&gt;                   list("\n", "A session map takes a ", list(list(
#&gt;                     "fastmap")), " object. All objects are\n", 
#&gt;                     "stored in current R session. This means you cannot access the map from other\n", 
#&gt;                     "process nor parent process. The goal of this map is to share the data across\n", 
#&gt;                     "different environments and to store global variables, as long as they share\n", 
#&gt;                     "the same map object. If you are looking for maps that can be shared\n", 
#&gt;                     "by different processes, check the rest map types. The closest map type is\n", 
#&gt;                     list("redis_map"), ", which is also memory-based.\n")), 
#&gt;                   "\n", list(list(list(list("rds_map"))), list(
#&gt;                     "\n", "An 'RDS' map uses file system to store values. The values are stored\n", 
#&gt;                     "separately in '.rds' files. Compared to session maps, 'RDS' map can be\n", 
#&gt;                     "shared across different R process. It's recommended to store\n", 
#&gt;                     "large files in ", list("rds_map"), ". If the value is not large in RAM,\n", 
#&gt;                     list("text_map"), " and ", list("redis_map"), 
#&gt;                     " are recommended.\n")), "\n", list(list(
#&gt;                     list(list("qs_map"))), list("\n", "A 'qs' map uses package 'qs' as backend. This map is very similar to\n", 
#&gt;                     list("rds_map"), ", but is especially designed for large values. For example,\n", 
#&gt;                     "pushing 1GB data to ", list("qs_map"), " will be 100 times faster than using\n", 
#&gt;                     list("rds_map"), ", and ", list("text_map"), 
#&gt;                     " will almost fail. However, compared\n", 
#&gt;                     "to ", list("rds_map"), " the stored data cannot be normally read by R as they\n", 
#&gt;                     "are compressed binary files. And ", list(
#&gt;                       "qs_map"), " is heavier than\n", list("text_map"), 
#&gt;                     ".\n")), "\n", list(list(list(list("text_map"))), 
#&gt;                     list("\n", "A 'text' map uses file system to store values. Similar to ", 
#&gt;                       list("rds_map"), ",\n", "it can be stored across multiple processes as long as the maps share the\n", 
#&gt;                       "same file directory. However, unlike ", 
#&gt;                       list("rds_map"), ", ", list("text_map"), 
#&gt;                       "\n", "the ", list("text_map"), " can only store basic data values, namely atom data types.\n", 
#&gt;                       "The supported types are: numeric, character, vector, list, matrix\n", 
#&gt;                       "It's highly recommended to convert factors to characters. Do NOT use if the\n", 
#&gt;                       "values are functions or environments. Please check\n", 
#&gt;                       list(list("write_yaml")), " for details. The recommended use case scenario\n", 
#&gt;                       "is when the speed is not the major concern, and you want to preserve data\n", 
#&gt;                       "with backward compatibility. Otherwise it's highly recommended to use\n", 
#&gt;                       list("redis_map"), ", ", list("qs_map"), 
#&gt;                       ", and ", list("rds_map"), ".\n")), "\n", 
#&gt;                   list(list(list(list("redis_map"))), list("\n", 
#&gt;                     "A 'Redis' map uses free open source software `Redis` and R package\n", 
#&gt;                     "'RcppRedis' as backend. Compared to session map, 'Redis' map can be\n", 
#&gt;                     "shared across sessions. Compared to 'text' and 'rds' maps, 'Redis' map\n", 
#&gt;                     "stores data in memory, meaning a potential of significant speed ups. To use\n", 
#&gt;                     list("redis_map"), ", you need to install `Redis` on your computer.\n", 
#&gt;                     list("\n", "  ", list(), " On Mac: use `", 
#&gt;                       list("brew install redis"), "` to install and\n", 
#&gt;                       "    `", list("brew services start redis"), 
#&gt;                       "` to start the service\n", "  ", list(), 
#&gt;                       " On Linux: use `", list("sudo apt-get install redis-server"), 
#&gt;                       "` to install\n", "    and `", list("sudo systemctl enable redis-server.service"), 
#&gt;                       "` to start the\n", "    service\n", "  ", 
#&gt;                       list(), " On Windows: Download from\n", 
#&gt;                       "    ", list("https://github.com/dmajkic/redis/downloads"), 
#&gt;                       " and double click\n", "    'redis-server.exe'\n"), 
#&gt;                     "\n")), "\n"), "\n"), "\n", list("\n", "# ----------------------Basic Usage ----------------------\n", 
#&gt;                 "\n", "# Define a path to your map.\n", "path = tempfile()\n", 
#&gt;                 "map &lt;- qs_map(path)\n", "\n", "# Reset\n", "map$reset()\n", 
#&gt;                 "\n", "# Check if the map is corrupted.\n", "map$validate()\n", 
#&gt;                 "\n", "# You have not set any key-value pairs yet.\n", 
#&gt;                 "# Let's say two parallel processes (A and B) are sharing this map.\n", 
#&gt;                 "# Process A set values\n", "map$keys()\n", "\n", 
#&gt;                 "# Start push\n", "# set a normal message\n", 
#&gt;                 "map$set(key = 'a', value = 1)\n", "\n", "# set a large object\n", 
#&gt;                 "map$set(key = 'b', value = rnorm(100000))\n", 
#&gt;                 "\n", "# set an object with hash of another object\n", 
#&gt;                 "map$set(key = 'c', value = 2, signature = list(\n", 
#&gt;                 "  parameter1 = 123,\n", "  parameter2 = 124\n", 
#&gt;                 "))\n", "\n", "# Check what's in the map from process B\n", 
#&gt;                 "mapB &lt;- qs_map(path)\n", "mapB$keys()\n", "mapB$keys(include_signatures = TRUE)\n", 
#&gt;                 "\n", "# Number of key-values pairs in the map.\n", 
#&gt;                 "mapB$size()\n", "\n", "# Check if key exists\n", 
#&gt;                 "mapB$has(c('1','a', 'c'))\n", "\n", "# Check if key exists and signature also matches\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 123,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Signature changed, then return FALSE. This is especially useful when\n", 
#&gt;                 "# value is really large and reading the value takes tons of time\n", 
#&gt;                 "mapB$has('c', signature = list(\n", "  parameter1 = 1244444,\n", 
#&gt;                 "  parameter2 = 124\n", "))\n", "\n", "# Destroy the map's files altogether.\n", 
#&gt;                 "mapB$destroy()\n", "\n", list("\n", "  # Once destroyed, validate will raise error\n", 
#&gt;                   "  mapB$validate()\n"), "\n", "\n", "\n"), 
#&gt;             "\n"), match_calls.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("match_calls"), "\n", list("match_calls"), 
#&gt;             "\n", list("Recursively match calls and modify arguments"), 
#&gt;             "\n", list("\n", "match_calls(\n", "  call,\n", "  recursive = TRUE,\n", 
#&gt;                 "  replace_args = list(),\n", "  quoted = FALSE,\n", 
#&gt;                 "  envir = parent.frame(),\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("call"), list("an ", list(
#&gt;                 "R"), " expression")), "\n", "\n", list(list(
#&gt;                 "recursive"), list("logical, recursively match calls, default is true")), 
#&gt;                 "\n", "\n", list(list("replace_args"), list("named list of functions, see examples")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("logical, is ", 
#&gt;                   list("call"), " quoted")), "\n", "\n", list(
#&gt;                   list("envir"), list("which environment should call be evaluated")), 
#&gt;                 "\n", "\n", list(list("..."), list("other parameters passing to ", 
#&gt;                   list("match.call"))), "\n"), "\n", list("\n", 
#&gt;                 "A nested call with all arguments matched\n"), 
#&gt;             "\n", list("\n", "Recursively match calls and modify arguments\n"), 
#&gt;             "\n", list("\n", "library(dipsaus); library(shiny)\n", 
#&gt;                 "\n", "# In shiny modules, we might want to add ns() to inputIds\n", 
#&gt;                 "# In this example, textInput(id) will become textInput(ns(id))\n", 
#&gt;                 "match_calls(lapply(1:20, function(i){\n", "  textInput(paste('id_', i), paste('Label ', i))\n", 
#&gt;                 "}), replace_args = list(\n", "  inputId = function(arg, call){ as.call(list(quote(ns), arg)) }\n", 
#&gt;                 "))\n", "\n"), "\n"), mem_limit2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("mem_limit2"), "\n", list("mem_limit2"), 
#&gt;             "\n", list("Get max RAM size\n", "This is an experimental function that is designed for non-windows systems"), 
#&gt;             "\n", list("\n", "mem_limit2()\n"), "\n", list("\n", 
#&gt;                 "a list of total free memory.\n"), "\n", list(
#&gt;                 "\n", "Get max RAM size\n", "This is an experimental function that is designed for non-windows systems\n"), 
#&gt;             "\n"), no_op.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/language.R", 
#&gt;             "\n", list("no_op"), "\n", list("no_op"), "\n", list(
#&gt;                 "Pipe-friendly no-operation function"), "\n", 
#&gt;             list("\n", "no_op(.x, .expr, ..., .check_fun = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list(".x"), list("any R object")), 
#&gt;                 "\n", "\n", list(list(".expr"), list("R expression that produces side effects")), 
#&gt;                 "\n", "\n", list(list("..., .check_fun"), list(
#&gt;                   "see `details`")), "\n"), "\n", list("\n", 
#&gt;                 "The value of ", list(".x"), "\n"), "\n", list(
#&gt;                 "\n", "returns the first input with side effects\n"), 
#&gt;             "\n", list("\n", list("no_op"), " is a pipe-friendly function that takes any values in,\n", 
#&gt;                 "evaluate expressions but still returns input. This is very useful when\n", 
#&gt;                 "you have the same input across multiple functions and you want to use pipes.\n", 
#&gt;                 "\n", list(".expr"), " is evaluated with a special object ", 
#&gt;                 list("'.'"), ", you can use\n", list("'.'"), 
#&gt;                 " to represent ", list(".x"), " in ", list(".expr"), 
#&gt;                 ". For example, if\n", list(".x=1:100"), ", then ", 
#&gt;                 list("plot(x=seq(0,1,length.out = 100), y=.)"), 
#&gt;                 " is\n", "equivalent to ", list("plot(x=seq(0,1,length.out = 100), y=1:100)"), 
#&gt;                 ".\n", "\n", list(".check_fun"), " checks whether ", 
#&gt;                 list(".expr"), " returns a function, if yes,\n", 
#&gt;                 "then the function is called with argument ", 
#&gt;                 list(".x"), " and ", list("..."), "\n"), "\n", 
#&gt;             list("\n", "\n", "library(magrittr)\n", "\n", "## 1. Basic usage\n", 
#&gt;                 "\n", "# Will print('a') and return 'a'\n", "no_op('a', print)\n", 
#&gt;                 "\n", "# Will do nothing and return 'a' because .check_fun is false\n", 
#&gt;                 "no_op('a', print, .check_fun = FALSE)\n", "\n", 
#&gt;                 "# Will print('a') and return 'a'\n", "no_op('a', print(.), .check_fun = FALSE)\n", 
#&gt;                 "\n", "## 2. Toy example\n", "library(graphics)\n", 
#&gt;                 "\n", "par(mfrow = c(2,2))\n", "x &lt;- rnorm(100)\n", 
#&gt;                 "\n", "# hist and plot share the same input `rnorm(100)`\n", 
#&gt;                 "\n", "x %&gt;%\n", "  # .expr is a function, all ... are passed as other arguments\n", 
#&gt;                 "  no_op( hist, nclass = 10 ) %&gt;%\n", "  no_op( plot, x = seq(0,1,length.out = 100) ) %&gt;%\n", 
#&gt;                 "\n", "  # Repeat the previous two plots, but with different syntax\n", 
#&gt;                 "  no_op({ hist(., nclass = 10) }) %&gt;%\n", "  no_op({ plot(x = seq(0,1,length.out = 100), y = .) }) %&gt;%\n", 
#&gt;                 "\n", "  # The return statement is ignored\n", 
#&gt;                 "\n", "  no_op({ return(x + 1)}) -&gt;\n", "  y\n", 
#&gt;                 "\n", "# x is returned at the end\n", "\n", "identical(x, y)   # TRUE\n", 
#&gt;                 "\n"), "\n"), package_installed.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("package_installed"), "\n", list("package_installed"), 
#&gt;             "\n", list("Check if a package is installed"), "\n", 
#&gt;             list("\n", "package_installed(pkgs, all = FALSE)\n"), 
#&gt;             "\n", list("\n", list(list("pkgs"), list("vector of package names")), 
#&gt;                 "\n", "\n", list(list("all"), list("only returns TRUE if all packages are installed. Default is FALSE.")), 
#&gt;                 "\n"), "\n", list("\n", "logical, if packages are installed or not. If ", 
#&gt;                 list("all=TRUE"), ", return\n", "a logical value of whether all packages a re installed.\n"), 
#&gt;             "\n", list("\n", "Check if a package is installed\n"), 
#&gt;             "\n", list("\n", "\n", "# Check if package base and dipsaus are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'))\n", 
#&gt;                 "\n", "# Check if all required packages are installed\n", 
#&gt;                 "package_installed(c('base', 'dipsaus'), all = TRUE)\n", 
#&gt;                 "\n"), "\n"), parse_svec.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("parse_svec"), "\n", list("parse_svec"), 
#&gt;             "\n", list("Parse Text Into Numeric Vectors\n", "\n", 
#&gt;                 "(stable)"), "\n", list("\n", "parse_svec(text, sep = \",\", connect = \"-:|\", sort = FALSE, unique = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("text"), list("string with chunks, e.g. ", 
#&gt;                 list("\"1-10, 14, 16-20, 18-30\""), " has 4 chunks")), 
#&gt;                 "\n", "\n", list(list("sep"), list("default is \",\", character used to separate chunks")), 
#&gt;                 "\n", "\n", list(list("connect"), list("characters defining connection links for example \"1:10\" is the same as \"1-10\"")), 
#&gt;                 "\n", "\n", list(list("sort"), list("sort the result")), 
#&gt;                 "\n", "\n", list(list("unique"), list("extract unique elements")), 
#&gt;                 "\n"), "\n", list("\n", "a numeric vector. For example, \"1-3\" returns ", 
#&gt;                 list("c(1, 2, 3)"), "\n"), "\n", list("\n", "Parse Text Into Numeric Vectors\n", 
#&gt;                 "\n", "(stable)\n"), "\n", list("\n", "parse_svec('1-10, 13:15,14-20')\n"), 
#&gt;             "\n", list("\n", list(list("deparse_svec")), "\n"), 
#&gt;             "\n"), prepare_install.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils-package.R", 
#&gt;             "\n", list("prepare_install"), "\n", list("prepare_install"), 
#&gt;             "\n", list("Install Packages at Next Startup"), "\n", 
#&gt;             list("\n", "prepare_install(\n", "  packages,\n", 
#&gt;                 "  update_all = FALSE,\n", "  restart = FALSE,\n", 
#&gt;                 "  repos = getOption(\"repos\")\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("packages"), list("characters, vector of package names")), 
#&gt;                 "\n", "\n", list(list("update_all"), list("whether to update all installed packages before\n", 
#&gt;                   "installation; default is false")), "\n", "\n", 
#&gt;                 list(list("restart"), list("whether to restart session automatically")), 
#&gt;                 "\n", "\n", list(list("repos"), list("repositories to search for packages")), 
#&gt;                 "\n"), "\n", list("\n", "None\n"), "\n", list(
#&gt;                 "\n", "Register temporary code that will install packages at\n", 
#&gt;                 "next session. The code will be automatically removed once executed.\n"), 
#&gt;             "\n", list("\n", "Installing packages in R session could require restarts if\n", 
#&gt;                 "a package to be updated has been loaded. Normally restarting R\n", 
#&gt;                 "fixes the problem. However, under some circumstances, such as with a\n", 
#&gt;                 "startup code in profile, restarting R might still fail the\n", 
#&gt;                 "installation. ", list("prepare_install"), " inserts the installation\n", 
#&gt;                 "code prior to the startup code so that next time the code will get\n", 
#&gt;                 "executed before any other packages are loaded.\n", 
#&gt;                 "Once the temporary code get executed, no matter succeeded or not,\n", 
#&gt;                 "it will be removed from startup profile.\n"), 
#&gt;             "\n"), progress2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-progress.R", 
#&gt;             "\n", list("progress2"), "\n", list("progress2"), 
#&gt;             "\n", list("'Shiny' progress bar, but can run without reactive context"), 
#&gt;             "\n", list("\n", "progress2(\n", "  title,\n", "  max = 1,\n", 
#&gt;                 "  ...,\n", "  quiet = FALSE,\n", "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  shiny_auto_close = FALSE,\n", "  log = NULL\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("title"), 
#&gt;                 list("character, task description")), "\n", "\n", 
#&gt;                 list(list("max"), list("maximum number of items in the queue")), 
#&gt;                 "\n", "\n", list(list("..."), list("passed to ", 
#&gt;                   list("shiny::Progress$new(...)"))), "\n", "\n", 
#&gt;                 list(list("quiet"), list("suppress console output, ignored in shiny context.")), 
#&gt;                 "\n", "\n", list(list("session"), list("'shiny' session, default is current reactive domain")), 
#&gt;                 "\n", "\n", list(list("shiny_auto_close"), list(
#&gt;                   "logical, automatically close 'shiny' progress bar\n", 
#&gt;                   "once current observer is over. Default is ", 
#&gt;                   list("FALSE"), ". If setting to\n", list("TRUE"), 
#&gt;                   ", then it's equivalent to\n", list("p &lt;- progress2(...); on.exit({p$close()}, add = TRUE)"), 
#&gt;                   ".")), "\n", "\n", list(list("log"), list("function when running locally, default is ", 
#&gt;                   list("NULL"), ",\n", "which redirects to ", 
#&gt;                   list(list("cat2")))), "\n"), "\n", list("\n", 
#&gt;                 "A list of functions:\n", list("\n", list(list(
#&gt;                   list("inc(detail, message = NULL, amount = 1, ...)")), 
#&gt;                   list("\n", "Increase progress bar by ", list(
#&gt;                     "amount"), " (default is 1).\n")), "\n", 
#&gt;                   list(list(list("close()")), list("\n", "Close the progress\n")), 
#&gt;                   "\n", list(list(list("reset(detail = '', message = '', value = 0)")), 
#&gt;                     list("\n", "Reset the progress to ", list(
#&gt;                       "value"), " (default is 0), and reset information\n")), 
#&gt;                   "\n", list(list(list("get_value()")), list(
#&gt;                     "\n", "Get current progress value\n")), "\n", 
#&gt;                   list(list(list("is_closed()")), list("\n", 
#&gt;                     "Returns logical value if the progress is closed or not.\n")), 
#&gt;                   "\n"), "\n"), "\n", list("\n", "'Shiny' progress bar, but can run without reactive context\n"), 
#&gt;             "\n", list("\n", "\n", "progress &lt;- progress2('Task A', max = 2)\n", 
#&gt;                 "progress$inc('Detail 1')\n", "progress$inc('Detail 2')\n", 
#&gt;                 "progress$close()\n", "\n", "# Check if progress is closed\n", 
#&gt;                 "progress$is_closed()\n", "\n", "# ------------------------------ Shiny Example ------------------------------\n", 
#&gt;                 "library(shiny)\n", "library(dipsaus)\n", "\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  actionButtonStyled('do', 'Click Here', type = 'primary')\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    updateActionButtonStyled(session, 'do', disabled = TRUE)\n", 
#&gt;                 "    progress &lt;- progress2('Task A', max = 10, shiny_auto_close = TRUE)\n", 
#&gt;                 "    lapply(1:10, function(ii){\n", "      progress$inc(sprintf('Detail %d', ii))\n", 
#&gt;                 "      Sys.sleep(0.2)\n", "    })\n", "    updateActionButtonStyled(session, 'do', disabled = FALSE)\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         registerInputBinding.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-inputbindings.R", 
#&gt;             "\n", list("registerInputBinding"), "\n", list("registerInputBinding"), 
#&gt;             "\n", list("Register customized input to enable support by compound input"), 
#&gt;             "\n", list("\n", "registerInputBinding(fname, pkg, shiny_binding, update_function = NULL)\n"), 
#&gt;             "\n", list("\n", list(list("fname"), list("character, function name, such as ", 
#&gt;                 list("\"textInput\""))), "\n", "\n", list(list(
#&gt;                 "pkg"), list("character, package name, like ", 
#&gt;                 list("\"shiny\""))), "\n", "\n", list(list("shiny_binding"), 
#&gt;                 list("character, 'JavaScript' binding name.See examples")), 
#&gt;                 "\n", "\n", list(list("update_function"), list(
#&gt;                   "character, update function such as ", list(
#&gt;                     "\"shiny::textInput\""))), "\n"), "\n", list(
#&gt;                 "\n", "a list of binding functions, one is `JavaScript` object key in\n", 
#&gt;                 list("Shiny.inputBindings"), ", the other is `shiny` update function in R end.\n"), 
#&gt;             "\n", list("\n", "Register customized input to enable support by compound input\n"), 
#&gt;             "\n", list("\n", "\n", "# register shiny textInput\n", 
#&gt;                 "registerInputBinding('textInput', 'shiny',\n", 
#&gt;                 "                     'shiny.textInput', 'shiny::updateTextInput')\n", 
#&gt;                 "\n", "# Register shiny actionLink\n", "# In \"Shiny.inputbindings\", the binding name is \"shiny.actionButtonInput\",\n", 
#&gt;                 "# Shiny update function is \"shiny::updateActionButton\"\n", 
#&gt;                 "registerInputBinding('actionLink', 'shiny',\n", 
#&gt;                 "                     'shiny.actionButtonInput', 'shiny::updateActionButton')\n", 
#&gt;                 "\n"), "\n"), screenshot.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/screenshot.R", 
#&gt;             "\n", list("screenshot"), "\n", list("screenshot"), 
#&gt;             "\n", list("Take a screenshot in shiny apps"), "\n", 
#&gt;             list("\n", "screenshot(inputId, session = shiny::getDefaultReactiveDomain())\n"), 
#&gt;             "\n", list("\n", list(list("inputId"), list("the input id where the screenshot should be")), 
#&gt;                 "\n", "\n", list(list("session"), list("shiny session")), 
#&gt;                 "\n"), "\n", list("\n", "None. However, the screenshot results can be accessed from\n", 
#&gt;                 "shiny input\n"), "\n", list("\n", "Take a screenshot of the whole page and save encoded\n", 
#&gt;                 list("DataURI"), " that can be accessed via ", 
#&gt;                 list("input[[inputId]]"), ".\n"), "\n", list(
#&gt;                 "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  tagList(\n", "    shiny::singleton(shiny::tags$head(\n", 
#&gt;                 "      shiny::tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"dipsaus/dipsaus.css\"),\n", 
#&gt;                 "      shiny::tags$script(src=\"dipsaus/dipsaus-dipterix-lib.js\")\n", 
#&gt;                 "    ))\n", "  ),\n", "  actionButtonStyled('do', 'Take Screenshot'),\n", 
#&gt;                 "  compoundInput2('group', label = 'Group', components = list(\n", 
#&gt;                 "    textInput('txt', 'Enter something here')\n", 
#&gt;                 "  ))\n", ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  observeEvent(input$do, {\n", "    screenshot('screeshot_result')\n", 
#&gt;                 "  })\n", "  observeEvent(input$screeshot_result, {\n", 
#&gt;                 "    showModal(modalDialog(\n", "      tags$img(src = input$screeshot_result, width = '100%')\n", 
#&gt;                 "    ))\n", "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         set_shiny_input.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("set_shiny_input"), "\n", list("set_shiny_input"), 
#&gt;             "\n", list("Set Shiny Input"), "\n", list("\n", "set_shiny_input(\n", 
#&gt;                 "  session = shiny::getDefaultReactiveDomain(),\n", 
#&gt;                 "  inputId,\n", "  value,\n", "  priority = c(\"event\", \"deferred\", \"immediate\"),\n", 
#&gt;                 "  method = c(\"proxy\", \"serialize\", \"value\", \"expression\"),\n", 
#&gt;                 "  quoted = TRUE\n", ")\n"), "\n", list("\n", 
#&gt;                 list(list("session"), list("shiny session, see shiny ", 
#&gt;                   list(list("domains")))), "\n", "\n", list(list(
#&gt;                   "inputId"), list("character, input ID")), "\n", 
#&gt;                 "\n", list(list("value"), list("the value to assign")), 
#&gt;                 "\n", "\n", list(list("priority"), list("characters, options are \"event\", \"deferred\", and \"immediate\".\n", 
#&gt;                   "\"event\" and \"immediate\" are similar, they always fire changes. \"deferred\"\n", 
#&gt;                   "fire signals to other reactive/observers only when the input value has been\n", 
#&gt;                   "changed")), "\n", "\n", list(list("method"), 
#&gt;                   list("characters, options are \"proxy\", \"serialize\", \"value\",\n", 
#&gt;                     "\"expression\". \"proxy\" is recommended, other methods are experimental.")), 
#&gt;                 "\n", "\n", list(list("quoted"), list("is value quoted? Only used when method is \"expression\"")), 
#&gt;                 "\n"), "\n", list("\n", "Shiny `input' object is read-only reactive list. When try to\n", 
#&gt;                 "assign values to input, errors usually occur. This method provides several\n", 
#&gt;                 "work-around to set values to input. Please use along with\n", 
#&gt;                 list(list("use_shiny_dipsaus")), ".\n"), "\n", 
#&gt;             list("\n", "\n", "library(shiny)\n", "library(dipsaus)\n", 
#&gt;                 "ui &lt;- fluidPage(\n", "  # Register widgets\n", 
#&gt;                 "  use_shiny_dipsaus(),\n", "  actionButton('run', 'Set Input'),\n", 
#&gt;                 "  verbatimTextOutput('input_value')\n", ")\n", 
#&gt;                 "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  start = Sys.time()\n", "\n", "  output$input_value &lt;- renderPrint({\n", 
#&gt;                 "\n", "    now &lt;- input$key\n", "    now %?&lt;-% start\n", 
#&gt;                 "    cat('This app has been opened for ',\n", 
#&gt;                 "        difftime(now, start, units = 'sec'), ' seconds')\n", 
#&gt;                 "  })\n", "\n", "  observeEvent(input$run, {\n", 
#&gt;                 "    # setting input$key to Sys.time()\n", "    set_shiny_input(session, 'key', Sys.time())\n", 
#&gt;                 "  })\n", "}\n", "\n", "if(interactive()){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n", "\n"), 
#&gt;             "\n"), shift_array.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/cpp-collapse.R", 
#&gt;             "\n", list("shift_array"), "\n", list("shift_array"), 
#&gt;             "\n", list("Shift Array by Index"), "\n", list("\n", 
#&gt;                 "shift_array(x, shift_idx, shift_by, shift_amount)\n"), 
#&gt;             "\n", list("\n", list(list("x"), list("array, must have at least matrix")), 
#&gt;                 "\n", "\n", list(list("shift_idx"), list("which index is to be shifted")), 
#&gt;                 "\n", "\n", list(list("shift_by"), list("which dimension decides ", 
#&gt;                   list("shift_amount"))), "\n", "\n", list(list(
#&gt;                   "shift_amount"), list("shift amount along ", 
#&gt;                   list("shift_idx"))), "\n"), "\n", list("\n", 
#&gt;                 "Re-arrange arrays in parallel\n"), "\n", list(
#&gt;                 "\n", "A simple use-case for this function is to think of a matrix where each row\n", 
#&gt;                 "is a signal and columns stand for time. The objective is to align (time-lock)\n", 
#&gt;                 "each signal according to certain events. For each signal, we want to shift\n", 
#&gt;                 "the time points by certain amount.\n", "\n", 
#&gt;                 "In this case, the shift amount is defined by ", 
#&gt;                 list("shift_amount"), ", whose\n", "length equals to number of signals. ", 
#&gt;                 list("shift_idx=2"), " as we want to shift\n", 
#&gt;                 "time points (column, the second dimension) for each signal. ", 
#&gt;                 list("shift_by=1"), "\n", "because the shift amount is depend on the signal number.\n"), 
#&gt;             "\n", list("\n", "x &lt;- matrix(1:10, nrow = 2, byrow = TRUE)\n", 
#&gt;                 "z &lt;- shift_array(x, 2, 1, c(1,2))\n", "\n", 
#&gt;                 "y &lt;- NA * x\n", "y[1,1:4] = x[1,2:5]\n", "y[2,1:3] = x[2,3:5]\n", 
#&gt;                 "\n", "# Check if z ang y are the same\n", "z - y\n", 
#&gt;                 "\n", "# array case\n", "# x is Trial x Frequency x Time\n", 
#&gt;                 "x &lt;- array(1:27, c(3,3,3))\n", "\n", "# Shift time for each trial, amount is 1, -1, 0\n", 
#&gt;                 "shift_amount &lt;- c(1,-1,0)\n", "z &lt;- shift_array(x, 3, 1, shift_amount)\n", 
#&gt;                 "par(mfrow = c(3, 2))\n", "for( ii in 1:3 ){\n", 
#&gt;                 "  image(t(x[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Trial', ii))\n", "  image(t(z[ii, ,]), ylab = 'Frequency', xlab = 'Time',\n", 
#&gt;                 "        main = paste('Shifted amount:', shift_amount[ii]))\n", 
#&gt;                 "}\n", "\n"), "\n"), sync_shiny_inputs.Rd = list(
#&gt;             "% Generated by roxygen2: do not edit by hand", "\n", 
#&gt;             "% Please edit documentation in R/shiny-syncInputs.R", 
#&gt;             "\n", list("sync_shiny_inputs"), "\n", list("sync_shiny_inputs"), 
#&gt;             "\n", list("Synchronize Shiny Inputs"), "\n", list(
#&gt;                 "\n", "sync_shiny_inputs(\n", "  input,\n", "  session,\n", 
#&gt;                 "  inputIds,\n", "  uniform = rep(\"I\", length(inputIds)),\n", 
#&gt;                 "  updates,\n", "  snap = 250\n", ")\n"), "\n", 
#&gt;             list("\n", list(list("input, session"), list("shiny reactive objects")), 
#&gt;                 "\n", "\n", list(list("inputIds"), list("input ids to be synchronized")), 
#&gt;                 "\n", "\n", list(list("uniform"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", converting inputs\n", 
#&gt;                   "to a uniform values")), "\n", "\n", list(list(
#&gt;                   "updates"), list("functions, equaling to length of ", 
#&gt;                   list("inputIds"), ", updating input values")), 
#&gt;                 "\n", "\n", list(list("snap"), list("numeric, milliseconds to defer the changes")), 
#&gt;                 "\n"), "\n", list("\n", "none.\n"), "\n", list(
#&gt;                 "\n", "Synchronize Shiny Inputs\n"), "\n", list(
#&gt;                 "\n", "\n", "library(shiny)\n", "\n", "ui &lt;- fluidPage(\n", 
#&gt;                 "  textInput('a', 'a', value = 'a'),\n", "  sliderInput('b', 'b', value = 1, min = 0, max = 1000)\n", 
#&gt;                 ")\n", "\n", "server &lt;- function(input, output, session) {\n", 
#&gt;                 "  sync_shiny_inputs(input, session, inputIds = c('a', 'b'), uniform = list(\n", 
#&gt;                 "    function(a){as.numeric(a)},\n", "    'I'\n", 
#&gt;                 "  ), updates = list(\n", "    function(a){updateTextInput(session, 'a', value = a)},\n", 
#&gt;                 "    function(b){updateSliderInput(session, 'b', value = b)}\n", 
#&gt;                 "  ))\n", "\n", "}\n", "\n", "if( interactive() ){\n", 
#&gt;                 "  shinyApp(ui, server)\n", "}\n", "\n"), "\n"), 
#&gt;         time_delta.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/utils.R", 
#&gt;             "\n", list("time_delta"), "\n", list("time_delta"), 
#&gt;             "\n", list("Calculate time difference and return a number"), 
#&gt;             "\n", list("\n", "time_delta(t1, t2, units = \"secs\")\n"), 
#&gt;             "\n", list("\n", list(list("t1"), list("time start")), 
#&gt;                 "\n", "\n", list(list("t2"), list("time end")), 
#&gt;                 "\n", "\n", list(list("units"), list("character, choices are ", 
#&gt;                   list("'secs'"), ", ", list("'mins'"), ", ", 
#&gt;                   list("'hours'"), ", and ", list("'days'"))), 
#&gt;                 "\n"), "\n", list("\n", "numeric difference of time in units specified\n"), 
#&gt;             "\n", list("\n", "Calculate time difference and return a number\n"), 
#&gt;             "\n", list("\n", "a = Sys.time()\n", "Sys.sleep(0.3)\n", 
#&gt;                 "b = Sys.time()\n", "\n", "time_delta(a, b) # In seconds, around 0.3\n", 
#&gt;                 "time_delta(a, b, 'mins') # in minutes, around 0.005\n", 
#&gt;                 "\n"), "\n"), to_datauri.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_datauri"), "\n", list("to_datauri"), 
#&gt;             "\n", list("Convert file to 'base64' format"), "\n", 
#&gt;             list("\n", "to_datauri(file, mime = \"\")\n"), "\n", 
#&gt;             list("\n", list(list("file"), list("file path")), 
#&gt;                 "\n", "\n", list(list("mime"), list("'mime' type, default is blank")), 
#&gt;                 "\n"), "\n", list("\n", "a 'base64' data string looks like ", 
#&gt;                 list("'data:;base64,AEF6986...'"), "\n"), "\n", 
#&gt;             list("\n", "Convert file to 'base64' format\n"), 
#&gt;             "\n"), to_ram_size.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/strings.R", 
#&gt;             "\n", list("to_ram_size"), "\n", list("to_ram_size"), 
#&gt;             "\n", list("Convert bytes to KB, MB, GB,..."), "\n", 
#&gt;             list("\n", "to_ram_size(s, kb_to_b = 1000)\n"), "\n", 
#&gt;             list("\n", list(list("s"), list("size")), "\n", "\n", 
#&gt;                 list(list("kb_to_b"), list("how many bytes counts one KB, 1000 by default")), 
#&gt;                 "\n"), "\n", list("\n", "numeric equaling to ", 
#&gt;                 list("s"), " but formatted\n"), "\n", list("\n", 
#&gt;                 "Convert bytes to KB, MB, GB,...\n"), "\n"), 
#&gt;         updateActionButtonStyled.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-actionbutton-styled.R", 
#&gt;             "\n", list("updateActionButtonStyled"), "\n", list(
#&gt;                 "updateActionButtonStyled"), "\n", list("Update styled action button"), 
#&gt;             "\n", list("\n", "updateActionButtonStyled(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  label = NULL,\n", "  icon = NULL,\n", 
#&gt;                 "  type = NULL,\n", "  disabled = NULL,\n", "  ...\n", 
#&gt;                 ")\n"), "\n", list("\n", list(list("session, inputId, label, icon"), 
#&gt;                 list("passed to ", list("shiny::updateActionButton"))), 
#&gt;                 "\n", "\n", list(list("type"), list("button type to update")), 
#&gt;                 "\n", "\n", list(list("disabled"), list("whether to disable the button")), 
#&gt;                 "\n", "\n", list(list("..."), list("ignored")), 
#&gt;                 "\n"), "\n", list("\n", "none\n"), "\n", list(
#&gt;                 "\n", "Update styled action button\n"), "\n", 
#&gt;             list("\n", list(list("actionButtonStyled")), " for how to define the button.\n"), 
#&gt;             "\n"), updateCompoundInput2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-compoundInput2.R", 
#&gt;             "\n", list("updateCompoundInput2"), "\n", list("updateCompoundInput2"), 
#&gt;             "\n", list("Update compound inputs"), "\n", list(
#&gt;                 "\n", "updateCompoundInput2(\n", "  session,\n", 
#&gt;                 "  inputId,\n", "  value = NULL,\n", "  ncomp = NULL,\n", 
#&gt;                 "  initialization = NULL,\n", "  ...\n", ")\n"), 
#&gt;             "\n", list("\n", list(list("session"), list("shiny session or session proxy")), 
#&gt;                 "\n", "\n", list(list("inputId"), list("character see ", 
#&gt;                   list("compoundInput2"))), "\n", "\n", list(
#&gt;                   list("value"), list("list of lists, see ", 
#&gt;                     list("compoundInput2"), " or examples")), 
#&gt;                 "\n", "\n", list(list("ncomp"), list("integer, non-negative number of groups to update, ", 
#&gt;                   list("NULL"), " to\n", "remain unchanged")), 
#&gt;                 "\n", "\n", list(list("initialization, ..."), 
#&gt;                   list("named list of other updates")), "\n"), 
#&gt;             "\n", list("\n", "none\n"), "\n", list("\n", "Update compound inputs\n"), 
#&gt;             "\n", list("\n", "\n", list("\n", "library(shiny); library(dipsaus)\n", 
#&gt;                 "\n", "## UI side\n", "compoundInput2(\n", "  'input_id', 'Group',\n", 
#&gt;                 "    div(\n", "    textInput('text', 'Text Label'),\n", 
#&gt;                 "    sliderInput('sli', 'Slider Selector', value = 0, min = 1, max = 1)\n", 
#&gt;                 "  ),\n", "  label_color = 1:10,\n", "  value = list(\n", 
#&gt;                 "    list(text = '1'),  # Set text first group to be \"1\"\n", 
#&gt;                 "    '',                # no settings for second group\n", 
#&gt;                 "    list(sli = 0.2)    # sli = 0.2 for the third group\n", 
#&gt;                 "  ))\n", "\n", "## server side:\n", "updateCompoundInput2(session, 'inputid',\n", 
#&gt;                 "                     # Change the first 3 groups\n", 
#&gt;                 "                     value = lapply(1:3, function(ii){\n", 
#&gt;                 "                       list(sli = runif(1))\n", 
#&gt;                 "                     }),\n", "                     # Change text label for all groups\n", 
#&gt;                 "                     initialization = list(\n", 
#&gt;                 "                       text = list(label = as.character(Sys.time()))\n", 
#&gt;                 "                     ))\n"), "\n", "\n"), "\n", 
#&gt;             list("\n", list(list("compoundInput2")), " for how to define components.\n"), 
#&gt;             "\n"), update_fastmap2.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/fastmap2.R", 
#&gt;             "\n", list("update_fastmap2"), "\n", list("update_fastmap2"), 
#&gt;             "\n", list("Migrate a ", list("fastmap2"), " object to a new one"), 
#&gt;             "\n", list("\n", "update_fastmap2(from, to, override = TRUE)\n"), 
#&gt;             "\n", list("\n", list(list("from, to"), list(list(
#&gt;                 "fastmap2"), " object")), "\n", "\n", list(list(
#&gt;                 "override"), list("whether to override keys in ", 
#&gt;                 list("to"), " if they exist")), "\n"), "\n", 
#&gt;             list("\n", "Map ", list("to"), "\n"), "\n", list(
#&gt;                 "\n", "Migrate a ", list("fastmap2"), " object to a new one\n"), 
#&gt;             "\n", list("\n", list(list("fastmap2")), "\n"), "\n"), 
#&gt;         use_shiny_dipsaus.Rd = list("% Generated by roxygen2: do not edit by hand", 
#&gt;             "\n", "% Please edit documentation in R/shiny-setInputs.R", 
#&gt;             "\n", list("use_shiny_dipsaus"), "\n", list("use_shiny_dipsaus"), 
#&gt;             "\n", list("Set up shiny plugins"), "\n", list("\n", 
#&gt;                 "use_shiny_dipsaus()\n"), "\n", list("\n", "This function must be called from a Shiny app's UI in order for\n", 
#&gt;                 "some widgets to work.\n"), "\n")), source = list(
#&gt;         AbstractMap.Rd = "R/map-abstract.R", AbstractQueue.Rd = "R/queue-abstract.R", 
#&gt;         MasterEvaluator.Rd = "R/parallels-workers.R", PersistContainer.Rd = "R/persist.R", 
#&gt;         actionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         ask_or_default.Rd = "R/strings.R", ask_yesno.Rd = "R/strings.R", 
#&gt;         async.Rd = "R/parallels.R", async_expr.Rd = "R/parallels.R", 
#&gt;         async_flapply.Rd = "R/parallels.R", base64_to_image.Rd = "R/screenshot.R", 
#&gt;         baseline_array.Rd = "R/cpp-baseline_array.R", cat2.Rd = "R/strings.R", 
#&gt;         check_installed_packages.Rd = "R/utils-package.R", col2hexStr.Rd = "R/strings.R", 
#&gt;         collapse.Rd = "R/cpp-collapse.R", compoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         decorate_function.Rd = "R/language.R", deparse_svec.Rd = "R/strings.R", 
#&gt;         dev_create.Rd = "R/graphics.R", do_aggregate.Rd = "R/apply.R", 
#&gt;         drop_nulls.Rd = "R/utils.R", eval_dirty.Rd = "R/language.R", 
#&gt;         fastmap2.Rd = "R/fastmap2.R", forelse.Rd = "R/apply.R", 
#&gt;         getInputBinding.Rd = "R/shiny-inputbindings.R", get_cpu.Rd = "R/systems.R", 
#&gt;         get_dots.Rd = "R/language.R", get_ram.Rd = "R/systems.R", 
#&gt;         `grapes-equals-greater-than-grapes.Rd` = "R/language.R", 
#&gt;         `grapes-help-set-grapes.Rd` = "R/language.R", `grapes-plus-grapes.Rd` = "R/language.R", 
#&gt;         handler_dipsaus_progress.Rd = "R/shiny-progress.R", iapply.Rd = "R/apply.R", 
#&gt;         lapply_async2.Rd = "R/parallels-future.R", lock.Rd = "R/lock.R", 
#&gt;         make_async_evaluator.Rd = "R/parallels-workers.R", make_forked_clusters.Rd = "R/parallels.R", 
#&gt;         map.Rd = "R/map-s3.R", match_calls.Rd = "R/language.R", 
#&gt;         mem_limit2.Rd = "R/strings.R", no_op.Rd = "R/language.R", 
#&gt;         package_installed.Rd = "R/utils-package.R", parse_svec.Rd = "R/strings.R", 
#&gt;         prepare_install.Rd = "R/utils-package.R", progress2.Rd = "R/shiny-progress.R", 
#&gt;         registerInputBinding.Rd = "R/shiny-inputbindings.R", 
#&gt;         screenshot.Rd = "R/screenshot.R", set_shiny_input.Rd = "R/shiny-setInputs.R", 
#&gt;         shift_array.Rd = "R/cpp-collapse.R", sync_shiny_inputs.Rd = "R/shiny-syncInputs.R", 
#&gt;         time_delta.Rd = "R/utils.R", to_datauri.Rd = "R/strings.R", 
#&gt;         to_ram_size.Rd = "R/strings.R", updateActionButtonStyled.Rd = "R/shiny-actionbutton-styled.R", 
#&gt;         updateCompoundInput2.Rd = "R/shiny-compoundInput2.R", 
#&gt;         update_fastmap2.Rd = "R/fastmap2.R", use_shiny_dipsaus.Rd = "R/shiny-setInputs.R"), 
#&gt;         keywords = list(character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0)), concepts = list(
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0), character(0), character(0), 
#&gt;             character(0), character(0)), internal = c(FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
#&gt;         FALSE)), tutorials = list(name = character(0), file_out = character(0), 
#&gt;         title = character(0), pagetitle = character(0), url = character(0)), 
#&gt;     vignettes = list(name = c("async_evaluator", "r_expr_addons", 
#&gt;     "shiny_customized_widgets", "utility_functions"), file_in = c("vignettes/async_evaluator.Rmd", 
#&gt;     "vignettes/r_expr_addons.Rmd", "vignettes/shiny_customized_widgets.Rmd", 
#&gt;     "vignettes/utility_functions.Rmd"), file_out = c("articles/async_evaluator.html", 
#&gt;     "articles/r_expr_addons.html", "articles/shiny_customized_widgets.html", 
#&gt;     "articles/utility_functions.html"), title = c("Asynchronous Evaluator", 
#&gt;     "R Expression Add-ons", "Shiny Customized Widgets", "Utility Functions"
#&gt;     ), description = c(NA_character_, NA_character_, NA_character_, 
#&gt;     NA_character_)), topic_index = c(`[.fastmap2` = "fastmap2", 
#&gt;     `[[.fastmap2` = "fastmap2", `[[&lt;-.fastmap2` = "fastmap2", 
#&gt;     `[&lt;-.fastmap2` = "fastmap2", `%?&lt;-%` = "grapes-help-set-grapes", 
#&gt;     `%+-%` = "grapes-plus-grapes", `%=&gt;%` = "grapes-equals-greater-than-grapes", 
#&gt;     `%D%` = "decorate_function", `$.fastmap2` = "fastmap2", `$&lt;-.fastmap2` = "fastmap2", 
#&gt;     AbstractMap = "AbstractMap", AbstractQueue = "AbstractQueue", 
#&gt;     actionButtonStyled = "actionButtonStyled", as.list.fastmap2 = "fastmap2", 
#&gt;     ask_or_default = "ask_or_default", ask_yesno = "ask_yesno", 
#&gt;     async = "async", async_expr = "async_expr", async_flapply = "async_flapply", 
#&gt;     base64_to_image = "base64_to_image", baseline_array = "baseline_array", 
#&gt;     cat2 = "cat2", check_installed_packages = "check_installed_packages", 
#&gt;     col2hexStr = "col2hexStr", collapse = "collapse", compoundInput2 = "compoundInput2", 
#&gt;     decorate_function = "decorate_function", deparse_svec = "deparse_svec", 
#&gt;     dev_create = "dev_create", dipsaus_lock = "lock", dipsaus_unlock = "lock", 
#&gt;     do_aggregate = "do_aggregate", drop_nulls = "drop_nulls", 
#&gt;     eval_dirty = "eval_dirty", fastmap2 = "fastmap2", forelse = "forelse", 
#&gt;     get_cpu = "get_cpu", get_dots = "get_dots", get_ram = "get_ram", 
#&gt;     getInputBinding = "getInputBinding", handler_dipsaus_progress = "handler_dipsaus_progress", 
#&gt;     iapply = "iapply", lapply_async2 = "lapply_async2", length.fastmap2 = "fastmap2", 
#&gt;     lock = "lock", make_async_evaluator = "make_async_evaluator", 
#&gt;     make_forked_clusters = "make_forked_clusters", map = "map", 
#&gt;     MasterEvaluator = "MasterEvaluator", match_calls = "match_calls", 
#&gt;     mem_limit2 = "mem_limit2", names.fastmap2 = "fastmap2", no_op = "no_op", 
#&gt;     package_installed = "package_installed", parse_svec = "parse_svec", 
#&gt;     PersistContainer = "PersistContainer", prepare_install = "prepare_install", 
#&gt;     print.fastmap2 = "fastmap2", progress2 = "progress2", qs_map = "map", 
#&gt;     rds_map = "map", redis_map = "map", registerInputBinding = "registerInputBinding", 
#&gt;     screenshot = "screenshot", session_map = "map", set_shiny_input = "set_shiny_input", 
#&gt;     shift_array = "shift_array", sync_shiny_inputs = "sync_shiny_inputs", 
#&gt;     text_map = "map", time_delta = "time_delta", to_datauri = "to_datauri", 
#&gt;     to_ram_size = "to_ram_size", update_fastmap2 = "update_fastmap2", 
#&gt;     updateActionButtonStyled = "updateActionButtonStyled", updateCompoundInput2 = "updateCompoundInput2", 
#&gt;     use_shiny_dipsaus = "use_shiny_dipsaus"), article_index = c(async_evaluator = "async_evaluator.html", 
#&gt;     r_expr_addons = "r_expr_addons.html", shiny_customized_widgets = "shiny_customized_widgets.html", 
#&gt;     utility_functions = "utility_functions.html")), examples = TRUE, 
#&gt;     run_dont_run = FALSE, seed = 1014, lazy = FALSE, override = list(), 
#&gt;     install = FALSE, preview = FALSE, new_process = FALSE, devel = FALSE, 
#&gt;     crayon_enabled = TRUE, crayon_colors = 256, pkgdown_internet = TRUE)
#&gt; 
#&gt; [[13]]
#&gt; pkgdown::build_site(...)
#&gt; 
#&gt; [[14]]
#&gt; build_site_local(pkg = pkg, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, lazy = lazy, override = override, preview = preview, 
#&gt;     devel = devel)
#&gt; 
#&gt; [[15]]
#&gt; build_reference(pkg, lazy = lazy, examples = examples, run_dont_run = run_dont_run, 
#&gt;     seed = seed, override = override, preview = FALSE, devel = devel)
#&gt; 
#&gt; [[16]]
#&gt; purrr::map(topics, build_reference_topic, pkg = pkg, lazy = lazy, 
#&gt;     examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[17]]
#&gt; .f(.x[[i]], ...)
#&gt; 
#&gt; [[18]]
#&gt; data_reference_topic(topic, pkg, examples = examples, run_dont_run = run_dont_run)
#&gt; 
#&gt; [[19]]
#&gt; run_examples(tags$tag_examples[[1]], env = new.env(parent = globalenv()), 
#&gt;     topic = tools::file_path_sans_ext(topic$file_in), run_examples = examples, 
#&gt;     run_dont_run = run_dont_run)
#&gt; 
#&gt; [[20]]
#&gt; highlight_examples(code, topic, env = env)
#&gt; 
#&gt; [[21]]
#&gt; evaluate::evaluate(x, child_env(env), new_device = TRUE)
#&gt; 
#&gt; [[22]]
#&gt; evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos, 
#&gt;     debug = debug, last = i == length(out), use_try = stop_on_error != 
#&gt;         2L, keep_warning = keep_warning, keep_message = keep_message, 
#&gt;     output_handler = output_handler, include_timing = include_timing)
#&gt; 
#&gt; [[23]]
#&gt; handle(pv &lt;- withCallingHandlers(withVisible(value_fun(ev$value, 
#&gt;     ev$visible)), warning = wHandler, error = eHandler, message = mHandler))
#&gt; 
#&gt; [[24]]
#&gt; try(f, silent = TRUE)
#&gt; 
#&gt; [[25]]
#&gt; tryCatch(expr, error = function(e) {
#&gt;     call &lt;- conditionCall(e)
#&gt;     if (!is.null(call)) {
#&gt;         if (identical(call[[1L]], quote(doTryCatch))) 
#&gt;             call &lt;- sys.call(-4L)
#&gt;         dcall &lt;- deparse(call)[1L]
#&gt;         prefix &lt;- paste("Error in", dcall, ": ")
#&gt;         LONG &lt;- 75L
#&gt;         sm &lt;- strsplit(conditionMessage(e), "\n")[[1L]]
#&gt;         w &lt;- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")
#&gt;         if (is.na(w)) 
#&gt;             w &lt;- 14L + nchar(dcall, type = "b") + nchar(sm[1L], 
#&gt;                 type = "b")
#&gt;         if (w &gt; LONG) 
#&gt;             prefix &lt;- paste0(prefix, "\n  ")
#&gt;     }
#&gt;     else prefix &lt;- "Error : "
#&gt;     msg &lt;- paste0(prefix, conditionMessage(e), "\n")
#&gt;     .Internal(seterrmessage(msg[1L]))
#&gt;     if (!silent &amp;&amp; isTRUE(getOption("show.error.messages"))) {
#&gt;         cat(msg, file = outFile)
#&gt;         .Internal(printDeferredWarnings())
#&gt;     }
#&gt;     invisible(structure(msg, class = "try-error", condition = e))
#&gt; })
#&gt; 
#&gt; [[26]]
#&gt; tryCatchList(expr, classes, parentenv, handlers)
#&gt; 
#&gt; [[27]]
#&gt; tryCatchOne(expr, names, parentenv, handlers[[1L]])
#&gt; 
#&gt; [[28]]
#&gt; doTryCatch(return(expr), name, parentenv, handler)
#&gt; 
#&gt; [[29]]
#&gt; withCallingHandlers(withVisible(value_fun(ev$value, ev$visible)), 
#&gt;     warning = wHandler, error = eHandler, message = mHandler)
#&gt; 
#&gt; [[30]]
#&gt; withVisible(value_fun(ev$value, ev$visible))
#&gt; 
#&gt; [[31]]
#&gt; value_fun(ev$value, ev$visible)
#&gt; 
#&gt; [[32]]
#&gt; value_handler(x)
#&gt; 
#&gt; [[33]]
#&gt; print(x)
#&gt; 
#&gt; [[34]]
#&gt; print.default(x)
#&gt; 
#&gt; [[35]]
#&gt; (function (x, ...) 
#&gt; UseMethod("print"))(x)
#&gt; 
#&gt; [[36]]
#&gt; print.progression_handler(x)
#&gt; 
#&gt; Progression calling handler of class ‘progression_handler’:
#&gt;  * configuration:
#&gt;    - name: ‘&lt;NULL&gt;’
#&gt;    - max_steps: &lt;NULL&gt;
#&gt;    - enable: FALSE
#&gt;    - enable_after: 0 seconds
#&gt;    - times: 0
#&gt;    - interval: 0 seconds
#&gt;    - intrusiveness: 1
#&gt;    - auto_finish: TRUE
#&gt;    - clear: TRUE
#&gt;    - target: ‘terminal’
#&gt;    - milestones: &lt;NULL&gt;
#&gt;    - owner: &lt;NULL&gt;
#&gt;  * state:
#&gt;    - enabled: FALSE
#&gt;    - finished: FALSE
#&gt;    - step: &lt;NULL&gt;
#&gt;    - message: &lt;NULL&gt;
#&gt;    - prev_milestone: &lt;NULL&gt;
#&gt;    - timestamps: &lt;NULL&gt;
#&gt; </div><div class='input'><span class='fu'><a href='https://rdrr.io/pkg/progressr/man/with_progress.html'>with_progress</a></span>({
  <span class='no'>p</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/progressr/man/progressor.html'>progressor</a></span>(<span class='kw'>along</span> <span class='kw'>=</span> <span class='no'>xs</span>)
  <span class='no'>y</span> <span class='kw'>&lt;-</span> <span class='kw pkg'>future.apply</span><span class='kw ns'>::</span><span class='fu'><a href='https://rdrr.io/pkg/future.apply/man/future_lapply.html'>future_lapply</a></span>(<span class='no'>xs</span>, <span class='kw'>function</span>(<span class='no'>x</span>) {
    <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/builder.html'>p</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/sprintf.html'>sprintf</a></span>(<span class='st'>"x=%g"</span>, <span class='no'>x</span>))
    <span class='fu'><a href='https://rdrr.io/r/base/Sys.sleep.html'>Sys.sleep</a></span>(<span class='fl'>0.1</span>)
    <span class='fu'><a href='https://rdrr.io/r/base/MathFun.html'>sqrt</a></span>(<span class='no'>x</span>)
  })
})

<span class='co'># ------------------------ A shiny case --------------------------------</span>

<span class='no'>ui</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/fluidPage.html'>fluidPage</a></span>(
  <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/actionButton.html'>actionButton</a></span>(<span class='st'>'ok'</span>, <span class='st'>'Run Demo'</span>)
)

<span class='no'>server</span> <span class='kw'>&lt;-</span> <span class='kw'>function</span>(<span class='no'>input</span>, <span class='no'>output</span>, <span class='no'>session</span>) {
  <span class='fu'><a href='https://rdrr.io/pkg/progressr/man/handlers.html'>handlers</a></span>(<span class='fu'>handler_dipsaus_progress</span>())
  <span class='fu'><a href='make_forked_clusters.html'>make_forked_clusters</a></span>()

  <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/observeEvent.html'>observeEvent</a></span>(<span class='no'>input</span>$<span class='no'>ok</span>, {
    <span class='fu'><a href='https://rdrr.io/pkg/progressr/man/with_progress.html'>with_progress</a></span>({
      <span class='no'>p</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/progressr/man/progressor.html'>progressor</a></span>(<span class='kw'>along</span> <span class='kw'>=</span> <span class='fl'>1</span>:<span class='fl'>100</span>)
      <span class='no'>y</span> <span class='kw'>&lt;-</span> <span class='kw pkg'>future.apply</span><span class='kw ns'>::</span><span class='fu'><a href='https://rdrr.io/pkg/future.apply/man/future_lapply.html'>future_lapply</a></span>(<span class='fl'>1</span>:<span class='fl'>100</span>, <span class='kw'>function</span>(<span class='no'>x</span>) {
        <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/builder.html'>p</a></span>(<span class='fu'><a href='https://rdrr.io/r/base/sprintf.html'>sprintf</a></span>(<span class='st'>"Input %d|Result %d"</span>, <span class='no'>x</span>, <span class='no'>x</span>+<span class='fl'>1</span>))
        <span class='fu'><a href='https://rdrr.io/r/base/Sys.sleep.html'>Sys.sleep</a></span>(<span class='fl'>1</span>)
        <span class='no'>x</span>+<span class='fl'>1</span>
      })
    })
  })
}

<span class='kw'>if</span>(<span class='fu'><a href='https://rdrr.io/r/base/interactive.html'>interactive</a></span>()){
  <span class='fu'><a href='https://rdrr.io/pkg/shiny/man/shinyApp.html'>shinyApp</a></span>(<span class='no'>ui</span>, <span class='no'>server</span>)
}</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Zhengjia Wang.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.5.0.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


