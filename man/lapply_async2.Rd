% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallels-future.R
\name{lapply_async2}
\alias{lapply_async2}
\title{Apply, but in parallel}
\usage{
lapply_async2(
  x,
  FUN,
  FUN.args = list(),
  env = environment(FUN),
  callback = NULL,
  plan = TRUE,
  ...
)
}
\arguments{
\item{x}{vector, list}

\item{FUN}{function to apply on each element of \code{x}}

\item{FUN.args}{more arguments to feed into \code{FUN}}

\item{env}{environment to run, default to \code{FUN}'s environment}

\item{callback}{function to run after each iteration}

\item{plan}{logical, or character or \code{future} plan; see Details.}

\item{...}{passed to \code{\link[future]{plan}}}
}
\value{
same as
\code{with(FUN.args, lapply(x, function(el){eval(body(FUN))}))}
}
\description{
Apply, but in parallel
}
\details{
When \code{plan} is logical, \code{FALSE} means use current plan.
If \code{plan=TRUE}, then it equals to \code{plan='multicore'}. For
characters, \code{plan} can be \code{'multicore'}, \code{'callr'},
\code{'sequential'}, \code{'multisession'}, \code{'multiprocess'},
etc. Alternatively, you could pass future \code{\link[future]{plan}}
objects.
}
