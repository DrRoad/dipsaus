% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zzz-finalizers.R
\name{shared_finalizer}
\alias{shared_finalizer}
\title{Create Shared Finalizers to Avoid Over Garbage Collection}
\usage{
shared_finalizer(key, env, fin, onexit = FALSE)
}
\arguments{
\item{key}{characters that should be identical to shared finalizers}

\item{env}{object to finalize. Must be an environment}

\item{fin}{Shared finalizer: function to call on finalization;
see \code{\link{reg.finalizer}}}

\item{onexit}{logical: should the finalizer be run if the object is
still uncollected at the end of the R session?
See \code{\link{reg.finalizer}}}
}
\description{
Generates a function to be passed to
\code{\link{reg.finalizer}}
}
\details{
The main purpose of this function is to allow multiple
objects that point to a same source (say a temporary file) to
perform clean up when all the objects are garbage collected.

Base function \code{\link{reg.finalizer}} provides finalization
to to garbage collect single R environment. However, when multiple
environments share the same file, finalizing one single environment
will result in removing the file so that all the other environment
lose the reference. (See example "Native \code{reg.finalizer}
fails example")
}
\examples{
#'
file_exists <- TRUE
clear_files <- function(e){
  print('Clean some shared files')
  # do something to remove files
  file_exists <<- FALSE
}

# e1, e2 both require file existence
e1 <- new.env()
e1$valid <- function(){ file_exists }
e2 <- new.env()
e2$valid <- function(){ file_exists }

e1$valid(); e2$valid()

# we don't want to remove files when either e1,e2 gets
# garbage collected, however, we want to run `clear_files`
# when system garbage collecting *both* e1 and e2

# Make sure `key`s are identical
e1_fin <- shared_finalizer('cleanXXXfiles', e1, clear_files)
e2_fin <- shared_finalizer('cleanXXXfiles', e2, clear_files)

reg.finalizer(e1, e1_fin)
reg.finalizer(e2, e2_fin)

# Now remove e1, files are not cleaned, and e2 is still valid
rm(e1); gc()
e2$valid()  # TRUE
file_exists # TRUE

# remove both e1 and e2, and file gets removed
rm(e2); gc()
file_exists  # FALSE


# ------------ Native reg.finalizer fails example ------------
file_exists <- TRUE
clear_files <- function(e){
  print('Clean some shared files')
  # do something to remove files
  file_exists <<- FALSE
}

# e1, e2 both require file existence
e1 <- new.env()
e1$valid <- function(){ file_exists }
e2 <- new.env()
e2$valid <- function(){ file_exists }

reg.finalizer(e1, clear_files)
reg.finalizer(e2, clear_files)
gc()
file_exists

# removing e1 will invalidate e2
rm(e1); gc()
e2$valid()    # FALSE

}
